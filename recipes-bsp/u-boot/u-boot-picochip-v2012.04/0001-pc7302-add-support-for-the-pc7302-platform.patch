From 9e8220f164e2197631420c98fd1ae1e5397a9077 Mon Sep 17 00:00:00 2001
From: Dave Aldridge <david.aldridge@picochip.com>
Date: Wed, 13 Apr 2011 11:31:37 +0100
Subject: [PATCH 01/70] pc7302: add support for the pc7302 platform

---
 MAKEALL                                     |    1 +
 Makefile                                    |    6 +
 arch/arm/cpu/arm926ejs/pc3xx/Makefile       |   70 ++
 arch/arm/cpu/arm926ejs/pc3xx/emac.c         |  889 +++++++++++++++++++
 arch/arm/cpu/arm926ejs/pc3xx/gpio.c         | 1075 ++++++++++++++++++++++
 arch/arm/cpu/arm926ejs/pc3xx/mux.c          | 1274 +++++++++++++++++++++++++++
 arch/arm/cpu/arm926ejs/pc3xx/reset.S        |   63 ++
 arch/arm/cpu/arm926ejs/pc3xx/serial.c       |  279 ++++++
 arch/arm/cpu/arm926ejs/pc3xx/spi.c          |  704 +++++++++++++++
 arch/arm/cpu/arm926ejs/pc3xx/timer.c        |  146 +++
 arch/arm/cpu/arm926ejs/pc3xx/utilities.c    |  243 +++++
 arch/arm/include/asm/arch-pc3xx/axi2cfg.h   |  162 ++++
 arch/arm/include/asm/arch-pc3xx/ebi.h       |  184 ++++
 arch/arm/include/asm/arch-pc3xx/emac.h      |  189 ++++
 arch/arm/include/asm/arch-pc3xx/fuse.h      |   76 ++
 arch/arm/include/asm/arch-pc3xx/gpio.h      |   74 ++
 arch/arm/include/asm/arch-pc3xx/mem_arm.h   |  129 +++
 arch/arm/include/asm/arch-pc3xx/mem_shd.h   |  395 +++++++++
 arch/arm/include/asm/arch-pc3xx/mux.h       |   53 ++
 arch/arm/include/asm/arch-pc3xx/pa.h        |   40 +
 arch/arm/include/asm/arch-pc3xx/pc302.h     |   92 ++
 arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h |  214 +++++
 arch/arm/include/asm/arch-pc3xx/spi.h       |   98 ++
 arch/arm/include/asm/arch-pc3xx/timer.h     |   85 ++
 arch/arm/include/asm/arch-pc3xx/uart.h      |  158 ++++
 arch/arm/include/asm/arch-pc3xx/utilities.h |  133 +++
 arch/arm/include/asm/arch-pc3xx/wdog.h      |   60 ++
 board/picochip/pc7302/Makefile              |   47 +
 board/picochip/pc7302/config.mk             |   26 +
 board/picochip/pc7302/lowlevel_init.S       |  426 +++++++++
 board/picochip/pc7302/mt29f2g08aadwp.c      |  199 +++++
 board/picochip/pc7302/pc7302.c              |  245 +++++
 boards.cfg                                  |    2 +
 include/configs/picochippc7302-common.h     |  388 ++++++++
 include/configs/picochippc7302nand.h        |   86 ++
 include/configs/picochippc7302nor.h         |   80 ++
 include/netdev.h                            |    1 +
 37 files changed, 8392 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/Makefile
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/emac.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/gpio.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/mux.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/reset.S
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/serial.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/spi.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/timer.c
 create mode 100644 arch/arm/cpu/arm926ejs/pc3xx/utilities.c
 create mode 100644 arch/arm/include/asm/arch-pc3xx/axi2cfg.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/ebi.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/emac.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/fuse.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/gpio.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/mem_arm.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/mem_shd.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/mux.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/pa.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/pc302.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/spi.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/timer.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/uart.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/utilities.h
 create mode 100644 arch/arm/include/asm/arch-pc3xx/wdog.h
 create mode 100644 board/picochip/pc7302/Makefile
 create mode 100644 board/picochip/pc7302/config.mk
 create mode 100644 board/picochip/pc7302/lowlevel_init.S
 create mode 100644 board/picochip/pc7302/mt29f2g08aadwp.c
 create mode 100644 board/picochip/pc7302/pc7302.c
 create mode 100644 include/configs/picochippc7302-common.h
 create mode 100644 include/configs/picochippc7302nand.h
 create mode 100644 include/configs/picochippc7302nor.h

diff --git a/MAKEALL b/MAKEALL
index e5da6f1..5efb424 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -321,6 +321,7 @@ LIST_SA="$(boards_by_cpu sa1100)"
 LIST_ARM9="$(boards_by_cpu arm920t)	\
 	$(boards_by_cpu arm926ejs)	\
 	$(boards_by_cpu arm925t)	\
+	picochippc7302          \
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index cdd4294..7796fc7 100644
--- a/Makefile
+++ b/Makefile
@@ -685,6 +685,12 @@ SX1_config:		unconfig
 	fi;
 	@$(MKCONFIG) -n $@ SX1 arm arm925t sx1
 
+picochippc7302nand_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip pc3xx
+
+picochippc7302nor_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip pc3xx
+
 #########################################################################
 ## ARM1176 Systems
 #########################################################################
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/Makefile b/arch/arm/cpu/arm926ejs/pc3xx/Makefile
new file mode 100644
index 0000000..3d5d755
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/Makefile
@@ -0,0 +1,70 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief
+#*
+#* Copyright (c) 2006-2011 Picochip Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+SOBJS-y := reset.o
+
+COBJS-y += emac.o
+COBJS-y += serial.o
+COBJS-y += timer.o
+COBJS-y += spi.o
+COBJS-y += utilities.o
+COBJS-y += mux.o
+COBJS-y += gpio.o
+
+SRCS    := $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS    := $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/emac.c b/arch/arm/cpu/arm926ejs/pc3xx/emac.c
new file mode 100644
index 0000000..0e63c1a
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/emac.c
@@ -0,0 +1,889 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file emac.c
+* \brief Ethernet driver for the PC302.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_DW_EMAC
+
+#include <malloc.h>
+#include <asm/errno.h>
+#include <net.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/emac.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/*!
+ * \brief Timeout value (in uS) for various EMAC operations
+ */
+#define EMAC_TX_TIMEOUT             (1000)
+
+/*!
+ * \brief Timeout value (in mS) for various PHY operations
+ */
+#define EMAC_PHY_TIMEOUT            (2000)
+
+/*!
+ * \brief Length (in bytes) of a MAC address
+ */
+#define EMAC_LENGTH_OF_MAC_ADDRESS  (6)
+
+/*!
+ * \brief Default receive and transmit ring lengths
+ */
+#define EMAC_RX_NUM_DESCRIPTOR      (8)
+#define EMAC_TX_NUM_DESCRIPTOR      (2)
+#define EMAC_DESCRIPTOR_BUF_SIZE    (2048)
+
+/*!
+ * \brief Values used in the emac_priv structure
+ */
+#define EMAC_PHY_SPEED_10           (0)
+#define EMAC_PHY_SPEED_100          (1)
+#define EMAC_PHY_DUPLEX_HALF        (0)
+#define EMAC_PHY_DUPLEX_FULL        (1)
+#define EMAC_PHY_LINK_DOWN          (0)
+#define EMAC_PHY_LINK_UP            (1)
+#define EMAC_PHY_AUTO_NEG_COMPLETE  (1)
+
+/*!
+ * \brief Macros used to read from, and write to, emac registers
+ */
+#define EMAC_READ(__offset) \
+                 (*((volatile u32*)(PC302_EMAC_BASE + __offset)))
+
+#define EMAC_WRITE(__value, __offset) \
+                  (*((volatile u32*)(PC302_EMAC_BASE + __offset)) = __value)
+
+/*!
+ * \brief Define the auto-negotiation advertisement register
+ *        value.
+ *
+ * Note: This advertises 100 mpbs capability only.
+ */
+#define PHY_AUTO_NEG_ADVERT_VALUE   (0x0181)
+
+/*!
+ * \brief Align an item to a 64-bit boundary.
+ */
+#define __align64b	    __attribute__((aligned(8)))
+
+/* Constants --------------------------------------------------------------- */
+
+/*!
+ * \brief This structure defines the format of the Ethernet MAC
+ *        Tx and Rx descriptors.
+ */
+struct emac_dma_descriptor
+{
+    /*! Used to define the Rx/Tx buffer address */
+    unsigned int buffer;
+
+    /*! Used to contain the status of the Rx/Tx operation */
+    unsigned int status;
+};
+
+/*!
+ * \brief This structure is used to hold private data for the network code
+ */
+struct emac_priv
+{
+    /* Useful phy state */
+    unsigned int auto_negotiation;
+    unsigned int speed;
+    unsigned int duplex;
+    unsigned int link;
+
+    /* Rx descriptor count */
+    unsigned int rx_desc;
+
+    /* Tx descriptor count */
+    unsigned int tx_desc;
+};
+
+/*!
+ * \brief Assign some memory for the Rx descriptors
+ */
+static volatile struct
+emac_dma_descriptor __align64b rx_descriptor[EMAC_RX_NUM_DESCRIPTOR];
+
+/*!
+ * \brief Assign some memory for the Tx descriptors
+ */
+static volatile struct
+emac_dma_descriptor __align64b tx_descriptor[EMAC_TX_NUM_DESCRIPTOR];
+
+/*!
+ * \brief Assign some memory for the Rx buffers
+ * \n Note: The Rx buffers have to be 64 bit aligned otherwise
+ *          very bad things happen.
+ */
+static unsigned char __align64b
+rx_buffer[EMAC_RX_NUM_DESCRIPTOR][EMAC_DESCRIPTOR_BUF_SIZE];
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/*!
+ *
+ * \brief Read a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to read from
+ * \return The value read
+ *
+ */
+static unsigned short emac_mii_read(unsigned int phy_id,
+                                    unsigned int register_number);
+
+/*!
+ *
+ * \brief Write to a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to write to
+ * \param data The data to write
+ *
+ */
+static void emac_mii_write(unsigned int phy_id,
+                           unsigned int register_number,
+                           unsigned short data);
+
+#if defined (CONFIG_CMD_MII)
+static int pc302emac_miiphy_read(char *devname,
+                                 uchar addr,
+                                 uchar reg,
+                                 ushort *val);
+
+static int pc302emac_miiphy_write(char *devname,
+                                  uchar addr,
+                                  uchar reg,
+                                  ushort val);
+#endif /*CONFIG_CMD_MII */
+
+/*!
+ *
+ * \brief Initialise the emac mdio interface
+ *
+ */
+static void emac_init_mdio(void);
+
+/*!
+ *
+ * \brief Initialise the phy connected to the emac management port.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static int emac_init_phy(struct eth_device *dev);
+
+/*!
+ *
+ * \brief Obtain the link status from the phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_phy_get_link_status(struct eth_device *dev);
+
+/*!
+ *
+ * \brief Set up the MAC address in the emac.
+ *
+ * \param dev Pointer to the eth_device structure
+ * \return Zero on success, non zero on error.
+ *
+ */
+static int emac_set_mac_addr(struct eth_device *dev);
+
+/*!
+ *
+ * \brief Initialise the emac registers.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_startup(struct eth_device *dev);
+
+/*!
+ *
+ * \brief Initialise the emac buffer descriptors and phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param bis Pointer to the board init structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_open(struct eth_device *dev, bd_t *bis);
+
+/*!
+ *
+ * \brief Receive a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_rx_packet(struct eth_device *dev);
+
+/*!
+ *
+ * \brief Transmit a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param packet Pointer to the packet data to transmit
+ * \param length  Length (in bytes) of the packet to send
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_tx_packet(struct eth_device *dev,
+                          volatile void *packet,
+                          int length);
+
+/*!
+ *
+ * \brief Stop the emac
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_halt(struct eth_device *dev);
+
+/* Functions --------------------------------------------------------------- */
+
+static unsigned short emac_mii_read(unsigned int phy_id,
+                                    unsigned int register_number)
+{
+    unsigned int write_data = 0x60020000;
+    unsigned int phy_management_idle = 0;
+    unsigned short value_read = 0;
+
+    /* Mask input parameters */
+    phy_id &= EMAC_PHY_ID_MASK;
+    register_number &= EMAC_PHY_REG_MASK;
+
+    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+                  (register_number << EMAC_PHY_REG_SHIFT));
+
+    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Wait for the phy access to complete */
+    do
+    {
+        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
+        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+    }
+    while(!phy_management_idle);
+
+    /* Read back the data obtained from the phy */
+    value_read = (unsigned short)EMAC_READ(EMAC_PHY_MAINTAIN_REG_OFFSET);
+    return(value_read);
+}
+
+static void emac_mii_write(unsigned int phy_id,
+                           unsigned int register_number,
+                           unsigned short data)
+{
+    unsigned int write_data = 0x50020000;
+    unsigned int phy_management_idle = 0;
+
+    /* Mask input parameters */
+    phy_id &= EMAC_PHY_ID_MASK;
+    register_number &= EMAC_PHY_REG_MASK;
+
+    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+                   (register_number << EMAC_PHY_REG_SHIFT) | data);
+    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+    /* Wait for the phy access to complete */
+    do
+    {
+        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
+        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+    }
+    while (!phy_management_idle);
+}
+
+#if defined (CONFIG_CMD_MII)
+static int pc302emac_miiphy_read(char *devname, uchar addr, uchar reg, ushort *val)
+{
+    /* Make sure the mdio bus is initialised */
+    emac_init_mdio();
+
+    /* Perform the mii bus read */
+    *val = emac_mii_read((unsigned int)addr,(unsigned int)reg);
+    return 0;
+}
+
+static int pc302emac_miiphy_write(char *devname, uchar addr, uchar reg, ushort val)
+{
+    /* Make sure the mdio bus is initialised */
+    emac_init_mdio();
+
+    /* Perform the mdio bis write */
+    emac_mii_write((unsigned int)addr,(unsigned int)reg, (unsigned short)val);
+    return 0;
+}
+#endif /*CONFIG_CMD_MII */
+
+static void emac_init_mdio(void)
+{
+    unsigned int network_control_register = 0;
+    unsigned int network_config_register = 0;
+
+    /* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
+    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
+    network_config_register &= ~(EMAC_MDC_CLOCK_DIV_MASK);
+    network_config_register |= EMAC_MDC_CLOCK_DIV_96;
+    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Enable phy management */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= EMAC_MDIO_ENABLE;
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+}
+
+static int emac_init_phy(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+
+    unsigned int device_id = pc302_read_device_id();
+    unsigned int device_rev = pc302_read_device_revision();
+
+    /* Setup the MDIO bus for Phy communications */
+    emac_init_mdio ();
+
+    /* If we are running on PC3x2 Rev D silicon and we are using a
+     * Reduced MII (RMII) connected Ethernet Phy then we need the
+     * link speed to be 100 mbps.
+     */
+    if (((device_id == PC302_DEVICE_ID) || (device_id == PC312_DEVICE_ID)) &&
+         (device_rev == PC3X2_REV_D) &&
+         pc302_get_rmii_enabled())
+    {
+        /* Are we already set for 100 mpbs ? */
+        emac_phy_get_link_status(dev);
+        if (priv->speed == EMAC_PHY_SPEED_100)
+        {
+            /* No need to do anything */
+        }
+        else
+        {
+            /* Setup the phy auto-negotiation advertisement register */
+            emac_mii_write(CONFIG_PHY_ADDR, MII_ADVERTISE,
+                           PHY_AUTO_NEG_ADVERT_VALUE);
+
+            /* Re-start auto-negotiation */
+            emac_mii_write(CONFIG_PHY_ADDR, MII_BMCR,
+                           (BMCR_ANENABLE | BMCR_ANRESTART));
+
+            /* Allow some time for the auto-negotiation process to start */
+            udelay(100);
+        }
+    }
+
+    /* Get the phy status */
+    emac_phy_get_link_status(dev);
+
+    if (priv->link == EMAC_PHY_LINK_DOWN)
+    {
+        /* Oops, no valid link established, time to bail out */
+        printf("%s: Link down !\n", dev->name);
+        return (-1);
+    }
+    else
+    {
+        /* We have a valid link established
+         * so we can report the phy setup
+         */
+        printf("%s: Link up\n", dev->name);
+
+        if (priv->auto_negotiation == EMAC_PHY_AUTO_NEG_COMPLETE)
+        {
+            printf("%s: Auto-Negotiation complete\n", dev->name);
+        }
+
+        if (priv->speed == EMAC_PHY_SPEED_100)
+        {
+            printf("%s: 100Mbps\n", dev->name);
+        }
+        else
+        {
+            printf("%s: 10Mbps\n", dev->name);
+        }
+
+        if (priv->duplex == EMAC_PHY_DUPLEX_FULL)
+        {
+            printf("%s: Full-duplex\n", dev->name);
+        }
+        else
+        {
+            printf("%s: Half-duplex\n", dev->name);
+        }
+    }
+    return(0);
+}
+
+static void emac_phy_get_link_status(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned short phy_control = 0;
+    unsigned short phy_status = 0;
+    unsigned short ana = 0;
+    unsigned short anlpa = 0;
+    unsigned int timebase = 0;
+
+    /* Initialise the phy status parameters in the private data structure */
+    priv->auto_negotiation = ~(EMAC_PHY_AUTO_NEG_COMPLETE);
+    priv->link = EMAC_PHY_LINK_DOWN;
+    priv->speed = EMAC_PHY_SPEED_10;
+    priv->duplex = EMAC_PHY_DUPLEX_HALF;
+
+    /* Check to make sure the phy has auto-negotiation enabled */
+    phy_control = emac_mii_read(CONFIG_PHY_ADDR, MII_BMCR);
+    if (phy_control & BMCR_ANENABLE)
+    {
+        /* Auto-negotiation is enabled
+         * now need to check on auto-negotiation progress
+         */
+        phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
+        if (phy_status & BMSR_ANEGCAPABLE)
+        {
+            /* The phy is auto-negotiation capable */
+            timebase = get_timer(0);
+            do
+            {
+                phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
+                if (phy_status & BMSR_ANEGCOMPLETE)
+                {
+                    /* Auto-negotiation has completed */
+                    priv->auto_negotiation = EMAC_PHY_AUTO_NEG_COMPLETE;
+                    break;
+                }
+            }
+            while (get_timer (timebase) < EMAC_PHY_TIMEOUT);
+
+            if (phy_status & BMSR_LSTATUS)
+            {
+                /* We have a valid link established */
+                priv->link = EMAC_PHY_LINK_UP;
+            }
+            else
+            {
+                /* We do not have a valid link established */
+                priv->link = EMAC_PHY_LINK_DOWN;
+            }
+
+            /* Read the auto-negotiation advertisement register */
+            ana = emac_mii_read(CONFIG_PHY_ADDR, MII_ADVERTISE);
+
+            /* Read the auto-negotiation link partner ability register */
+            anlpa = emac_mii_read(CONFIG_PHY_ADDR, MII_LPA);
+
+            anlpa &= ana;
+
+            if (anlpa & (LPA_100FULL | LPA_100HALF))
+            {
+                priv->speed = EMAC_PHY_SPEED_100;
+
+                if (anlpa & LPA_100FULL)
+                {
+                    priv->duplex = EMAC_PHY_DUPLEX_FULL;
+                }
+            }
+            else
+            {
+                if (anlpa & LPA_10FULL)
+                {
+                    priv->duplex = EMAC_PHY_DUPLEX_FULL;
+                }
+            }
+        }
+    }
+
+    if (priv->auto_negotiation != EMAC_PHY_AUTO_NEG_COMPLETE)
+    {
+        /* Auto-negotiation is not enabled or failed for some reason
+         * so we just get phy setup from the status and control registers
+         */
+        phy_control = emac_mii_read(CONFIG_PHY_ADDR, MII_BMCR);
+        phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
+        if (phy_status & BMSR_LSTATUS)
+        {
+            priv->link = EMAC_PHY_LINK_UP;
+        }
+        else
+        {
+            priv->link = EMAC_PHY_LINK_DOWN;
+        }
+
+        if (phy_control & BMCR_SPEED100)
+        {
+            priv->speed = EMAC_PHY_SPEED_100;
+        }
+        else
+        {
+            priv->speed = EMAC_PHY_SPEED_10;
+        }
+
+        if (phy_control & BMCR_FULLDPLX)
+        {
+            priv->duplex = EMAC_PHY_DUPLEX_FULL;
+        }
+        else
+        {
+            priv->duplex = EMAC_PHY_DUPLEX_HALF;
+        }
+    }
+}
+
+static int emac_set_mac_addr(struct eth_device *dev)
+{
+    unsigned int mac_addr_bottom = 0;
+    unsigned int mac_addr_top = 0;
+
+    mac_addr_bottom = dev->enetaddr[0] |
+                      dev->enetaddr[1] << 8 |
+                      dev->enetaddr[2] << 16 |
+                      dev->enetaddr[3] << 24;
+
+    mac_addr_top = dev->enetaddr[4] |
+                   dev->enetaddr[5] << 8;
+
+    EMAC_WRITE(mac_addr_bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+    EMAC_WRITE(mac_addr_top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+
+    return 0;
+}
+
+static void emac_startup(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int network_config_register = 0;
+    unsigned int network_control_register = 0;
+    unsigned int dma_config_register = 0;
+
+    /* Make sure the Tx & Rx are halted */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register &= ~(EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Get the MAC address from environment variables
+     *
+     * Note: We do this again here just incase the MAC
+     * address has been changed since U-Boot has started up
+     */
+    eth_getenv_enetaddr("ethaddr", dev->enetaddr);
+
+    /* Set the hardware MAC address
+     *
+     * Note: We do this again here just incase the MAC
+     * address has been changed since U-Boot has started up
+     */
+    (void)emac_set_mac_addr(dev);
+
+    /* Setup the Rx Buffer Queue Base Address */
+    EMAC_WRITE((unsigned int)&rx_descriptor,
+                EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+    /* Setup the Tx Buffer Queue Base Address */
+    EMAC_WRITE((unsigned int)&tx_descriptor,
+                EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+    /* Setup the size of the DMA Receive Buffer */
+    dma_config_register = EMAC_READ(EMAC_DMA_CFG_REG_OFFSET);
+    dma_config_register &= ~(EMAC_DMA_RX_BUFFER_SIZE_MASK);
+    dma_config_register |= EMAC_DMA_RX_BUFFER_SIZE;
+    EMAC_WRITE(dma_config_register, EMAC_DMA_CFG_REG_OFFSET);
+
+    /* Setup the Network Configuration Register */
+    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
+    network_config_register |= EMAC_64_BIT_AMBA_DATA_BUS_WITDH;
+    network_config_register |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
+    network_config_register |= EMAC_FCS_REMOVE;
+
+    if (priv->duplex == EMAC_PHY_DUPLEX_FULL)
+    {
+        network_config_register |= EMAC_FULL_DUPLEX;
+    }
+    else
+    {
+        network_config_register &= ~(EMAC_FULL_DUPLEX);
+    }
+
+    if (priv->speed == EMAC_PHY_SPEED_100)
+    {
+        network_config_register |= EMAC_SPEED_100_MBPS;
+    }
+    else
+    {
+        network_config_register &= ~(EMAC_SPEED_100_MBPS);
+    }
+
+    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+    /* Setup the Network Control Register */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= (EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+}
+
+static int emac_open(struct eth_device *dev, bd_t *bis)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int i = 0;;
+    unsigned int buffer_address = 0;
+    unsigned int ret = 0;
+
+    /* Initialise the Rx descriptor count */
+    priv->rx_desc = 0;
+
+    /* Initialise the Tx descriptor count */
+    priv->tx_desc = 0;
+
+    /* Initialise the Rx descriptors */
+    for (i = 0; i < EMAC_RX_NUM_DESCRIPTOR; i++)
+    {
+        buffer_address = (unsigned int)&rx_buffer[i][0];
+        if (i == (EMAC_RX_NUM_DESCRIPTOR - 1))
+        {
+            /* we are on the last descriptor entry */
+            buffer_address |= EMAC_RX_DESC_WRAP;
+        }
+        rx_descriptor[i].buffer = buffer_address;
+        rx_descriptor[i].status = 0;
+    }
+
+    /* Initialise the Tx descriptors */
+    for (i = 0; i < EMAC_TX_NUM_DESCRIPTOR; i++)
+    {
+        tx_descriptor[i].buffer = 0;
+        tx_descriptor[i].status = EMAC_TX_DESC_HOST_OWN;
+
+        if (i == (EMAC_TX_NUM_DESCRIPTOR - 1))
+        {
+            /* we are on the last descriptor entry */
+            tx_descriptor[i].status |= EMAC_TX_DESC_WRAP;
+        }
+    }
+
+    /* Check out the phy status */
+    ret = emac_init_phy(dev);
+    if (ret != 0)
+    {
+        /* Oops, we've had an error */
+        return(ret);
+    }
+
+    /* Initialise the emac registers */
+    emac_startup(dev);
+
+    return (0);
+}
+
+static int emac_rx_packet(struct eth_device *dev)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int start_of_frame = 0;
+    unsigned int end_of_frame = 0;
+    unsigned int frame_error = 0;
+    unsigned int length = 0;
+    void * buffer_start;
+
+    if (rx_descriptor[priv->rx_desc].buffer & EMAC_RX_DESC_HOST_OWN)
+    {
+        /* We have some received data */
+
+        /* Make sure we have a whole frame */
+        start_of_frame = rx_descriptor[priv->rx_desc].status &
+                         EMAC_RX_DESC_START_OF_FRAME;
+        end_of_frame = rx_descriptor[priv->rx_desc].status &
+                       EMAC_RX_DESC_END_OF_FRAME;
+        if (start_of_frame && end_of_frame)
+        {
+            /* We have a complete frame */
+            length = rx_descriptor[priv->rx_desc].status &
+                     EMAC_RX_DESC_LENGTH_MASK;
+
+            /* Noodle the buffer start address for the higher level
+             * network stack. The start address should be 8 byte aligned,
+             * also bits 0 & 1 can be set by the emac, so these need to
+             * be masked out as well
+             */
+
+            buffer_start = (void *)
+                           (rx_descriptor[priv->rx_desc].buffer & 0xFFFFFFF8);
+
+            /* Send received packet to the higher network layers */
+            NetReceive(buffer_start, length);
+        }
+        else
+        {
+            /* Oops, not a complete frame */
+            frame_error++;
+        }
+
+        /* Reclaim the buffer just used */
+        rx_descriptor[priv->rx_desc].buffer &= ~(EMAC_RX_DESC_HOST_OWN);
+
+        /* Increment the Rx descriptor counter */
+        priv->rx_desc++;
+        if (priv->rx_desc == EMAC_RX_NUM_DESCRIPTOR)
+        {
+            /* We have exhausted the supply of Rx descriptors */
+            priv->rx_desc = 0;
+        }
+    }
+
+    if (frame_error)
+    {
+        printf ("frame error\n");
+        return (1);
+    }
+
+    return(0);
+}
+
+static int emac_tx_packet(struct eth_device *dev,
+                          volatile void *packet,
+                          int length)
+{
+    struct emac_priv *priv = dev->priv;
+    unsigned int i = 0;
+    unsigned int network_control_register = 0;
+
+    /* Set up the Tx descriptor */
+
+    /* Make sure the wrap bit is set for the last descriptor */
+    if (priv->tx_desc == (EMAC_TX_NUM_DESCRIPTOR - 1))
+    {
+        /* we are on the last descriptor entry */
+        tx_descriptor[priv->tx_desc].status = EMAC_TX_DESC_WRAP;
+    }
+
+    tx_descriptor[priv->tx_desc].status |= length & EMAC_TX_BUFFER_LENGTH_MASK;
+    tx_descriptor[priv->tx_desc].status |= EMAC_TX_LAST_BUFFER;
+    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_NO_CRC_APPEND);
+    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_DESC_HOST_OWN);
+
+    /* Setup the Tx descriptor buffer */
+    tx_descriptor[priv->tx_desc].buffer = (unsigned int)packet;
+
+    /* Start the packet transmission */
+    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
+    network_control_register |= EMAC_START_TX;
+    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Wait for transmission to complete */
+    for (i = 0; i <= EMAC_TX_TIMEOUT; i++)
+    {
+	if (tx_descriptor[priv->tx_desc].status & EMAC_TX_DESC_HOST_OWN)
+        {
+            /* The emac has completed transmission */
+            break;
+        }
+	udelay(1);
+    }
+
+    /* Increment the Tx descriptor counter */
+    priv->tx_desc++;
+    if (priv->tx_desc == EMAC_TX_NUM_DESCRIPTOR)
+    {
+        /* We have exhausted the supply of Tx descriptors */
+        priv->tx_desc = 0;
+    }
+
+    /* We could add some error reporting in here, but no one cares anyway */
+    return(0);
+}
+
+static void emac_halt(struct eth_device *dev)
+{
+    unsigned int status_register = 0;
+
+    /* Halt the Tx & Rx */
+    EMAC_WRITE(0, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear the statistics counters */
+    EMAC_WRITE(EMAC_CLEAR_STATS_REGISTERS, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+    /* Clear the Tx status registers */
+    status_register = EMAC_READ(EMAC_TX_STATUS_REG_OFFSET);
+    EMAC_WRITE(status_register, EMAC_TX_STATUS_REG_OFFSET);
+
+    /* Clear the Rx status registers */
+    status_register = EMAC_READ(EMAC_RX_STATUS_REG_OFFSET);
+    EMAC_WRITE(status_register, EMAC_RX_STATUS_REG_OFFSET);
+}
+
+int pc302_eth_register(bd_t *bis)
+{
+    struct eth_device *dev = NULL;
+    struct emac_priv *priv = NULL;
+
+    /* Create some storage for useful structures */
+    dev = (struct eth_device *) malloc(sizeof (*dev));
+    if (dev == NULL)
+    {
+        /* Oops, no memory available */
+        return -ENOMEM;
+    }
+
+    priv = (struct emac_priv *) malloc(sizeof (*priv));
+    if (priv == NULL)
+    {
+        /* Oops, no memory available */
+        free (dev);
+        return -ENOMEM;
+    }
+
+    dev->priv = priv;
+
+    /* Reset the private data */
+    memset(priv, 0, sizeof(struct emac_priv));
+
+    /* Define our name */
+    sprintf(dev->name, "pc302_emac");
+
+    dev->init = emac_open;
+    dev->recv = emac_rx_packet;
+    dev->send = emac_tx_packet;
+    dev->halt = emac_halt;
+    dev->write_hwaddr = emac_set_mac_addr;
+
+    /* Register our emac driver with the networking environment */
+    (void)eth_register(dev);
+
+    /* Get the MAC address from environment variables */
+    eth_getenv_enetaddr("ethaddr", dev->enetaddr);
+
+    /* Set the hardware MAC address */
+    (void)emac_set_mac_addr(dev);
+
+#if defined (CONFIG_CMD_MII)
+    miiphy_register(dev->name, pc302emac_miiphy_read, pc302emac_miiphy_write);
+#endif
+
+    return 0;
+}
+
+#endif /* CONFIG_DW_EMAC */
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/gpio.c b/arch/arm/cpu/arm926ejs/pc3xx/gpio.c
new file mode 100644
index 0000000..72e4305
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/gpio.c
@@ -0,0 +1,1075 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009-2011 Picochip Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pc3xxgpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+#define __iomem
+#define _ioa (void __iomem *)
+#define readl(addr) (pc302_read_from_register((unsigned int)addr))
+#define writel(val, addr) (pc302_write_to_register((unsigned int)addr, val))
+
+/* The number of gpio pins that this drover can handle */
+#define ARCH_NR_GPIOS 128
+
+#define BITS_PER_BYTE 8
+#define BITS_TO_LONGS(nr) \
+        DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
+#define DECLARE_BITMAP(name,bits) \
+        unsigned long name[BITS_TO_LONGS(bits)]
+
+/* Constants --------------------------------------------------------------- */
+/**
+ * struct gpio_chip - abstract a GPIO controller
+ * @label: for diagnostics
+ * @request: optional hook for chip-specific activation, such as
+ *	enabling module power and clock; may sleep
+ * @free: optional hook for chip-specific deactivation, such as
+ *	disabling module power and clock; may sleep
+ * @direction_input: configures signal "offset" as input, or returns error
+ * @get: returns value for signal "offset"; for output signals this
+ *	returns either the value actually sensed, or zero
+ * @direction_output: configures signal "offset" as output, or returns error
+ * @set: assigns output value for signal "offset"
+ * @base: identifies the first GPIO number handled by this chip; or, if
+ *	negative during registration, requests dynamic ID allocation.
+ * @ngpio: the number of GPIOs handled by this controller; the last GPIO
+ *	handled is (base + ngpio - 1).
+ * @names: if set, must be an array of strings to use as alternative
+ *      names for the GPIOs in this chip. Any entry in the array
+ *      may be NULL if there is no alias for the GPIO, however the
+ *      array must be @ngpio entries long.
+ *
+ * A gpio_chip can help platforms abstract various sources of GPIOs so
+ * they can all be accessed through a common programing interface.
+ * Example sources would be SOC controllers, FPGAs, multifunction
+ * chips, dedicated GPIO expanders, and so on.
+ *
+ * Each chip controls a number of signals, identified in method calls
+ * by "offset" values in the range 0..(@ngpio - 1).  When those signals
+ * are referenced through calls like gpio_get_value(gpio), the offset
+ * is calculated by subtracting @base from the gpio number.
+ */
+struct gpio_chip {
+	const char		*label;
+
+	int			(*request)(struct gpio_chip *chip,
+						unsigned offset);
+	void			(*free)(struct gpio_chip *chip,
+						unsigned offset);
+
+	int			(*direction_input)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*get)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*direction_output)(struct gpio_chip *chip,
+						unsigned offset, int value);
+	void			(*set)(struct gpio_chip *chip,
+						unsigned offset, int value);
+
+	int			base;
+	u16			ngpio;
+	char			**names;
+};
+
+DECLARE_BITMAP(pin_status, ARCH_NR_GPIOS);
+
+struct gpio_desc {
+	struct gpio_chip	*chip;
+};
+
+static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
+
+/* Functions --------------------------------------------------------------- */
+static int
+armgpio_request(struct gpio_chip *chip,
+		unsigned offset)
+{
+	enum mux_setting mux;
+
+	if (test_and_set_bit(offset + chip->base, pin_status))
+		return -EBUSY;
+
+	/* Check the pin has been correctly multiplexed. */
+	mux = pc3xx_get_pin_mux(offset + chip->base);
+	if (!(mux & (MUX_ARM | MUX_UNMUXED))) {
+		/* The pin has an inconsistent mux setting. */
+		printf("attempt to request armgpio%u which is not correctly multiplexed\n",
+			   chip->base + offset);
+		test_and_clear_bit(offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void
+armgpio_free(struct gpio_chip *chip,
+	     unsigned offset)
+{
+	test_and_clear_bit(offset + chip->base, pin_status);
+}
+
+#define GPIO_SW_PORT_A_EXT_REG_OFFSET	GPIO_EXT_PORT_A_REG_OFFSET
+#define GPIO_SW_PORT_B_EXT_REG_OFFSET	GPIO_EXT_PORT_B_REG_OFFSET
+#define GPIO_SW_PORT_D_EXT_REG_OFFSET	GPIO_EXT_PORT_D_REG_OFFSET
+
+static inline int
+armgpio_block_nr(unsigned gpio_nr)
+{
+	if (!is_pc3x3()) {
+		/*
+		 * PC3X2 has GPIOs numbered in non contiguous blocks.
+		 */
+		if (gpio_nr < PC302_GPIO_PIN_ARM_8)
+			return gpio_nr - PC302_GPIO_PIN_ARM_0;
+		else
+			return gpio_nr - PC302_GPIO_PIN_ARM_8 + 8;
+	} else {
+		/*
+		 * For PC3X3, ARM GPIO's are numbered from 0->MAX.
+		 */
+		return gpio_nr;
+	}
+
+	return -ENXIO;
+}
+
+#define __ARMGPIO_REG(_gpio_base, _reg)					    \
+	({								    \
+		void __iomem *ret = NULL;				    \
+		int __gpio_nr = armgpio_block_nr(_gpio_base);		    \
+		if (__gpio_nr < 8)					    \
+			ret = _ioa(PC302_GPIO_BASE +			    \
+				GPIO_SW_PORT_A_##_reg##_REG_OFFSET);	    \
+		else if (__gpio_nr < 24)				    \
+			ret = _ioa(PC302_GPIO_BASE +			    \
+				GPIO_SW_PORT_B_##_reg##_REG_OFFSET);	    \
+		else							    \
+			ret = _ioa(PC302_GPIO_BASE +			    \
+				GPIO_SW_PORT_D_##_reg##_REG_OFFSET);	    \
+		ret;							    \
+	})
+
+#define ARMGPIO_DR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DR)
+#define ARMGPIO_DDR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DDR)
+#define ARMGPIO_CTL(_gpio_base)	    __ARMGPIO_REG(_gpio_base, CTL)
+#define ARMGPIO_EXT(_gpio_base)	    __ARMGPIO_REG(_gpio_base, EXT)
+
+static inline unsigned
+armgpio_offset(unsigned offset)
+{
+	if (is_pc3x3()) {
+		/*
+		 * The arm gpios in PC3x3 are controlled via three sets of
+		 * registers. The register addressing is already taken care
+		 * of by the __ARMGPIO_REG macro, this takes care of the bit
+		 * offsets within each register.
+		 */
+		if (offset < 8) /* GPIO Port A*/
+			return offset;
+		else if (offset < 24) /* GPIO Port B */
+			return offset - 8;
+		else /* GPIO Port D */
+			return offset - 24;
+	}
+
+	return offset;
+}
+
+static int
+armgpio_direction_input(struct gpio_chip *chip,
+			unsigned offset)
+{
+	void __iomem *ddr = ARMGPIO_DDR(chip->base + offset);
+	void __iomem *cr = ARMGPIO_CTL(chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset(offset);
+
+	/* Mark the pin as an output. */
+	val = readl(ddr);
+	val &= ~(1 << bit_offset);
+        writel(val, ddr);
+
+	/* Set the pin as software controlled. */
+	val = readl(cr);
+	val &= ~(1 << bit_offset);
+        writel(val, cr);
+
+	return 0;
+}
+
+static void
+armgpio_set(struct gpio_chip *chip,
+	    unsigned offset,
+	    int value);
+
+static int
+armgpio_direction_output(struct gpio_chip *chip,
+			 unsigned offset,
+			 int value)
+{
+	void __iomem *ddr = ARMGPIO_DDR(chip->base + offset);
+	void __iomem *cr = ARMGPIO_CTL(chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset(offset);
+
+	/* Set the value first so we don't glitch. */
+	armgpio_set(chip, offset, value);
+
+	/* Mark the pin as an output. */
+	val = readl(ddr);
+	val |= (1 << bit_offset);
+        writel(val, ddr);
+
+	/* Set the pin as software controlled. */
+	val = readl(cr);
+	val &= ~(1 << bit_offset);
+	writel(val, cr);
+
+	return 0;
+}
+
+static int
+armgpio_get(struct gpio_chip *chip,
+	    unsigned offset)
+{
+	void __iomem *ext = ARMGPIO_EXT(chip->base + offset);
+	unsigned long bit_offset = armgpio_offset(offset);
+
+	return !!(readl(ext) & (1 << bit_offset));
+}
+
+static void
+armgpio_set(struct gpio_chip *chip,
+	    unsigned offset,
+	    int value)
+{
+	void __iomem *dr = ARMGPIO_DR(chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset(offset);
+
+	val = readl(dr);
+	val &= ~(1 << bit_offset);
+	val |= (!!value << bit_offset);
+	writel(val, dr);
+}
+
+/*
+ * PC3X2 ARM GPIO chips. One chip per port.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X2
+char *pc3x2_armgpio_lo_pins[] = {
+	"arm0",
+	"arm1",
+	"arm2",
+	"arm3",
+	"arm4",
+	"arm5",
+	"arm6",
+	"arm7",
+};
+
+static struct gpio_chip pc3x2_arm_gpio_lo = {
+	.label		    = "armgpio_lo",
+	.request	    = armgpio_request,
+	.free		    = armgpio_free,
+	.direction_input    = armgpio_direction_input,
+	.direction_output   = armgpio_direction_output,
+	.get		    = armgpio_get,
+	.set		    = armgpio_set,
+	.base		    = PC302_GPIO_PIN_ARM_0,
+	.ngpio		    = ARRAY_SIZE(pc3x2_armgpio_lo_pins),
+	.names		    = pc3x2_armgpio_lo_pins,
+};
+
+char *pc3x2_armgpio_shared_pins[] = {
+	"arm8",
+	"arm9",
+	"arm10",
+	"arm11",
+	"arm12",
+	"arm13",
+	"arm14",
+	"arm15",
+};
+
+static struct gpio_chip pc3x2_arm_gpio_shared = {
+	.label		    = "armgpio_shared",
+	.request	    = armgpio_request,
+	.free		    = armgpio_free,
+	.direction_input    = armgpio_direction_input,
+	.direction_output   = armgpio_direction_output,
+	.get		    = armgpio_get,
+	.set		    = armgpio_set,
+	.ngpio		    = ARRAY_SIZE(pc3x2_armgpio_shared_pins),
+	.base		    = PC302_GPIO_PIN_ARM_8,
+	.names		    = pc3x2_armgpio_shared_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+#ifdef CONFIG_PICOCHIP_PC3X3
+/*
+ * PC3X3 ARM GPIO chip.
+ */
+char *pc3x3_armgpio_pins[] = {
+	"arm0",
+	"arm1",
+	"arm2",
+	"arm3",
+	"arm4",
+	"arm5",
+	"arm6",
+	"arm7",
+	"arm8",
+	"arm9",
+	"arm10",
+	"arm11",
+	"arm12",
+	"arm13",
+	"arm14",
+	"arm15",
+	"arm16",
+	"arm17",
+	"arm18",
+	"arm19",
+	"arm20",
+	"arm21",
+	"arm22",
+	"arm23",
+	"arm24",
+	"arm25",
+	"arm26",
+	"arm27",
+	"arm28",
+	"arm29",
+	"arm30",
+	"arm31",
+	"arm32",
+	"arm33",
+	"arm34",
+	"arm35",
+	"arm36",
+	"arm37",
+	"arm38",
+	"arm39",
+	"arm40",
+	"arm41",
+	"arm42",
+	"arm43",
+	"arm44",
+	"arm45",
+	"arm46",
+	"arm47",
+	"arm48",
+	"arm49",
+	"arm50",
+	"arm51",
+        "arm52",
+        "arm53",
+};
+
+static struct gpio_chip pc3x3_arm_gpio = {
+	.label		    = "armgpio",
+	.request	    = armgpio_request,
+	.free		    = armgpio_free,
+	.direction_input    = armgpio_direction_input,
+	.direction_output   = armgpio_direction_output,
+	.get		    = armgpio_get,
+	.set		    = armgpio_set,
+	.base		    = PC3X3_GPIO_PIN_ARM_0,
+	.ngpio		    = ARRAY_SIZE(pc3x3_armgpio_pins),
+	.names		    = pc3x3_armgpio_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+/* The base address of SD-GPIO config registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_CONFIG_BASE		0x9800
+/* The base address of SD-GPIO analogue value registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE	0x9801
+/* The base address of SD-GPIO analogue rate registers in the AXI2Pico. */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE	0x9802
+/* The address of the control value register in the AXI2Pico. */
+#define PC302_GPIO_SD_CONTROL_VAL_REG		0x9882
+/* The address of the control value high register in the AXI2Pico (pc3x3). */
+#define PC302_GPIO_SD_CONTROL_VAL_HI_REG	0x9883
+/* The address of the output value register in the AXI2Pico. */
+#define PC302_GPIO_SD_OUTPUT_VAL_REG		0x9884
+/* The address of the output value high register in the AXI2Pico (pc3x3). */
+#define PC302_GPIO_SD_OUTPUT_HI_VAL_REG		0x9885
+/* The address of the input value register in the AXI2Pico. */
+#define PC302_GPIO_SD_INPUT_VAL_REG		0x9880
+/* The address of the input value high register in the AXI2Pico (pc3x3). */
+#define PC302_GPIO_SD_INPUT_VAL_HI_REG		0x9880
+/* The address of the sleep register in the AXI2Pico. */
+#define PC302_AXI2PICO_SLEEP_REG		0xA060
+/* The spacing between SD-GPIO config registers. */
+#define PC302_GPIO_SD_PIN_CONFIG_SPACING	4
+/* Control source bit. */
+#define PC302_GPIO_SD_CONFIG_CS_MASK		~(1 << 15)
+/* Analogue not digital bit. */
+#define PC302_GPIO_SD_CONFIG_AND		(1 << 14)
+/* The mask for analogue converter size in the config register. */
+#define PC302_GPIO_SD_CONV_SZ_MASK		0xF
+/* Soft reset lock bit. */
+#define PC302_GPIO_SD_CONFIG_SR_LOCK		(1 << 13)
+/* PC302 AXI2Pico CAEID. */
+#define PC302_AXI2PICO_CAEID			(0x9000)
+
+/*
+ * Get the address of a config register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_CONFIG(_n) \
+    PC302_GPIO_SD_PIN_CONFIG_BASE + ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
+
+/*
+ * Get the address of a analogue rate register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_RATE(_n) \
+    PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
+        ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
+
+/*
+ * Get the address of a analogue value register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PC302_GPIO_SD_PIN_ANALOGUE_VAL(_n) \
+    PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
+        ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
+
+static int
+sdgpio_reset_config(unsigned block_pin,
+		    int value)
+{
+	int ret;
+	u16 data;
+
+	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+				  PC302_GPIO_SD_PIN_CONFIG(block_pin),
+				  &data, 1);
+	if (1 != ret) {
+		printf("failed to read config register for SDGPIO pin %u\n",
+		       block_pin );
+		return -EIO;
+	}
+
+	if (value)
+		data |= PC302_GPIO_SD_CONFIG_SR_LOCK;
+	else
+		data &= ~PC302_GPIO_SD_CONFIG_SR_LOCK;
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+				   PC302_GPIO_SD_PIN_CONFIG(block_pin),
+				   &data, 1);
+	if (1 != ret) {
+		printf("failed to write config register for SDGPIO pin %u\n",
+		       block_pin );
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int
+sdgpio_block_nr(unsigned gpio_nr)
+{
+	if (is_pc3x3()) {
+		return gpio_nr - PC3X3_GPIO_PIN_SDGPIO_0;
+	} else {
+		if (gpio_nr >= PC302_GPIO_PIN_SDGPIO_0 &&
+		    gpio_nr < PC302_GPIO_PIN_SDGPIO_7)
+			return gpio_nr - PC302_GPIO_PIN_SDGPIO_0;
+		else
+			return (gpio_nr - PC302_GPIO_PIN_SDGPIO_8) + 8;
+	}
+}
+
+static int
+sdgpio_request(struct gpio_chip *chip,
+	       unsigned offset)
+{
+	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
+	enum mux_setting mux;
+
+	if (test_and_set_bit(offset + chip->base, pin_status))
+		return -EBUSY;
+
+	if (sdgpio_reset_config(block_pin, 1)) {
+		test_and_clear_bit(offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	/* Check the pin has been correctly multiplexed. */
+	mux = pc3xx_get_pin_mux(offset + chip->base);
+	if (!(mux & (MUX_SD | MUX_UNMUXED))) {
+		/* The pin has an inconsistent mux setting. */
+		printf("attempt to request sdgpio%u which is not correctly multiplexed\n",
+			   block_pin);
+		test_and_clear_bit(offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void
+sdgpio_free(struct gpio_chip *chip,
+	    unsigned offset)
+{
+	test_and_clear_bit(offset + chip->base, pin_status);
+	pc3xx_gpio_configure_dac(chip->base + offset, 0, 0);
+}
+
+/*
+ * Create a map of which pins are analogue and not digital. We have a separate
+ * function for configuring pins as analogue. When we set analogue pins, we
+ * don't treat the int parameter as a boolean anymore.
+ */
+DECLARE_BITMAP(a_not_d_map, ARCH_NR_GPIOS);
+
+static int
+sdgpio_get_digital_out_status(u32 *v)
+{
+	u16 data[2] = { 0, 0 };
+
+	if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+				PC302_GPIO_SD_OUTPUT_VAL_REG, &data[0], 1))
+		return -EIO;
+
+	if (is_pc3x3()) {
+		if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+					PC302_GPIO_SD_OUTPUT_HI_VAL_REG,
+					&data[1], 1))
+			return -EIO;
+	}
+
+	*v = data[0] | (data[1] << 16);
+
+	return 0;
+}
+
+static int
+sdgpio_set_digital_out_status(u32 v)
+{
+	u16 data[2] = { (u16)(v & 0xFFFF), (u16)((v >> 16) & 0xFFFF) };
+
+	if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+				PC302_GPIO_SD_OUTPUT_VAL_REG, &data[0], 1))
+		return -EIO;
+
+	if (is_pc3x3()) {
+		if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+					PC302_GPIO_SD_OUTPUT_HI_VAL_REG,
+					&data[1], 1))
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static void
+sdgpio_set(struct gpio_chip *chip,
+	   unsigned offset,
+	   int value)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
+
+	if (!test_bit(chip->base + offset, a_not_d_map)) {
+		u32 status;
+
+		if (sdgpio_get_digital_out_status(&status)) {
+			printf("failed to read SDGPIO output value reg\n");
+			return;
+		}
+
+		status &= ~(1 << block_pin);
+		status |= (!!value) << block_pin;
+
+		if (sdgpio_set_digital_out_status(status)) {
+			printf("failed to output control register for SDGPIO pin %u\n",
+			       block_pin);
+			return;
+		}
+	} else {
+		/* Analogue mode */
+		data = (u16)value;
+		ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+				PC302_GPIO_SD_PIN_ANALOGUE_VAL(block_pin),
+				&data, 1);
+		if (1 != ret) {
+			printf("failed to write analogue value register for SDGPIO pin %u\n",
+			       block_pin);
+			return;
+		}
+	}
+}
+
+static int
+sdgpio_get_digital_in_status(u32 *v)
+{
+	u16 data[2] = { 0, 0 };
+
+	if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+				PC302_GPIO_SD_INPUT_VAL_REG, &data[0], 1))
+		return -EIO;
+
+	if (is_pc3x3()) {
+		if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+					PC302_GPIO_SD_INPUT_VAL_HI_REG,
+					&data[1], 1))
+			return -EIO;
+	}
+
+	*v = data[0] | (data[1] << 16);
+
+	return 0;
+}
+
+static int
+sdgpio_get(struct gpio_chip *chip,
+	   unsigned offset)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
+
+	if (!test_bit(chip->base + offset, a_not_d_map)) {
+		u32 status;
+
+		if (sdgpio_get_digital_in_status(&status))
+			return -EIO;
+
+		return !!(status & (1 << block_pin));
+	} else {
+		/* Analogue mode */
+		ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+				PC302_GPIO_SD_PIN_ANALOGUE_VAL(block_pin),
+				&data, 1);
+		if (1 != ret) {
+			printf("failed to read the analogue value register for SDGPIO pin %u\n",
+			       block_pin);
+			return -EIO;
+		}
+
+		return (int)data;
+	}
+}
+
+static int
+sdgpio_set_direction(unsigned block_pin,
+		     int input)
+{
+	int ret;
+	u16 data;
+
+	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
+	if (1 != ret) {
+		printf("failed to read config register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
+	if (1 != ret) {
+		printf("failed to write config register for SDGPIO pin %u\n",
+		       block_pin );
+		return -EIO;
+	}
+
+	/* Configure the pin to drive or not drive the output as appropriate. */
+	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf("failed to read SDGPIO control value register\n");
+		return -EIO;
+	}
+
+	if (input)
+		data &= ~(1 << block_pin);
+	else
+		data |= (1 << block_pin);
+
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf("failed to write control value register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int
+sdgpio_direction_output(struct gpio_chip *chip,
+			unsigned offset,
+			int value)
+{
+	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
+	int ret = sdgpio_set_direction(block_pin, 0);
+
+	if (ret)
+		return ret;
+
+	sdgpio_set(chip, offset, value);
+
+	return 0;
+}
+
+static int
+sdgpio_direction_input(struct gpio_chip *chip,
+		       unsigned offset)
+{
+	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
+
+	return sdgpio_set_direction(block_pin, 1);
+}
+
+int
+pc3xx_gpio_configure_dac(unsigned gpio,
+                         u8 converter_size,
+                         u16 analogue_rate)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr(gpio);
+
+	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
+	if (1 != ret) {
+		printf("failed to read config register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	data &= PC302_GPIO_SD_CONFIG_CS_MASK;
+	data &= ~PC302_GPIO_SD_CONV_SZ_MASK;
+	if (!analogue_rate && !converter_size)
+		data &= ~PC302_GPIO_SD_CONFIG_AND;
+	else
+		data |= PC302_GPIO_SD_CONFIG_AND;
+	data |= (converter_size & PC302_GPIO_SD_CONV_SZ_MASK);
+
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
+	if (1 != ret) {
+		printf("failed to write config register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	/* Configure the pin to drive the output. */
+	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf("failed to read SDGPIO control value register\n");
+		return -EIO;
+	}
+
+	data |= (1 << block_pin);
+
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf("failed to write control value register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	/* Write the analogue rate register */
+	data = analogue_rate;
+	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+			PC302_GPIO_SD_PIN_ANALOGUE_RATE(block_pin), &data, 1);
+	if (1 != ret) {
+		printf("failed to write analogue rate register for SDGPIO pin %u\n",
+		       block_pin);
+		return -EIO;
+	}
+
+	if (analogue_rate || converter_size)
+		test_and_set_bit(gpio, a_not_d_map);
+	else
+		test_and_clear_bit(gpio, a_not_d_map);
+
+	return 0;
+}
+
+/*
+ * PC3X2 SD-GPIO.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X2
+char *sdgpio_lo_pins[] = {
+	"sdgpio0",
+	"sdgpio1",
+	"sdgpio2",
+	"sdgpio3",
+	"sdgpio4",
+	"sdgpio5",
+	"sdgpio6",
+	"sdgpio7",
+};
+
+static struct gpio_chip pc3x2_sd_gpio_lo = {
+	.label		    = "sdpio_lo",
+	.request	    = sdgpio_request,
+	.free		    = sdgpio_free,
+	.direction_input    = sdgpio_direction_input,
+	.direction_output   = sdgpio_direction_output,
+	.get		    = sdgpio_get,
+	.set		    = sdgpio_set,
+	.ngpio		    = ARRAY_SIZE(sdgpio_lo_pins),
+	.base		    = PC302_GPIO_PIN_SDGPIO_0,
+	.names		    = sdgpio_lo_pins,
+};
+
+char *sdgpio_shared_pins[] = {
+	"sdgpio8",
+	"sdgpio9",
+	"sdgpio10",
+	"sdgpio11",
+	"sdgpio12",
+	"sdgpio13",
+	"sdgpio14",
+	"sdgpio15",
+};
+
+static struct gpio_chip pc3x2_sd_gpio_shared = {
+	.label		    = "sdgpio_shared",
+	.request	    = sdgpio_request,
+	.free		    = sdgpio_free,
+	.direction_input    = sdgpio_direction_input,
+	.direction_output   = sdgpio_direction_output,
+	.get		    = sdgpio_get,
+	.set		    = sdgpio_set,
+	.ngpio		    = ARRAY_SIZE(sdgpio_shared_pins),
+	.base		    = PC302_GPIO_PIN_SDGPIO_8,
+	.names		    = sdgpio_shared_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+/*
+ * PC3X3 SD-GPIO.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X3
+char *pc3x3_sdgpio_pins[] = {
+	"sdgpio0",
+	"sdgpio1",
+	"sdgpio2",
+	"sdgpio3",
+	"sdgpio4",
+	"sdgpio5",
+	"sdgpio6",
+	"sdgpio7",
+	"sdgpio8",
+	"sdgpio9",
+	"sdgpio10",
+	"sdgpio11",
+	"sdgpio12",
+	"sdgpio13",
+	"sdgpio14",
+	"sdgpio15",
+	"sdgpio16",
+	"sdgpio17",
+	"sdgpio18",
+	"sdgpio19",
+	"sdgpio20",
+	"sdgpio21",
+	"sdgpio22",
+	"sdgpio23",
+};
+
+static struct gpio_chip pc3x3_sd_gpio = {
+	.label		    = "sdgpio",
+	.request	    = sdgpio_request,
+	.free		    = sdgpio_free,
+	.direction_input    = sdgpio_direction_input,
+	.direction_output   = sdgpio_direction_output,
+	.get		    = sdgpio_get,
+	.set		    = sdgpio_set,
+	.ngpio		    = ARRAY_SIZE(pc3x3_sdgpio_pins),
+	.base		    = PC3X3_GPIO_PIN_SDGPIO_0,
+	.names		    = pc3x3_sdgpio_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+static struct gpio_chip *pc3x2_chips[] = {
+#ifdef CONFIG_PICOCHIP_PC3X2
+	&pc3x2_arm_gpio_lo,
+	&pc3x2_arm_gpio_shared,
+	&pc3x2_sd_gpio_lo,
+	&pc3x2_sd_gpio_shared,
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+};
+
+static struct gpio_chip *pc3x3_chips[] = {
+#ifdef CONFIG_PICOCHIP_PC3X3
+	&pc3x3_arm_gpio,
+	&pc3x3_sd_gpio,
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+};
+
+/* Public API -------------------------------------------------------------- */
+
+int
+pc3xx_gpio_init(void)
+{
+	int num_chips, i, ret = 0, id;
+	u16 data = 0;
+	struct gpio_chip **all_chips, *chip;
+
+	/*
+	 * Make sure that the AXI2Pico is awake for the SDGPIO transactions.
+	 */
+	if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
+				      PC302_AXI2PICO_SLEEP_REG, &data, 1)) {
+		printf("unable to wake axi2pico\n");
+		return -EIO;
+	}
+
+	if (is_pc3x3()) {
+		num_chips = ARRAY_SIZE(pc3x3_chips);
+		all_chips = pc3x3_chips;
+	} else {
+		num_chips = ARRAY_SIZE(pc3x2_chips);
+		all_chips = pc3x2_chips;
+	}
+
+        /* Populate the gpio_desc[] array */
+	for (chip = all_chips[0], i = 0; i < num_chips; ++i, ++chip) {
+                int base = chip->base;
+                for (id = base; id < base + chip->ngpio; id++) {
+			gpio_desc[id].chip = chip;
+		}
+	}
+
+	return ret;
+}
+
+int
+pc3xx_gpio_request(unsigned gpio)
+{
+    	struct gpio_desc	*desc;
+	struct gpio_chip	*chip;
+        int			status = -EINVAL;
+
+        desc = &gpio_desc[gpio];
+	chip = desc->chip;
+
+        if (chip == NULL)
+		goto done;
+
+        if (chip->request) {
+		status = chip->request(chip, gpio - chip->base);
+	}
+done:
+        return status;
+}
+
+void
+pc3xx_gpio_free(unsigned gpio)
+{
+	struct gpio_desc	*desc;
+	struct gpio_chip	*chip;
+
+        desc = &gpio_desc[gpio];
+	chip = desc->chip;
+
+        if (chip->free) {
+		chip->free(chip, gpio - chip->base);
+	}
+}
+
+int
+pc3xx_gpio_direction_input(unsigned gpio)
+{
+    	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+	int			status = -EINVAL;
+        chip = desc->chip;
+	if (!chip || !chip->get || !chip->direction_input)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+
+        status = chip->direction_input(chip, gpio);
+
+fail:
+        return status;
+}
+
+int
+pc3xx_gpio_direction_output(unsigned gpio,
+                            int value)
+
+{
+        struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+	int			status = -EINVAL;
+
+        chip = desc->chip;
+	if (!chip || !chip->set || !chip->direction_output)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+
+        status = chip->direction_output(chip, gpio, value);
+
+fail:
+        return status;
+}
+
+void
+pc3xx_gpio_set_value(unsigned gpio,
+                     int value)
+
+{
+    	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+
+        chip = desc->chip;
+
+        chip->set(chip, gpio - chip->base, value);
+}
+
+int
+pc3xx_gpio_get_value(unsigned gpio)
+{
+    	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+
+        chip = desc->chip;
+
+        return chip->get ? chip->get(chip, gpio - chip->base) : 0;
+}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/mux.c b/arch/arm/cpu/arm926ejs/pc3xx/mux.c
new file mode 100644
index 0000000..3793aa4
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/mux.c
@@ -0,0 +1,1274 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file mux.c
+ * \brief Muxing control for the gpio pins.
+ *
+ * Copyright (c) 2009-2011 Picochip Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pc3xxgpio.h>
+
+/* Constants --------------------------------------------------------------- */
+/*
+ * A multiplexed pin. This defines the SD and ARM pins that are on the pad. If
+ * the pin does not have an SD or ARM pin then set the appropriate field to
+ * -1.
+ */
+struct muxed_pin {
+	const char	*name;
+	int		is_dedicated_gpio;
+	int		sd_pin;
+	int		arm_pin;
+	int		(*set_mux)(struct muxed_pin *pin,
+			           enum mux_setting setting);
+	int		(*get_mux)(struct muxed_pin *pin);
+};
+
+/*
+ * A logical group of multiplexed pins. Typically this is grouped by what the
+ * pins are multiplexed with e.g. system peripheral.
+ */
+struct pin_group {
+	int		    nr_pins;
+	const char	    *name;
+	struct muxed_pin    *pins;
+};
+
+/* Macros ------------------------------------------------------------------ */
+#define __PIN(_name, _sd, _arm, _set, _get)		        \
+	.name		    = __stringify(_name),		\
+	.is_dedicated_gpio  = 0,				\
+	.sd_pin		    = (_sd),				\
+	.arm_pin    	    = (_arm),				\
+	.set_mux    	    = _set,				\
+	.get_mux    	    = _get
+/*
+ * Declare a function pin that is also multiplexed with GPIO pins.
+ */
+#define PIN(_name, _sd, _arm, _set, _get) {			\
+	__PIN(_name, _sd, _arm, _set, _get),			\
+	.is_dedicated_gpio  = 0,				\
+}
+
+/*
+ * Declare a pure GPIO pin.
+ */
+#define GPIO(_name, _sd, _arm, _set, _get) {			\
+	__PIN(_name, _sd, _arm, _set, _get),			\
+	.is_dedicated_gpio  = 1,				\
+}
+
+/* Functions --------------------------------------------------------------- */
+/*****************************************************************************
+ * PC302 pin multiplexing.
+ ****************************************************************************/
+#ifdef CONFIG_PICOCHIP_PC3X2
+
+static int
+pai_get_mux(struct muxed_pin *pin)
+{
+#define PAI_GPIO_PIN_ARM_4	0xB
+#define PAI_GPIO_PIN_ARM_5	0xA
+#define PAI_GPIO_PIN_ARM_6	0x9
+#define PAI_GPIO_PIN_ARM_7	0x8
+#define PAI_GPIO_PIN_SDGPIO_4	0x7
+#define PAI_GPIO_PIN_SDGPIO_5	0x6
+#define PAI_GPIO_PIN_SDGPIO_6	0x5
+#define PAI_GPIO_PIN_SDGPIO_7	0x4
+#define PC302_PAI_CAEID		0x8080
+#define PAI_SLEEP_REG		0xA060
+#define PAI_IO_CTRL_REG		0x0009
+
+	/* Make sure that the PAI block is awake. */
+	u16 data = 0, sd_mask = 0, arm_mask = 0;
+	int ret = axi2cfg_config_write(PC302_PAI_CAEID, PAI_SLEEP_REG,
+				       &data, 1);
+	if (1 != ret) {
+		printf("unable to wake up PAI\n");
+		return -EIO;
+	}
+
+	/* Get the current PAI muxing configuration. */
+	ret = axi2cfg_config_read(PC302_PAI_CAEID, PAI_IO_CTRL_REG,
+				  &data, 1);
+	if (1 != ret) {
+		printf("unable to read PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_4;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_5;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_6;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_7;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
+		arm_mask |= PAI_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
+		arm_mask |= PAI_GPIO_PIN_ARM_5;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
+		arm_mask |= PAI_GPIO_PIN_ARM_6;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
+		arm_mask |= PAI_GPIO_PIN_ARM_7;
+	} else {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (data & sd_mask)
+		ret = MUX_SD;
+	else if (data & arm_mask)
+		ret = MUX_ARM;
+	else
+		ret = MUX_PERIPHERAL;
+
+out:
+	return ret;
+}
+
+static int
+pai_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting)
+{
+	/* Make sure that the PAI block is awake. */
+	u16 data = 0;
+	int err = axi2cfg_config_write(PC302_PAI_CAEID, PAI_SLEEP_REG,
+				       &data, 1);
+	if (1 != err) {
+		printf("unable to wake up PAI\n");
+		return -EIO;
+	}
+
+	/* Get the current PAI muxing configuration. */
+	err = axi2cfg_config_read(PC302_PAI_CAEID, PAI_IO_CTRL_REG,
+				  &data, 1);
+	if (1 != err) {
+		printf("unable to read PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	if (MUX_SD == setting) {
+		if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
+			data |= PAI_GPIO_PIN_SDGPIO_4;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
+			data |= PAI_GPIO_PIN_SDGPIO_5;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
+			data |= PAI_GPIO_PIN_SDGPIO_6;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
+			data |= PAI_GPIO_PIN_SDGPIO_7;
+		} else {
+			err = -EINVAL;
+			goto out;
+		}
+	} else if (MUX_ARM == setting) {
+		if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
+			data |= PAI_GPIO_PIN_ARM_4;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
+			data |= PAI_GPIO_PIN_ARM_5;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
+			data |= PAI_GPIO_PIN_ARM_6;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
+			data |= PAI_GPIO_PIN_ARM_7;
+		} else {
+			err = -EINVAL;
+			goto out;
+		}
+	} else if (MUX_PERIPHERAL == setting) {
+		/*
+		 * We don't do anything here. The PAI is only driven by the
+		 * picoArray so this will be automatically set in the loadfile
+		 * when the design is next loaded.
+		 */
+		err = 0;
+	} else if (MUX_UNMUXED == setting) {
+		/* This can't be changed at run-time! */
+		return -EPERM;
+	}
+
+	err = axi2cfg_config_write(PC302_PAI_CAEID, PAI_IO_CTRL_REG, &data, 1);
+	if (1 != err) {
+		printf("unable to write PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	err = 0;
+
+out:
+	return err;
+}
+
+static struct muxed_pin pai_pins[] = {
+PIN(sdgpio4, PC302_GPIO_PIN_SDGPIO_4, -1, pai_set_mux, pai_get_mux),
+PIN(sdgpio5, PC302_GPIO_PIN_SDGPIO_5, -1, pai_set_mux, pai_get_mux),
+PIN(sdgpio6, PC302_GPIO_PIN_SDGPIO_6, -1, pai_set_mux, pai_get_mux),
+PIN(sdgpio7, PC302_GPIO_PIN_SDGPIO_7, -1, pai_set_mux, pai_get_mux),
+PIN(arm4, -1, PC302_GPIO_PIN_ARM_4, pai_set_mux, pai_get_mux),
+PIN(arm5, -1, PC302_GPIO_PIN_ARM_5, pai_set_mux, pai_get_mux),
+PIN(arm6, -1, PC302_GPIO_PIN_ARM_6, pai_set_mux, pai_get_mux),
+PIN(arm7, -1, PC302_GPIO_PIN_ARM_7, pai_set_mux, pai_get_mux),
+};
+
+static struct pin_group pai_group = {
+	.nr_pins    = ARRAY_SIZE(pai_pins),
+	.name	    = "pai/ebi",
+	.pins	    = pai_pins,
+};
+
+static int
+shd_get_mux(struct muxed_pin *pin)
+{
+	unsigned bit;
+	unsigned long syscfg = syscfg_read();
+
+	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
+		return MUX_PERIPHERAL;
+
+	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_0) {
+		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
+			return MUX_PERIPHERAL;
+		else
+			return MUX_SD;
+	}
+
+	bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+			pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
+
+	return syscfg & bit ? MUX_ARM : MUX_SD;
+}
+
+static int
+shd_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting)
+{
+	unsigned bit;
+	unsigned long syscfg = syscfg_read();
+
+	/*
+	 * In parallel boot mode, shared pin 7 can't be used as it is always
+	 * on the EBI.
+	 */
+	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
+		return -EBUSY;
+
+	switch (setting) {
+	case MUX_PERIPHERAL:
+		/*
+		 * SDGPIO pin 0 is shared with the Frac-N.
+		 */
+		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
+			syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
+				      AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
+			break;
+		}
+		return -EIO;
+
+	case MUX_SD:
+		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+			    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
+		syscfg_update(bit, 0);
+		break;
+
+	case MUX_ARM:
+		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin)
+			return -EINVAL;
+		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+			    pin->arm_pin - PC302_GPIO_PIN_ARM_8);
+		syscfg_update(bit, bit);
+		break;
+
+	case MUX_UNMUXED:
+		/* This can't be changed at run-time! */
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static struct muxed_pin shared_pins[] = {
+GPIO(shared0, PC302_GPIO_PIN_SDGPIO_8, PC302_GPIO_PIN_ARM_8, shd_set_mux,
+     shd_get_mux),
+GPIO(shared1, PC302_GPIO_PIN_SDGPIO_9, PC302_GPIO_PIN_ARM_9, shd_set_mux,
+     shd_get_mux),
+GPIO(shared2, PC302_GPIO_PIN_SDGPIO_10, PC302_GPIO_PIN_ARM_10, shd_set_mux,
+     shd_get_mux),
+GPIO(shared3, PC302_GPIO_PIN_SDGPIO_11, PC302_GPIO_PIN_ARM_11, shd_set_mux,
+     shd_get_mux),
+GPIO(shared4, PC302_GPIO_PIN_SDGPIO_12, PC302_GPIO_PIN_ARM_12, shd_set_mux,
+     shd_get_mux),
+GPIO(shared5, PC302_GPIO_PIN_SDGPIO_13, PC302_GPIO_PIN_ARM_13, shd_set_mux,
+     shd_get_mux),
+GPIO(shared6, PC302_GPIO_PIN_SDGPIO_14, PC302_GPIO_PIN_ARM_14, shd_set_mux,
+     shd_get_mux),
+PIN(shared7, PC302_GPIO_PIN_SDGPIO_15, PC302_GPIO_PIN_ARM_15, shd_set_mux,
+    shd_get_mux),
+};
+
+static struct pin_group shd_group = {
+	.nr_pins    = ARRAY_SIZE(shared_pins),
+	.name	    = "shared/ebi",
+	.pins	    = shared_pins,
+};
+
+static struct muxed_pin fracn_pins[] = {
+PIN(sdgpio0, PC302_GPIO_PIN_SDGPIO_0, -1, shd_set_mux, shd_get_mux),
+};
+
+static struct pin_group fracn_group = {
+	.nr_pins    = ARRAY_SIZE(fracn_pins),
+	.name	    = "fracn/sdgpio0",
+	.pins	    = fracn_pins,
+};
+
+static struct pin_group *pc3x2_groups[] = {
+	&shd_group,
+	&pai_group,
+	&fracn_group,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+/*****************************************************************************
+ * PC3X3 pin multiplexing.
+ ****************************************************************************/
+#ifdef CONFIG_PICOCHIP_PC3X3
+
+#define SHD_GPIO_MUX_REG        (PC302_AXI2CFG_BASE + \
+				 AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET)
+#define USE_EBI_GPIO_REG	(PC302_AXI2CFG_BASE + \
+				 AXI2CFG_USE_EBI_GPIO_REG_OFFSET)
+#define USE_PAI_GPIO_REG	(PC302_AXI2CFG_BASE + \
+				 AXI2CFG_USE_PAI_GPIO_REG_OFFSET)
+#define USE_DECODE_GPIO_REG	(PC302_AXI2CFG_BASE + \
+				 AXI2CFG_USE_DECODE_GPIO_REG_OFFSET)
+#define USE_MISC_INT_GPIO_REG	(PC302_AXI2CFG_BASE + \
+				 AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET)
+
+/*
+ * Set the muxing of one of the shared pins.
+ */
+static void
+pc3xx_shd_gpio_set_mux(int arm_pin_nr,
+		       enum mux_setting setting)
+{
+	unsigned long shd_mux = pc302_read_from_register(SHD_GPIO_MUX_REG);
+
+	if (MUX_ARM == setting)
+		shd_mux |= (1 << arm_pin_nr);
+	else
+		shd_mux &= ~(1 << arm_pin_nr);
+
+	pc302_write_to_register(SHD_GPIO_MUX_REG, shd_mux);
+}
+
+static int
+pc3xx_get_shd_mux(struct muxed_pin *pin)
+{
+	unsigned long shd_mux = pc302_read_from_register(SHD_GPIO_MUX_REG);
+	unsigned long syscfg = syscfg_read();
+
+	if (pin->sd_pin == PC3X3_GPIO_PIN_SDGPIO_0) {
+		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
+			return MUX_PERIPHERAL;
+		else
+			return MUX_SD;
+	}
+
+	return shd_mux & (1 << pin->arm_pin) ? MUX_ARM : MUX_SD;
+}
+
+/*
+ * Shared ARM/SD gpio pins. These pins go to the arm_gpio[3:0] pads but can
+ * be arm or sdgpio.
+ */
+static int
+pc3xx_shd_mux(struct muxed_pin *pin,
+	      enum mux_setting setting)
+{
+	if (MUX_PERIPHERAL == setting) {
+		if (pin->sd_pin != PC3X3_GPIO_PIN_SDGPIO_0)
+			return -EINVAL;
+
+		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
+			      AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
+	} else if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
+		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+	}
+
+	if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin && MUX_ARM == setting)
+		return -EINVAL;
+
+	pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
+
+	return 0;
+}
+
+static struct muxed_pin armgpio_0_4[] = {
+GPIO(arm_gpio0, PC3X3_GPIO_PIN_SDGPIO_16, PC3X3_GPIO_PIN_ARM_0, pc3xx_shd_mux,
+     pc3xx_get_shd_mux),
+GPIO(arm_gpio1, PC3X3_GPIO_PIN_SDGPIO_17, PC3X3_GPIO_PIN_ARM_1, pc3xx_shd_mux,
+     pc3xx_get_shd_mux),
+GPIO(arm_gpio2, PC3X3_GPIO_PIN_SDGPIO_18, PC3X3_GPIO_PIN_ARM_2, pc3xx_shd_mux,
+     pc3xx_get_shd_mux),
+GPIO(arm_gpio3, PC3X3_GPIO_PIN_SDGPIO_19, PC3X3_GPIO_PIN_ARM_3, pc3xx_shd_mux,
+     pc3xx_get_shd_mux),
+};
+
+static struct pin_group armgpio_0_4_group = {
+	.nr_pins    = ARRAY_SIZE(armgpio_0_4),
+	.name	    = "arm_gpio[3:0]",
+	.pins	    = armgpio_0_4,
+};
+
+static struct muxed_pin shd_gpio[] = {
+GPIO(shd_gpio, PC3X3_GPIO_PIN_SDGPIO_8, PC3X3_GPIO_PIN_ARM_8, pc3xx_shd_mux,
+     pc3xx_get_shd_mux),
+};
+
+static struct pin_group pc3x3_shd_group = {
+	.nr_pins    = ARRAY_SIZE(shd_gpio),
+	.name	    = "shd_gpio",
+	.pins	    = shd_gpio,
+};
+
+/*
+ * boot_mode[1:0] pads - the pins switch to gpio automatically after boot and
+ * can be either arm or sdgpio.
+ */
+static struct muxed_pin boot_mode_0_1[] = {
+GPIO(boot_mode0, PC3X3_GPIO_PIN_SDGPIO_9, PC3X3_GPIO_PIN_ARM_9,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+GPIO(boot_mode1, PC3X3_GPIO_PIN_SDGPIO_10, PC3X3_GPIO_PIN_ARM_10,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group boot_mode_group = {
+	.nr_pins    = ARRAY_SIZE(boot_mode_0_1),
+	.name	    = "boot_mode[1:0]",
+	.pins	    = boot_mode_0_1,
+};
+
+/*
+ * sdram_speed_sel pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin sdram_speed_sel[] = {
+GPIO(sdram_speed_sel, PC3X3_GPIO_PIN_SDGPIO_11, PC3X3_GPIO_PIN_ARM_11,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group sdram_speed_sel_group = {
+	.nr_pins    = ARRAY_SIZE(sdram_speed_sel),
+	.name	    = "sdram_speed_sel",
+	.pins	    = sdram_speed_sel,
+};
+
+/*
+ * mii_rev_en pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_rev_en[] = {
+GPIO(mii_rev_en, PC3X3_GPIO_PIN_SDGPIO_12, PC3X3_GPIO_PIN_ARM_12,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_rev_en_group = {
+	.nr_pins    = ARRAY_SIZE(mii_rev_en),
+	.name	    = "mii_rev_en",
+	.pins	    = mii_rev_en,
+};
+
+/*
+ * mii_rmii_en pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_rmii_en[] = {
+GPIO(mii_rmii_en, PC3X3_GPIO_PIN_SDGPIO_13, PC3X3_GPIO_PIN_ARM_13,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_rmii_en_group = {
+	.nr_pins    = ARRAY_SIZE(mii_rmii_en),
+	.name	    = "mii_rmii_en",
+	.pins	    = mii_rmii_en,
+};
+
+/*
+ * mii_speed_sel pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_speed_sel[] = {
+GPIO(mii_speed_sel, PC3X3_GPIO_PIN_SDGPIO_14, PC3X3_GPIO_PIN_ARM_14,
+     pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_speed_sel_group = {
+	.nr_pins    = ARRAY_SIZE(mii_speed_sel),
+	.name	    = "mii_speed_sel",
+	.pins	    = mii_speed_sel,
+};
+
+static int
+pc3x3_shd_ebi_get_mux(struct muxed_pin *pin)
+{
+	int ebi_pin, err = 0, can_be_sd = 1;
+	unsigned long ebi_mux;
+
+	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
+
+	/*
+	 * Find out what EBI pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else {
+		/* These aren't shared gpio pins. */
+		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
+		can_be_sd = 0;
+	}
+
+	if (!(ebi_mux & (1 << (ebi_pin - 14)))) {
+		err = MUX_PERIPHERAL;
+		goto out;
+	}
+
+	if (can_be_sd)
+		err = pc3xx_get_shd_mux(pin);
+	else
+		err = MUX_ARM;
+
+out:
+	return err;
+}
+
+static int
+pc3x3_shd_ebi_set_mux(struct muxed_pin *pin,
+		      enum mux_setting setting)
+{
+	int ebi_pin, err = 0, can_be_sd = 1;
+	unsigned long ebi_mux;
+
+	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
+
+	/*
+	 * Find out what EBI pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else {
+		/* These aren't shared gpio pins. */
+		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
+		can_be_sd = 0;
+	}
+
+	if (MUX_SD == setting && !can_be_sd) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Use the pin as EBI. */
+	if (MUX_PERIPHERAL == setting)
+		ebi_mux &= ~(1 << (ebi_pin - 14));
+	else
+		ebi_mux |= (1 << (ebi_pin - 14));
+
+	pc302_write_to_register(USE_EBI_GPIO_REG, ebi_mux);
+
+	/*
+	 * Make sure that the configuration is valid (the GPIO isn't going to
+	 * the PAI).
+	 */
+	if (pc302_read_from_register(USE_EBI_GPIO_REG) != ebi_mux) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * If we can be SD or ARM and we want to be gpio, pick the correct
+	 * one now.
+	 */
+	if (MUX_PERIPHERAL != setting && can_be_sd)
+		pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
+
+out:
+	return err;
+}
+
+/*
+ * ebi_addr[25:18] pads - these pads can be either the EBI or arm gpio or
+ * sdgpio. Note: the gpio pins can also be routed to the pai_tx/rx_data pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the pai tx/rx data pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin ebi_addr_18_25[] = {
+PIN(ebi_addr18, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr19, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr20, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr21, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr22, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr23, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr24, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr25, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
+    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+};
+
+static struct pin_group ebi_addr_18_25_group = {
+	.nr_pins    = ARRAY_SIZE(ebi_addr_18_25),
+	.name	    = "ebi_addr[25:18]",
+	.pins	    = ebi_addr_18_25,
+};
+
+static int
+pc3x3_shd_pai_get_mux(struct muxed_pin *pin)
+{
+	int bit, err = 0, can_be_sd = 1;
+	unsigned long pai_mux;
+
+	pai_mux = pc302_read_from_register(USE_PAI_GPIO_REG);
+
+	/*
+	 * Find out what pai pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		/* pai_tx_data[3:0] */
+		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		/* pai_rx_data[3:0] */
+		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
+		/* pai_tx_data[7:4] */
+		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
+		can_be_sd = 0;
+	} else {
+		/* pai_rx_data[7:4] */
+		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
+		can_be_sd = 0;
+	}
+
+	if (!(pai_mux & (1 << bit))) {
+		err = MUX_PERIPHERAL;
+		goto out;
+	}
+
+	if (can_be_sd)
+		err = pc3xx_get_shd_mux(pin);
+	else
+		err = MUX_ARM;
+
+out:
+	return err;
+}
+
+static int
+pc3x3_shd_pai_set_mux(struct muxed_pin *pin,
+		      enum mux_setting setting)
+{
+	int bit, err = 0, can_be_sd = 1;
+	unsigned long pai_mux;
+
+	pai_mux = pc302_read_from_register(USE_PAI_GPIO_REG);
+
+	/*
+	 * Find out what pai pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		/* pai_tx_data[3:0] */
+		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		/* pai_rx_data[3:0] */
+		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
+		/* pai_tx_data[7:4] */
+		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
+		can_be_sd = 0;
+	} else {
+		/* pai_rx_data[7:4] */
+		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
+		can_be_sd = 0;
+	}
+
+	if (MUX_SD == setting && !can_be_sd) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Use the pin as pai. */
+	if (MUX_PERIPHERAL == setting)
+		pai_mux &= ~(1 << bit);
+	else
+		pai_mux |= (1 << bit);
+
+	pc302_write_to_register(USE_PAI_GPIO_REG, pai_mux);
+
+	/*
+	 * Make sure that the configuration is valid (the GPIO isn't going to
+	 * the EBI).
+	 */
+	if (pc302_read_from_register(USE_PAI_GPIO_REG) != pai_mux) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * If we can be SD or ARM and we want to be gpio, pick the correct
+	 * one now.
+	 */
+	if (MUX_PERIPHERAL != setting && can_be_sd)
+		pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
+
+out:
+	return err;
+}
+
+/*
+ * pai_rx_data[3:0] pads - these pads can be either the pai_rx_data or arm
+ * gpio or sdgpio. Note: the gpio pins can also be routed to the
+ * ebi_addr pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the ebi address pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin pai_rx_data_0_3[] = {
+PIN(pai_rx_data0, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data1, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data2, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data3, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_rx_data_0_3_group = {
+	.nr_pins    = ARRAY_SIZE(pai_rx_data_0_3),
+	.name	    = "pai_rx_data[3:0]",
+	.pins	    = pai_rx_data_0_3,
+};
+
+/*
+ * pai_tx_data[3:0] pads - these pads can be either the pai_tx_data or arm
+ * gpio or sdgpio. Note: the gpio pins can also be routed to the
+ * ebi_addr pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the ebi address pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin pai_tx_data_0_3[] = {
+PIN(pai_tx_data0, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data1, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data2, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data3, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
+    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_tx_data_0_3_group = {
+	.nr_pins    = ARRAY_SIZE(pai_tx_data_0_3),
+	.name	    = "pai_tx_data[3:0]",
+	.pins	    = pai_tx_data_0_3,
+};
+
+/*
+ * pai_tx_data[7:4] pads - these pads can either be pai_tx_data or arm gpio.
+ */
+static struct muxed_pin pai_tx_data_4_7[] = {
+PIN(pai_tx_data4, -1, PC3X3_GPIO_PIN_ARM_24, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data5, -1, PC3X3_GPIO_PIN_ARM_25, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data6, -1, PC3X3_GPIO_PIN_ARM_26, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_tx_data7, -1, PC3X3_GPIO_PIN_ARM_27, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_tx_data_4_7_group = {
+	.nr_pins    = ARRAY_SIZE(pai_tx_data_4_7),
+	.name	    = "pai_tx_data[7:4]",
+	.pins	    = pai_tx_data_4_7,
+};
+
+/*
+ * pai_rx_data[7:4] pads - these pads can either be pai_rx_data or arm gpio.
+ */
+static struct muxed_pin pai_rx_data_4_7[] = {
+PIN(pai_rx_data4, -1, PC3X3_GPIO_PIN_ARM_28, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data5, -1, PC3X3_GPIO_PIN_ARM_29, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data6, -1, PC3X3_GPIO_PIN_ARM_30, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+PIN(pai_rx_data7, -1, PC3X3_GPIO_PIN_ARM_31, pc3x3_shd_pai_set_mux,
+    pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_rx_data_4_7_group = {
+	.nr_pins    = ARRAY_SIZE(pai_rx_data_4_7),
+	.name	    = "pai_rx_data[7:4]",
+	.pins	    = pai_rx_data_4_7,
+};
+
+/*
+ * ebi_addr[17:14] pads - these pads can either be ebi_addr or arm gpio.
+ */
+static struct muxed_pin ebi_addr_14_17[] = {
+PIN(ebi_addr14, -1, PC3X3_GPIO_PIN_ARM_32, pc3x3_shd_ebi_set_mux,
+    pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr15, -1, PC3X3_GPIO_PIN_ARM_33, pc3x3_shd_ebi_set_mux,
+    pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr16, -1, PC3X3_GPIO_PIN_ARM_34, pc3x3_shd_ebi_set_mux,
+    pc3x3_shd_ebi_get_mux),
+PIN(ebi_addr17, -1, PC3X3_GPIO_PIN_ARM_35, pc3x3_shd_ebi_set_mux,
+    pc3x3_shd_ebi_get_mux),
+};
+
+static struct pin_group ebi_addr_14_17_group = {
+	.nr_pins    = ARRAY_SIZE(ebi_addr_14_17),
+	.name	    = "ebi_addr[17:14]",
+	.pins	    = ebi_addr_14_17,
+};
+
+static int
+decode_get_mux(struct muxed_pin *pin)
+{
+	unsigned bit = 1 << (pin->arm_pin - PC3X3_GPIO_PIN_ARM_36);
+	unsigned long use_decode_gpio =
+            pc302_read_from_register(USE_DECODE_GPIO_REG);
+
+	return use_decode_gpio & (1 << bit) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int
+decode_set_mux(struct muxed_pin *pin,
+	       enum mux_setting setting)
+{
+	unsigned long use_decode_gpio;
+	unsigned bit = pin->arm_pin == PC3X3_GPIO_PIN_ARM_36 ? 0 : 1;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_decode_gpio = pc302_read_from_register(USE_DECODE_GPIO_REG);
+	if (MUX_ARM == setting)
+		use_decode_gpio |= (1 << bit);
+	else
+		use_decode_gpio &= ~(1 << bit);
+	pc302_write_to_register(USE_DECODE_GPIO_REG, use_decode_gpio);
+
+	return 0;
+}
+
+/*
+ * decode[3:0] pads - these pads can either be decode pins or arm gpio.
+ */
+static struct muxed_pin decode_0_3[] = {
+PIN(decode0, -1, PC3X3_GPIO_PIN_ARM_36, decode_set_mux, decode_get_mux),
+PIN(decode1, -1, PC3X3_GPIO_PIN_ARM_37, decode_set_mux, decode_get_mux),
+PIN(decode2, -1, PC3X3_GPIO_PIN_ARM_38, decode_set_mux, decode_get_mux),
+PIN(decode3, -1, PC3X3_GPIO_PIN_ARM_39, decode_set_mux, decode_get_mux),
+};
+
+static struct pin_group decode_0_3_group = {
+	.nr_pins    = ARRAY_SIZE(decode_0_3),
+	.name	    = "decode[3:0]",
+	.pins	    = decode_0_3,
+};
+
+static int
+ssi_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting);
+
+static int
+ssi_get_mux(struct muxed_pin *pin);
+
+/*
+ * ssi pads - these pads can either be ssi block pins or arm gpio.
+ */
+static struct muxed_pin ssi[] = {
+PIN(ssi_clk, -1, PC3X3_GPIO_PIN_ARM_40, ssi_set_mux, ssi_get_mux),
+PIN(ssi_data_in, -1, PC3X3_GPIO_PIN_ARM_41, ssi_set_mux, ssi_get_mux),
+PIN(ssi_data_out, -1, PC3X3_GPIO_PIN_ARM_42, ssi_set_mux, ssi_get_mux),
+};
+
+static int
+ssi_get_mux(struct muxed_pin *pin)
+{
+	unsigned long use_misc_int_gpio =
+            pc302_read_from_register(USE_MISC_INT_GPIO_REG);
+
+	return use_misc_int_gpio & (1 << 0) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int
+ssi_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting)
+{
+	unsigned long use_misc_int_gpio;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_misc_int_gpio = pc302_read_from_register(USE_MISC_INT_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		use_misc_int_gpio &= ~(1 << 0);
+	else
+		use_misc_int_gpio |= (1 << 0);
+	pc302_write_to_register(USE_MISC_INT_GPIO_REG, use_misc_int_gpio);
+
+	return 0;
+}
+
+static struct pin_group ssi_group = {
+	.nr_pins    = ARRAY_SIZE(ssi),
+	.name	    = "ssi",
+	.pins	    = ssi,
+};
+
+static int
+mii_get_mux(struct muxed_pin *pin)
+{
+	unsigned long syscfg = syscfg_read();
+
+	return syscfg & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int
+mii_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting)
+{
+	/*
+	 * These are automatically configured by hardware if we are in
+	 * reduced MII mode.
+	 */
+	return -EOPNOTSUPP;
+}
+
+/*
+ * mii pads - these pads can either be mii pins or arm gpio.
+ */
+static struct muxed_pin mii[] = {
+PIN(mii_tx_data2, -1, PC3X3_GPIO_PIN_ARM_43, mii_set_mux, mii_get_mux),
+PIN(mii_tx_data3, -1, PC3X3_GPIO_PIN_ARM_44, mii_set_mux, mii_get_mux),
+PIN(mii_rx_data2, -1, PC3X3_GPIO_PIN_ARM_45, mii_set_mux, mii_get_mux),
+PIN(mii_rx_data3, -1, PC3X3_GPIO_PIN_ARM_46, mii_set_mux, mii_get_mux),
+PIN(mii_col, -1, PC3X3_GPIO_PIN_ARM_47, mii_set_mux, mii_get_mux),
+PIN(mii_crs, -1, PC3X3_GPIO_PIN_ARM_48, mii_set_mux, mii_get_mux),
+PIN(mii_tx_clk, -1, PC3X3_GPIO_PIN_ARM_49, mii_set_mux, mii_get_mux),
+};
+
+static struct pin_group mii_group = {
+	.nr_pins    = ARRAY_SIZE(mii),
+	.name	    = "mii",
+	.pins	    = mii,
+};
+
+static int
+max_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting);
+
+static int
+max_get_mux(struct muxed_pin *pin);
+
+/*
+ * maxim pads - these pads can either be maxim pins or arm gpio.
+ */
+static struct muxed_pin max[] = {
+PIN(max_tx_ctrl, -1, PC3X3_GPIO_PIN_ARM_50, max_set_mux, max_get_mux),
+PIN(max_ref_clk, -1, PC3X3_GPIO_PIN_ARM_51, max_set_mux, max_get_mux),
+PIN(max_trig_clk, -1, PC3X3_GPIO_PIN_ARM_52, max_set_mux, max_get_mux),
+};
+
+static int
+max_get_mux(struct muxed_pin *pin)
+{
+	unsigned long use_misc_int_gpio =
+            pc302_read_from_register(USE_MISC_INT_GPIO_REG);
+
+	return use_misc_int_gpio & (1 << 1) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int
+max_set_mux(struct muxed_pin *pin,
+	    enum mux_setting setting)
+{
+	unsigned long use_misc_int_gpio;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_misc_int_gpio = pc302_read_from_register(USE_MISC_INT_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		use_misc_int_gpio &= ~(1 << 1);
+	else
+		use_misc_int_gpio |= (1 << 1);
+	pc302_write_to_register(USE_MISC_INT_GPIO_REG, use_misc_int_gpio);
+
+	return 0;
+}
+
+
+static struct pin_group max_group = {
+	.nr_pins    = ARRAY_SIZE(max),
+	.name	    = "mii",
+	.pins	    = max,
+};
+
+static int
+ebi_clk_get_mux(struct muxed_pin *pin)
+{
+	unsigned long ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
+
+	return ebi_mux & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int
+ebi_clk_set_mux(struct muxed_pin *pin,
+	        enum mux_setting setting)
+{
+	unsigned long ebi_mux;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		ebi_mux &= ~(1 << 13);
+	else
+		ebi_mux |= (1 << 13);
+	pc302_write_to_register(USE_EBI_GPIO_REG, ebi_mux);
+
+	return 0;
+}
+
+/*
+ * ebi clock pads - this pad can either be the ebi clock or an arm gpio.
+ */
+static struct muxed_pin ebi_clk[] = {
+PIN(ebi_clk, -1, PC3X3_GPIO_PIN_ARM_53, ebi_clk_set_mux, ebi_clk_get_mux),
+};
+
+static struct pin_group ebi_clk_group = {
+	.nr_pins    = ARRAY_SIZE(ebi_clk),
+	.name	    = "ebi_clk",
+	.pins	    = ebi_clk,
+};
+
+static struct muxed_pin pc3x3_fracn_pins[] = {
+PIN(sdgpio0, PC3X3_GPIO_PIN_SDGPIO_0, -1, pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group pc3x3_fracn_group = {
+	.nr_pins    = ARRAY_SIZE(pc3x3_fracn_pins),
+	.name	    = "fracn/sdgpio0",
+	.pins	    = pc3x3_fracn_pins,
+};
+
+static struct pin_group *pc3x3_groups[] = {
+	&armgpio_0_4_group,
+	&pc3x3_shd_group,
+	&boot_mode_group,
+	&sdram_speed_sel_group,
+	&mii_rev_en_group,
+	&mii_rmii_en_group,
+	&mii_speed_sel_group,
+	&ebi_addr_18_25_group,
+	&pai_tx_data_0_3_group,
+	&pai_rx_data_0_3_group,
+	&pai_tx_data_4_7_group,
+	&pai_rx_data_4_7_group,
+	&ebi_addr_14_17_group,
+	&decode_0_3_group,
+	&ssi_group,
+	&mii_group,
+	&max_group,
+	&ebi_clk_group,
+	&pc3x3_fracn_group,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+/* Public API -------------------------------------------------------------- */
+/*****************************************************************************
+ * Generic level pin multiplexing.
+ ****************************************************************************/
+
+static struct {
+	unsigned	    num_groups;
+	struct pin_group    **groups;
+} all_groups;
+
+int
+pc3xx_pin_set_mux(int pin_nr,
+		  enum mux_setting setting)
+{
+	unsigned i, j;
+	int ret = 0;
+
+	/*
+	 * Don't let users try and trick us - they can't change the hardware
+	 * that much!
+	 */
+	if (MUX_UNMUXED == setting)
+		return -EINVAL;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			/*
+			 * Dedicated GPIO pins aren't shared with a
+			 * peripheral. This is illegal!
+			 */
+			if (pin->is_dedicated_gpio &&
+			    MUX_PERIPHERAL == setting)
+				return -EINVAL;
+			if (pin_nr == pin->arm_pin ||
+			    pin_nr == pin->sd_pin) {
+				ret = pin->set_mux(pin, setting);
+				if (!ret)
+					goto out;
+				/*
+				 * If we failed to set the muxing of this pin,
+				 * carry on looping as we have some
+				 * many-to-many pins so we might pick it up
+				 * again on another output.
+				 */
+			}
+		}
+	}
+
+	/*
+	 * If we don't have a multiplexed pin entry for the requested pin then
+	 * we assume that the pin isn't multiplexed so we don't need to do
+	 * anything.
+	 */
+out:
+	return ret;
+}
+
+int
+pc3xx_group_set_mux(const char *group_name,
+		    enum mux_setting setting)
+{
+	unsigned i, j;
+	int err = -ENXIO;
+
+	/*
+	 * Don't let users try and trick us - they can't change the hardware
+	 * that much!
+	 */
+	if (MUX_UNMUXED == setting)
+		return -EINVAL;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		if (strcmp(group->name, group_name))
+			continue;
+
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			/*
+			 * Dedicated GPIO pins aren't shared with a
+			 * peripheral. This is illegal!
+			 */
+			if (pin->is_dedicated_gpio &&
+			    MUX_PERIPHERAL == setting)
+				return -EINVAL;
+			err = pin->set_mux(pin, setting);
+			if (err)
+				goto out;
+		}
+
+		break;
+	}
+
+out:
+	return err;
+}
+
+int
+pc3xx_get_pin_mux(int pin_nr)
+{
+	unsigned i, j;
+	int ret = 0;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			if (pin_nr == pin->arm_pin ||
+			    pin_nr == pin->sd_pin) {
+				int tmp = pin->get_mux(pin);
+				if (tmp < 0)
+					return tmp;
+				ret |= tmp;
+			}
+		}
+	}
+
+	/*
+	 * If we don't have a multiplexed pin entry for the requested pin then
+	 * we assume that the pin isn't multiplexed.
+	 */
+	return ret ? ret : MUX_UNMUXED;
+}
+
+void
+pc3xx_muxing_init(void)
+{
+	if (!is_pc3x3()) {
+#ifdef CONFIG_PICOCHIP_PC3X2
+		all_groups.num_groups = ARRAY_SIZE(pc3x2_groups);
+		all_groups.groups = pc3x2_groups;
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+	} else {
+#ifdef CONFIG_PICOCHIP_PC3X3
+		all_groups.num_groups = ARRAY_SIZE(pc3x3_groups);
+		all_groups.groups = pc3x3_groups;
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+	}
+}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/reset.S b/arch/arm/cpu/arm926ejs/pc3xx/reset.S
new file mode 100644
index 0000000..4c8c883
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/reset.S
@@ -0,0 +1,63 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file reset.S
+* \brief Function used to reset the PC302 device.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/wdog.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Functions --------------------------------------------------------------- */
+
+	.align	5
+
+/*!
+ *
+ * Perform a software reset of the PC302 device.
+ *
+ */
+.globl reset_cpu
+
+reset_cpu:
+
+        /* Use the 'fallback' watchdog method for reseting */
+
+        ldr     r0, =PC302_WDOG_BASE
+
+        /* Read the control register */
+        ldr     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* Clear the 'Response mode' bit */
+        bic     r1, #WDOGCONTROLREGRMODMASK
+
+        /* Set the 'Watchdog Enable' bit */
+        orr     r1, #WDOGCONTROLREGWDT_ENMASK
+
+        /* Write to the control register */
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* The Watchdog is hardwired for a 1 second timeout */
+
+        /* 'Kick' the Watchdog into life */
+        mov     r1, #WDOG_COUNTER_RESTART_KICK_VALUE
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+reset_loop_forever:
+
+        /* We will never return from this function */
+        b       reset_loop_forever
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/serial.c b/arch/arm/cpu/arm926ejs/pc3xx/serial.c
new file mode 100644
index 0000000..a51b657
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/serial.c
@@ -0,0 +1,279 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file serial.c
+* \brief Functions for providing serial i/o via a UART.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#include <common.h>
+
+#ifdef CONFIG_DW_APB_UART
+
+/* Includes ----------------------------------------------------------------- */
+#include <asm/arch/pc302.h>
+#include <asm/arch/uart.h>
+
+/* Macros ------------------------------------------------------------------- */
+#if !defined(CONFIG_CONS_INDEX)
+#error	"No console index specified."
+#elif (CONFIG_CONS_INDEX < 1) || (CONFIG_CONS_INDEX > 2)
+#error	"Invalid console index value specified."
+#endif
+
+#define IO_WRITE(addr, val) (*(volatile unsigned int *)(addr) = (val))
+#define IO_READ(addr) (*(volatile unsigned int *)(addr))
+
+/* uart[] array is zero based whilst CONFIG_CONS_INDEX is '1' based */
+#define CONSOLE_PORT (CONFIG_CONS_INDEX - 1)
+
+/* Constants ---------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+static volatile unsigned char *const uart[] =
+{
+    (void *)PC302_UART1_BASE,
+    (void *)PC302_UART2_BASE
+};
+
+/* Prototypes---------------------------------------------------------------- */
+/*!
+ *
+ * Write a character to the uart
+ *
+ * Note: This function will block if the Tx FIFO is full
+ *
+ * \param uartNumb Which uart to use
+ * \param c The character to output
+ *
+ */
+static void dwApbUart_putc (int uartNum, char c);
+
+/*!
+ *
+ * Read a character from the uart
+ *
+ * Note: This function will block if the Rx FIFO is empty
+ *
+ * \param uartNumb Which uart to use
+ */
+static int dwApbUart_getc (int uartNum);
+
+/*!
+ *
+ * Test if there is a character available to be read from the uart
+ *
+ * \param uartNumb Which uart to use
+ *
+ * \return 0 no character availbale to be read
+ *         1 character available to be read
+ *
+ */
+static int dwApbUart_tstc (int uartNum);
+
+/* Functions ---------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * serial_init()
+ *
+ * Purpose: Initialise the console uart
+ *
+ * Args:
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+int serial_init (void)
+{
+    unsigned int lcr_register;
+    unsigned int uart_num = CONSOLE_PORT;
+
+    /* Wait while the UART is busy... */
+    while ( ( IO_READ ( uart[uart_num] + UART_UART_STATUS_REG_OFFSET ) &
+             UART_UART_STATUS_BUSY_MASK ) );
+
+    /* Setup the UART for...
+     *  8 data bit word length
+     *  1 stop bit
+     *  parity disabled
+     */
+    lcr_register = IO_READ ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET );
+    lcr_register = lcr_register | UART_LINE_CTRL_DLS_8BITS;
+    lcr_register = lcr_register & UART_LINE_CTRL_1STOP_BIT;
+    lcr_register = lcr_register & UART_LINE_CTRL_PARITY_DISABLE;
+    IO_WRITE ( ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET ), lcr_register );
+
+    /* Enable the Rx & Tx fifos */
+    IO_WRITE ( ( uart[uart_num] + UART_FIFO_CTRL_REG_OFFSET ),
+                UART_FIFO_CTRL_ENABLE );
+
+    /* Set up the baudrate */
+    serial_setbrg ();
+
+    return (0);
+}
+
+/*****************************************************************************
+ *
+ * serial_setbtg()
+ *
+ * Purpose: set the uart baud rate.
+ *
+ * Args:
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+void serial_setbrg (void)
+{
+    unsigned int lcr_register;
+    unsigned int uart_num = CONSOLE_PORT;
+    unsigned int baudrate = gd->baudrate;
+    unsigned int divisor;
+
+    /* Wait while the UART is busy... */
+    while ( ( IO_READ ( uart[uart_num] + UART_UART_STATUS_REG_OFFSET ) &
+              UART_UART_STATUS_BUSY_MASK ) );
+
+    /* Set the Divisor Latch Access Bit in the Line Control Register */
+    lcr_register = IO_READ ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET );
+    lcr_register = lcr_register | UART_LINE_CTRL_DLAB_MASK;
+    IO_WRITE ( ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET ), lcr_register );
+
+    /* Baud Rate = Baud Rate Gen Clock / (16 * divisor) */
+    divisor = DIV_ROUND_UP(CONFIG_DW_APB_UART_CLOCK, (16 * baudrate));
+
+    IO_WRITE ( ( uart[uart_num] + UART_DIVISOR_LOW_REG_OFFSET ),
+               ( divisor & UART_DIVISOR_MASK ) );
+    IO_WRITE ( ( uart[uart_num] + UART_DIVISOR_HIGH_REG_OFFSET ),
+               ( ( divisor >> 8 ) & UART_DIVISOR_MASK ) );
+
+    /* Clear the Divisor Latch Access Bit in the Line Control Register */
+    lcr_register = IO_READ ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET );
+    lcr_register = lcr_register  & ~(UART_LINE_CTRL_DLAB_MASK);
+    IO_WRITE ( ( uart[uart_num] + UART_LINE_CTRL_REG_OFFSET ), lcr_register );
+}
+
+/*****************************************************************************
+ *
+ * serial_putc()
+ *
+ * Purpose: Write a character to the console uart
+ *
+ * Args:
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+void serial_putc (const char c)
+{
+    if (c == '\n')
+    {
+        dwApbUart_putc (CONSOLE_PORT, '\r');
+    }
+
+    dwApbUart_putc (CONSOLE_PORT, c);
+}
+
+/*****************************************************************************
+ *
+ * serial_puts()
+ *
+ * Purpose: Write a string to the console uart
+ *
+ * Args:
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+
+void serial_puts (const char *s)
+{
+
+    while (*s)
+    {
+        serial_putc(*s++);
+    }
+
+}
+
+/*****************************************************************************
+ *
+ * serial_getc()
+ *
+ * Purpose: Read a character from the console uart
+ *
+ * Args:
+ *
+ * Returns:
+ *
+ *****************************************************************************/
+
+int serial_getc (void)
+{
+
+    return dwApbUart_getc(CONSOLE_PORT);
+
+}
+
+/*****************************************************************************
+ *
+ * serial_tstc()
+ *
+ * Purpose: Test to see if there are any characters availale to be read
+ *          from the console uart
+ *
+ * Args:
+ *
+ * Returns: 0 - no character availbale in the Rx FIFO
+ *          1 - character available in the Rx FIFO
+ *
+ *****************************************************************************/
+int serial_tstc (void)
+{
+
+    return dwApbUart_tstc(CONSOLE_PORT);
+
+}
+
+static void dwApbUart_putc (int uartNum, char c)
+{
+
+    /* Wait until there is space in the Tx FIFO... */
+    while ( !( IO_READ ( uart[uartNum] + UART_LINE_STATUS_REG_OFFSET ) &
+               UART_LINE_STATUS_THRE_MASK ) );
+
+    /* Send the character */
+    IO_WRITE ( ( uart[uartNum] + UART_TX_HOLDING_REG_OFFSET ), c);
+}
+
+static int dwApbUart_getc (int uartNum)
+{
+
+    /* Wait until there is a character in the Rx FIFO... */
+    while (!dwApbUart_tstc(CONSOLE_PORT));
+
+    /* Go and read a character... */
+    return ( IO_READ ( uart[uartNum] + UART_RX_BUFFER_REG_OFFSET ) );
+
+}
+
+static int dwApbUart_tstc (int uartNum)
+{
+
+    return ( IO_READ ( uart[uartNum] + UART_LINE_STATUS_REG_OFFSET ) &
+             UART_LINE_STATUS_DATA_READY_MASK );
+
+}
+
+#endif /* CONFIG_DW_APB_UART */
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/spi.c b/arch/arm/cpu/arm926ejs/pc3xx/spi.c
new file mode 100644
index 0000000..2f73198
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/spi.c
@@ -0,0 +1,704 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file spi.c
+* \brief SPI driver for the PC302.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_DW_SPI
+
+/* Define this to use a GPIO as the spi flash chip select.
+   Note: On the PC7302 platform we only have a single spi flash device.
+   Note: If this is not defined then we use the chip select generated by the
+         SPI block.
+   Note: Using this option on a PC7302 platform will require a board
+         modification.
+*/
+#undef USE_GPIO_AS_CHIP_SELECT
+
+#include <spi.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/gpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * \brief Debug macro
+ */
+#ifdef	SPI_DEBUG
+#define spi_debug(fmt,args...)	printf (fmt ,##args)
+#else
+#define spi_debug(fmt,args...)
+#endif	/* SPI_DEBUG */
+
+/* !
+ *  \brief Macros used to read from, and write to, the spi registers.
+ *         Note: These macros provide 16 bit access.
+ */
+#define SPI_READ(__offset) \
+                  *((volatile u16*)(PC302_SSI_BASE + __offset))
+
+#define SPI_WRITE(__value, __offset) \
+                   *((volatile u16*)(PC302_SSI_BASE + __offset)) = __value
+
+/* !
+ *  \brief Macros used to read from, and write to, the axi2cfg registers.
+ *         Note: These macros provide 32 bit access.
+ */
+#define AXI2CFG_READ(__offset) \
+                  *((volatile u32*)(PC302_AXI2CFG_BASE + __offset))
+
+#define AXI2CFG_WRITE(__value, __offset) \
+                   *((volatile u32*)(PC302_AXI2CFG_BASE + __offset)) = __value
+
+/* Constants --------------------------------------------------------------- */
+/* !
+ *  \brief This structure is used for generic and device specific
+ *         spi driver data.
+ */
+struct pc302_spi_slave
+{
+    /* Generic spi slave description */
+    struct spi_slave slave;
+
+    /* Additional driver data for the pc302 implementation */
+
+    /* Serial clock polarity */
+    unsigned int scpol;
+
+    /* Serial clock phase */
+    unsigned int scph;
+
+    /* Serial bus speed (Hz) */
+    unsigned int max_hz;
+
+    /* Pointer to hold location of the Tx data 'copy' */
+    u8 * dout_copy;
+
+    /* Keep a count of the data to tx */
+    unsigned int byte_count_tx;
+};
+
+/*!
+ * \brief Function return codes
+ */
+enum return_codes
+{
+    SUCCESS = 0,    /* Successful outcome */
+    FAILURE = 1     /* Error response */
+};
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+void spi_init()
+{
+    /* Nothing specific required in here */
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus,
+                                  unsigned int cs,
+                                  unsigned int max_hz,
+                                  unsigned int mode)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    unsigned int    spi_max_clock = 0;
+    unsigned int    spi_min_clock = 0;
+
+    /* Have we been passed a valid combination of bus and cs ?
+       Note: PC302 device has a single SPI controller (bus) and
+             4 possible SPI chip selects */
+
+    if (bus > (PC302_MAX_NUMBER_SPI_BUSSES - 1))
+    {
+        /* Oops, request bus is out of range. */
+        printf ("Oops, SPI 'bus' out of range. "
+                "(We only have %d SPI bus(ses) available).\n",
+                (unsigned int)PC302_MAX_NUMBER_SPI_BUSSES);
+        return NULL;
+    }
+
+    if (cs > (PC302_MAX_NUMBER_SPI_CS - 1))
+    {
+        /* Oops, requested chip select is out of range */
+        printf ("Oops, SPI 'cs' out of range. "
+                "(We only have %d 'cs' available).\n",
+                (unsigned int)PC302_MAX_NUMBER_SPI_CS);
+        return NULL;
+    }
+
+    /* Have we been passed a valid SPI bus clock rate ? */
+    spi_max_clock = (PC302_AHB_CLOCK_FREQ / PC302_MIN_SPI_CLK_DIVIDER);
+    spi_min_clock = (PC302_AHB_CLOCK_FREQ / PC302_MAX_SPI_CLK_DIVIDER);
+
+    if ((max_hz < spi_min_clock) || (max_hz > spi_max_clock))
+    {
+    	/* Oops, we do not support this requested SPI bus clock rate */
+        printf ("Oops, SPI bus 'hz' out of range. "
+                "(Min = %d Hz, Max = %d Hz).\n", spi_min_clock, spi_max_clock);
+	return NULL;
+    }
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Have we been passed a valid SPI mode ? */
+    if ((mode < SPI_MODE_0) || (mode > SPI_MODE_3))
+    {
+        /* Oops, we only support spi mode 0 - 3 */
+        printf ("Oops, SPI 'mode' out of range. "
+                "(We only support SPI 'mode' %d to %d).\n",
+                (unsigned int)SPI_MODE_0, (unsigned int)SPI_MODE_3);
+        return NULL;
+    }
+#else
+    /* Have we been passed a valid SPI mode ? */
+    if (mode != SPI_MODE_3)
+    {
+        /* Oops, we only support spi mode 3 */
+        printf ("Oops, SPI 'mode' out of range. "
+                "(We only support SPI 'mode' %d).\n",
+                (unsigned int)SPI_MODE_3);
+        return NULL;
+    }
+#endif
+
+    /* Grab some memory for the SPI data structure */
+    spi_slave = malloc(sizeof(struct pc302_spi_slave));
+    if (!spi_slave)
+    {
+        /* Oops, we have a memory management problem */
+	printf ("Oops, memory allocation error, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return NULL;
+    }
+
+    /* Populate our structure */
+    spi_slave->slave.bus = bus;
+    spi_slave->slave.cs = cs;
+    spi_slave->max_hz = max_hz;
+
+    switch (mode)
+    {
+        case SPI_MODE_0:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 0;
+            break;
+        case SPI_MODE_1:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 1;
+            break;
+        case SPI_MODE_2:
+            spi_slave->scpol = 1;
+            spi_slave->scph = 0;
+            break;
+        case SPI_MODE_3:
+            spi_slave->scpol = 1;
+            spi_slave->scph = 1;
+            break;
+        default:
+            spi_slave->scpol = 0;
+            spi_slave->scph = 0;
+            break;
+    }
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Set up ARM gpio #2 for cs driving */
+    /* Negate the 'cs' in the data register */
+    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+                      GPIO_BIT_2;
+
+    /* Set up the gpio as an o/p */
+    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET) |=
+                      GPIO_BIT_2;
+#endif
+
+    return &spi_slave->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave =
+           container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Free memory acquired to hold the SPI data structure */
+    free (spi_slave);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    u16 ctrlr0 = 0;
+    u16 sckdv = 0;
+
+     /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return -FAILURE;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Disable SPI operations
+       Note: We can't program up the block registers unless
+             the block is disabled  */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Program up some bits Control Register 0.
+       Note: As TMOD bits set to 00 (Transmit & Receive),
+             we do not need to worry about the ctrlr1 register */
+    ctrlr0 = PC302_SPI_DATA_FRM_8_BIT;
+
+    if (spi_slave->scph)
+    {
+        /* Set the clock phase */
+        ctrlr0 |= PC302_SPI_SCPH;
+    }
+    if (spi_slave->scpol)
+    {
+        /* Set the clock polarity */
+        ctrlr0 |= PC302_SPI_SCPOL;
+    }
+    SPI_WRITE(ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
+
+    /* Setup the SPI bus clock rate */
+    sckdv = (PC302_AHB_CLOCK_FREQ / spi_slave->max_hz);
+    SPI_WRITE(sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+
+    /* Mask all interrupts from the SPI block */
+    SPI_WRITE(PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
+
+    return SUCCESS;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+    }
+
+    /* Disable SPI operations */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+}
+
+int spi_xfer(struct spi_slave *slave,
+             unsigned int bitlen,
+             const void *dout,
+             void *din,
+             unsigned long flags)
+{
+    struct pc302_spi_slave  *spi_slave;
+
+    unsigned int    len_tx;
+    unsigned int    len_rx;
+    unsigned int    byte_count;
+
+    u16		    status;
+
+    const u8	    *txp = dout;
+    u8		    *rxp = din;
+    u8		    value;
+
+
+    spi_debug ("spi_xfer: bitlen = %d, dout = %p, din = %p, flags = %d\n",
+                bitlen, dout, din, flags);
+
+     /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return -FAILURE;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    if (bitlen == 0)
+    {
+        /* Finish any previously submitted transfers */
+	goto out;
+    }
+
+    /*
+     * The SPI controller can do non-multiple-of-8 bit
+     * transfers, but this driver currently doesn't support it.
+     */
+    if (bitlen % 8)
+    {
+        /* Errors always terminate an ongoing transfer */
+	flags |= SPI_XFER_END;
+        goto out;
+    }
+
+    /* Number of bytes to transfer */
+    byte_count = bitlen / 8;
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Ok, we are using a chip select generated by a gpio signal */
+
+    if (flags & SPI_XFER_BEGIN)
+    {
+        /* Assert the required chip SPI slave chip select */
+        spi_cs_activate(slave);
+
+        /* Enable SPI operations */
+        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+    }
+
+    /* Start the data transfer */
+    for (len_tx = 0, len_rx = 0; len_rx < byte_count; )
+    {
+        status = SPI_READ(SSI_STATUS_REG_OFFSET);
+
+	if (len_tx < byte_count && (status & PC302_SPI_STATUS_TFNF))
+        {
+	    /* We have room in the Tx fifo */
+            if (txp)
+		value = *txp++;
+	    else
+		value = 0;
+
+            SPI_WRITE(value, SSI_DATA_REG_OFFSET);
+            len_tx++;
+	}
+
+        if (status & PC302_SPI_STATUS_RFNE)
+        {
+	    /* We have some data in the receive fifo */
+            value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
+	    if (rxp)
+	        *rxp++ = value;
+	    len_rx++;
+	}
+    }
+
+out:
+    if (flags & SPI_XFER_END)
+    {
+        /*
+	 * Wait until the transfer is completely done before
+	 * we deactivate CS.
+	 */
+        do
+        {
+	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
+            status &= PC302_SPI_STATUS_BUSY;
+
+	} while (status);
+
+	spi_cs_deactivate(slave);
+    }
+
+    return SUCCESS;
+}
+#else   /* USE_GPIO_AS_CHIP_SELECT */
+
+    /* Using the SPI block to control the chip selects,
+       therefore we need all transactions before we start anything.
+
+       Note: It is imperative that the Tx fifo never empties during operation,
+             if this happens the cs will be negated by the SPI block,
+             the spi flash will 'forget' what it is doing and it will
+             all end in tears ! */
+
+    u8 *dout_copy = NULL;
+    unsigned int byte_count_tx = 0;
+    unsigned int byte_count_rx = 0;
+    unsigned int byte_count_tx_more = 0;
+    unsigned int total_loop_count = 0;
+    unsigned int total_tx_count = 0;
+
+    if (flags & SPI_XFER_BEGIN)
+    {
+        /* If necessary take a copy of the data to transmit */
+        if (txp)
+        {
+            /* Ok, we have some data to Tx */
+
+            /* Grab some memory */
+            dout_copy = malloc(byte_count);
+            if (!dout_copy)
+            {
+                /* Oops, we have a memory management problem */
+	        printf ("Oops, memory allocation error, File: %s,"
+                        " Function: %s, Line: %d\n",
+                        __FILE__, __FUNCTION__, __LINE__);
+                return -FAILURE;
+            }
+
+            /* Lets take a copy of the data */
+            memcpy (dout_copy, dout, byte_count);
+
+            /* Save some useful info for later use */
+            spi_slave->dout_copy = dout_copy;
+            spi_slave->byte_count_tx = byte_count;
+
+            /* We have a copy of the data so can null the
+               tx data pointer */
+            txp = NULL;
+        }
+    }
+
+    if (flags & SPI_XFER_END)
+    {
+        /* Go retrieve the saved data */
+        dout_copy = spi_slave->dout_copy;
+        byte_count_tx = spi_slave->byte_count_tx ;
+
+        if (!dout_copy)
+        {
+            /* Oops, we have a memory management problem */
+	    printf ("Oops, memory allocation error, File: %s,"
+                    " Function: %s, Line: %d\n",
+                    __FILE__, __FUNCTION__, __LINE__);
+            return -FAILURE;
+        }
+
+        /* Have we any more Tx data (spi flash writing) ? */
+        if (txp)
+        {
+            byte_count_tx_more = byte_count;
+        }
+        else
+        {
+            byte_count_tx_more = 0;
+        }
+
+        /* Have we any data to Rx ? */
+        if (rxp)
+        {
+            byte_count_rx = byte_count;
+        }
+        else
+        {
+            byte_count_rx = 0;
+        }
+
+        /* Assert the required chip SPI slave chip select */
+        spi_cs_activate(slave);
+
+        /* Enable SPI block operations */
+        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+        /* Set up some variables to avoid calculating them during the loop */
+        total_loop_count = byte_count_rx + byte_count_tx + byte_count_tx_more;
+        total_tx_count = byte_count_tx + byte_count_tx_more;
+
+        spi_debug ("spi_xfer: byte_count_rx = %d\n", byte_count_rx);
+        spi_debug ("spi_xfer: byte_count_tx = %d\n", byte_count_tx);
+        spi_debug ("spi_xfer: byte_count_tx_more = %d\n", byte_count_tx_more);
+        spi_debug ("spi_xfer: total_tx_count = %d\n", total_tx_count);
+        spi_debug ("spi_xfer: total_loop_count = %d\n", total_loop_count);
+
+        for (len_tx = 0, len_rx = 0; len_rx < total_loop_count; )
+        {
+	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
+
+            while (len_tx < byte_count_tx)
+            {
+	        /* The Tx fifo is 16 entries deep, we should never fill
+                   this up sending a 'command' to the flash.  Therefore
+                   we do not check the tx fifo status */
+                SPI_WRITE(*dout_copy++, SSI_DATA_REG_OFFSET);
+                len_tx++;
+            }
+
+            while ((len_tx < total_tx_count) &&
+                   (status & PC302_SPI_STATUS_TFNF))
+            {
+                /* We have more data to Tx, so just keep going */
+                SPI_WRITE(*txp++, SSI_DATA_REG_OFFSET);
+                len_tx++;
+
+                /* We may fill the tx fifo now, so a re-read of
+                   the status register is a good idea */
+                status = SPI_READ(SSI_STATUS_REG_OFFSET);
+            }
+
+            if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
+            {
+                /* We have finished Tx and we are not interested in Rx,
+                  lets get out of here */
+                break;
+            }
+
+            if ((len_tx >= total_tx_count) && (byte_count_rx != 0))
+            {
+                /* Still trying to read some data, so keep the Tx fifo
+                   tickling along, we don't care if the Tx fifo is
+                   full or overflows */
+                SPI_WRITE(0, SSI_DATA_REG_OFFSET);
+            }
+
+            if (status & PC302_SPI_STATUS_RFNE)
+            {
+	        /* We have some data available in the receive fifo */
+                value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
+
+                /* We do not want this data until it is 'valid',
+                   i.e. we have finished transmitting all the Tx data */
+                if (len_rx < total_tx_count)
+                {
+                    /* Just chuck the read data away */
+                }
+                else
+                {
+	            *rxp++ = value;
+                }
+
+                len_rx++;
+	    }
+        }
+    }
+out:
+    if (flags & SPI_XFER_END)
+    {
+        /*
+	 * If we have finished transmitting and we have no data to receive
+         * wait until the transfer is completely done before we deactivate CS.
+	 */
+        if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
+        {
+            /* Make sure the SPI block has actually started
+               doing something... */
+            udelay (500);
+
+            do
+            {
+	        status = SPI_READ(SSI_STATUS_REG_OFFSET);
+                status &= PC302_SPI_STATUS_BUSY;
+
+	    } while (status);
+        }
+
+	spi_cs_deactivate(slave);
+
+        if (spi_slave->dout_copy)
+        {
+            free(spi_slave->dout_copy);
+            spi_slave->dout_copy = NULL;
+        }
+
+        spi_slave->byte_count_tx = 0;
+    }
+
+    return SUCCESS;
+
+}
+#endif  /* USE_GPIO_AS_CHIP_SELECT */
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+    u16 chip_select = 0;
+    u32 system_config = 0;
+
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Make sure the SPI is disabled */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Obtain the chip select are we using */
+    chip_select =  (u16)spi_slave->slave.cs;
+
+    /* Write to the Slave Enable Register */
+    SPI_WRITE((1 << chip_select), SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+       Note: Set all chip select muxing to be SPI */
+    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    system_config &= ~(AXI2CFG_DECODE_MUX_0 |
+                       AXI2CFG_DECODE_MUX_1 |
+                       AXI2CFG_DECODE_MUX_2 |
+                       AXI2CFG_DECODE_MUX_3);
+
+    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Assert the 'cs' */
+    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) &=
+                     ~(GPIO_BIT_2);
+#endif
+
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+    struct pc302_spi_slave  *spi_slave;
+    u16 chip_select = 0;
+    u32 system_config = 0;
+
+    /* Have we been passed a valid data structure handle ? */
+    if (slave == NULL)
+    {
+        /* Oops, bad handle passed in */
+        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+        return;
+    }
+
+    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
+
+    /* Make sure the SPI is disabled */
+    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+    /* Obtain the chip select are we using */
+    chip_select =  (u16)spi_slave->slave.cs;
+
+    /* Write to the Slave Enable Register,
+       Note: Just disable all chip selects for now */
+    SPI_WRITE(PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
+
+    /* Sort out the SPI/EBI chip select muxing.
+       Note: Set all chip select muxing to be EBI */
+    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    system_config |= (AXI2CFG_DECODE_MUX_0 |
+                      AXI2CFG_DECODE_MUX_1 |
+                      AXI2CFG_DECODE_MUX_2 |
+                      AXI2CFG_DECODE_MUX_3);
+
+    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+    /* Negate the 'cs' */
+    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+                     GPIO_BIT_2;
+#endif
+
+}
+
+#endif /* CONFIG_DW_SPI */
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/timer.c b/arch/arm/cpu/arm926ejs/pc3xx/timer.c
new file mode 100644
index 0000000..2a6f905
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/timer.c
@@ -0,0 +1,146 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file timer.c
+* \brief Useful functions for timer implementation.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/timer.h>
+#include <div64.h>
+
+/*
+ * The timer is a decrementer, it runs at a frequency of PC302_AHB_CLOCK_FREQ
+ */
+
+#define READ_TIMER() (*(volatile unsigned int *)\
+		     (CONFIG_SYS_TIMERBASE + TIMERNCURRENTVALUEREGOFFSET(0)))
+
+#define TIMER_LOAD_VAL 0xFFFFFFFF
+
+static unsigned long long timestamp;
+static unsigned long lastdec;
+
+void reset_timer_masked(void)
+{
+	lastdec = READ_TIMER();
+	timestamp = 0;
+}
+
+/* Timer init function */
+int timer_init(void)
+{
+        reset_timer_masked();
+        return 0;
+}
+
+/* Restart counting from 0 */
+void reset_timer (void)
+{
+         reset_timer_masked();
+}
+
+static inline unsigned long long tick_to_time(unsigned long long tick)
+{
+	tick *= CONFIG_SYS_HZ;
+	do_div(tick, PC302_AHB_CLOCK_FREQ);
+	return tick;
+}
+
+static inline unsigned long long time_to_tick(unsigned long long time)
+{
+	time *= PC302_AHB_CLOCK_FREQ;
+	do_div(time, CONFIG_SYS_HZ);
+	return time;
+}
+
+static inline unsigned long long us_to_tick(unsigned long long us)
+{
+	us = us * PC302_AHB_CLOCK_FREQ + 999999;
+	do_div(us, 1000000);
+	return us;
+}
+
+unsigned long long get_ticks(void)
+{
+	ulong now = READ_TIMER();
+
+	if (lastdec >= now)
+		timestamp += (lastdec - now);
+	else
+		timestamp += (lastdec + TIMER_LOAD_VAL - now);
+
+	lastdec = now;
+
+	return timestamp;
+}
+
+ulong get_timer_masked(void)
+{
+	return tick_to_time(get_ticks());
+}
+
+/* Return how many HZ passed since "base" */
+ulong get_timer (ulong base)
+{
+        return get_timer_masked() - base;
+}
+
+/* Delay 'usec' micro seconds */
+void __udelay (unsigned long usec)
+{
+        unsigned long long tmp;
+	unsigned long long tmo;
+
+	tmo = us_to_tick(usec);
+	tmp = get_ticks() + tmo;
+
+	while (get_ticks() < tmp);
+}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/utilities.c b/arch/arm/cpu/arm926ejs/pc3xx/utilities.c
new file mode 100644
index 0000000..2774c79
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/pc3xx/utilities.c
@@ -0,0 +1,243 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file utilities.c
+* \brief Various useful functions for PC3xx devices.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/fuse.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * Bit mask used to obtain the least significant 16 bits
+ */
+#define SIXTEEN_BIT_MASK        ( 0xFFFF )
+
+/*!
+ * Bit mask used to obtain the device ID
+ */
+#define DEVICE_ID_MASK          ( 0xFF )
+
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK     ( 1 << 19 )    /*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK     ( 1 << 18 )    /*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK     ( 1 << 17 )    /*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK    ( 1 << 16 )    /*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK       ( 1 << 17 )    /*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK      ( 1 << 16 )    /*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )                  /*!< The number of retries for an \
+                                         *   AXI2Cfg config read. */
+
+/*! Register offset for the config bus write port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_WR ( 0x0100 )
+
+/*! Register offset for the config bus read port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_RD ( 0x0200 )
+
+/* Constants --------------------------------------------------------------- */
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Functions --------------------------------------------------------------- */
+__inline unsigned int
+pc302_read_from_register (const unsigned int address)
+{
+    /* Read an integer (32 bit) value from a register */
+
+    return(*(volatile unsigned int *)address);
+}
+
+__inline void
+pc302_write_to_register (const unsigned int address,
+                         const unsigned int value)
+{
+    /* Write an integer (32 bit) value to a register */
+
+    *(volatile unsigned int *)address = value;
+}
+
+unsigned int
+pc302_read_device_id (void)
+{
+    unsigned int device_id;
+
+    device_id = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                          AXI2CFG_DEVICE_ID_REG_OFFSET);
+    device_id &= DEVICE_ID_MASK;
+
+    return device_id;
+}
+
+unsigned int
+pc302_read_device_revision (void)
+{
+    unsigned int revision_code;
+
+    revision_code = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                              AXI2CFG_REVISION_ID_REG_OFFSET);
+    revision_code &= SIXTEEN_BIT_MASK;
+
+    return revision_code;
+}
+
+void pc302_read_die_id_number (unsigned int * die_number)
+{
+    /* Read the 128 bit manufacturing id from the fuses and store
+       in the provided array */
+
+    unsigned int i;
+
+    for (i = 0; i < 4; i++)
+    {
+        *die_number++ = pc302_read_from_register(PC302_FUSE_BASE +
+                                                 FUSE_MAP_24_REG_OFFSET +
+                                                 (i * sizeof (unsigned int)));
+    }
+}
+
+unsigned int
+pc302_get_rmii_enabled (void)
+{
+    unsigned int rmii_enabled;
+
+    rmii_enabled = pc302_read_from_register (PC302_AXI2CFG_BASE +
+                                             AXI2CFG_SYS_CONFIG_REG_OFFSET);
+    rmii_enabled &= AXI2CFG_RMII_EN;
+
+    return !!rmii_enabled;
+}
+
+int
+axi2cfg_config_read( u16 caeid,
+                     u16 address,
+                     u16 *data,
+                     u16 count )
+{
+    u32 val;
+    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+    unsigned int read_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
+    u16 to_read = count;
+    u16 rc;
+    unsigned i;
+    unsigned retries;
+
+    val = caeid | CAEID_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    while ( to_read )
+    {
+        /* Output the address to read from. */
+        val = ( address + ( count - to_read ) ) | CADDR_BIT_MASK;
+        pc302_write_to_register( write_p, val );
+
+        /* Dispatch the read requests. */
+        rc = ( to_read > 64 ) ? 64 : to_read;
+        val = CREAD_BIT_MASK | rc;
+        pc302_write_to_register( write_p, val );
+
+        /* Now read the values. */
+        for ( i = 0; i < rc; ++i )
+        {
+            retries = RETRIES;
+            while ( retries )
+            {
+                val = pc302_read_from_register( read_p );
+                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
+                    break;
+                --retries;
+            }
+
+            if ( !retries || ( val & RB_FAIL_MASK ) )
+            {
+                break;
+            }
+            else
+                data[ ( count - to_read ) + i ] = val & 0xFFFF;
+        }
+
+        if ( val & RB_FAIL_MASK )
+            break;
+
+        to_read -= rc;
+    }
+
+    return !( val & RB_FAIL_MASK ) ? count : -EIO;
+}
+
+int
+axi2cfg_config_write( u16 caeid,
+                      u16 address,
+                      u16 *data,
+                      u16 count )
+{
+    u32 val;
+    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+    unsigned i;
+
+    val = caeid | CAEID_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    /* Output the address to write to */
+    val = address | CADDR_BIT_MASK;
+    pc302_write_to_register( write_p, val );
+
+    /* Now write the values. */
+    for ( i = 0; i < count; ++i )
+    {
+        val = data[ i ] | CWRITE_BIT_MASK;
+        pc302_write_to_register( write_p, val );
+    }
+
+    return i;
+}
+
+u32
+syscfg_read(void)
+{
+    return pc302_read_from_register(PC302_AXI2CFG_BASE +
+                                    AXI2CFG_SYS_CONFIG_REG_OFFSET);
+}
+
+void
+syscfg_update(u32 mask,
+	      u32 val)
+{
+    u32 tmp = syscfg_read();
+    tmp &= ~mask;
+    tmp |= (val & mask);
+    pc302_write_to_register((PC302_AXI2CFG_BASE +
+                             AXI2CFG_SYS_CONFIG_REG_OFFSET),tmp);
+}
+
+__inline int
+is_pc3x3(void)
+{
+    u32 dev_id = pc302_read_from_register(PC302_AXI2CFG_BASE +
+                                          AXI2CFG_DEVICE_ID_REG_OFFSET);
+
+    return (dev_id == PC313_DEVICE_ID ||
+            dev_id == PC323_DEVICE_ID ||
+            dev_id == PC333_DEVICE_ID);
+}
diff --git a/arch/arm/include/asm/arch-pc3xx/axi2cfg.h b/arch/arm/include/asm/arch-pc3xx/axi2cfg.h
new file mode 100644
index 0000000..95d7898
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/axi2cfg.h
@@ -0,0 +1,162 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file axi2cfg.h
+* \brief Definitions for the PC3xx AXI2CFG Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_AXI2CFG_H__
+#define __PC3XX_AXI2CFG_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define AXI2CFG_SYS_CONFIG_REG_OFFSET               (0x0000)
+#define AXI2CFG_JTAG_ISC_REG_OFFSET                 (0x0004)
+#define AXI2CFG_IRQ_REG_OFFSET                      (0x0008)
+#define AXI2CFG_PURGE_CFG_PORT_REG_OFFSET           (0x000C)
+#define AXI2CFG_DMA_CFG_REG_OFFSET                  (0x0010)
+#define AXI2CFG_DEVICE_ID_REG_OFFSET                (0x0014)
+#define AXI2CFG_REVISION_ID_REG_OFFSET              (0x0018)
+#define AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET          (0x0034)
+#define AXI2CFG_USE_PAI_GPIO_REG_OFFSET             (0x0038)
+#define AXI2CFG_USE_EBI_GPIO_REG_OFFSET             (0x003C)
+#define AXI2CFG_USE_DECODE_GPIO_REG_OFFSET          (0x0040)
+#define AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET        (0x0044)
+#define AXI2CFG_CLK_GATING_REG_OFFSET               (0x0048)
+#define AXI2CFG_ARM_PLL_CLK_REG_OFFSET              (0x0050)
+#define AXI2CFG_FREQ_SENSE_REG_OFFSET               (0x0054)
+#define AXI2CFG_CONFIG_WRITE_REG_OFFSET             (0x0100)
+#define AXI2CFG_CONFIG_READ_REG_OFFSET              (0x0200)
+#define AXI2CFG_DMAC1_CONFIG_REG_OFFSET             (0x0300)
+
+
+/*****************************************************************************/
+/* Register Bit Fields		                                             */
+/*****************************************************************************/
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_IDX               (30)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ       (8)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_HI       (23)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO       (16)
+#define AXI2CFG_SYS_CONFIG_RW_EBI_CLK_DISABLE_IDX   (15)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX         (14)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX           (13)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX         (12)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ           (4)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_HI           (11)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO           (8)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX       (7)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX         (6)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_IDX             (5)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX            (4)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX            (3)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX            (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ             (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_HI             (1)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_LO             (0)
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_MASK              (1 << AXI2CFG_SYS_CONFIG_PA_RST_IDX)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK         (((1 << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_MASK          (1 << AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK         (((1 << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK      (1<<AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_MASK        (1 << AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_MASK            (1 << AXI2CFG_SYS_CONFIG_RW_REMAP_IDX)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_MASK           (1 << AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK           (((1 << AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ)-1) << AXI2CFG_SYS_CONFIG_BOOT_MODE_LO)
+
+#define AXI2CFG_DMAC1_CONFIG_WR_SZ                  (7)
+#define AXI2CFG_DMAC1_CONFIG_WR_HI                  (16)
+#define AXI2CFG_DMAC1_CONFIG_WR_LO                  (10)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ           (7)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_HI           (9)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_LO           (3)
+#define AXI2CFG_DMAC1_CONFIG_SNGL_IDX               (2)
+#define AXI2CFG_DMAC1_CONFIG_STATE_IDX              (1)
+#define AXI2CFG_DMAC1_CONFIG_ENABLE_IDX             (0)
+
+#define AXI2CFG_JTAG_ISC_REGISTER_IDX               (0)
+#define AXI2CFG_JTAG_ISC_IN_CTRL_IDX                (1)
+#define AXI2CFG_JTAG_ISC_DISABLED_IDX               (2)
+/* [31:2] - Reserved */
+
+#define AXI2CFG_PURGE_CFG_RD_PORT_IDX               (0)
+#define AXI2CFG_PURGE_CFG_WR_PORT_IDX               (1)
+#define AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX         (2)
+/* [31:3]   Reserved */
+
+#define AXI2CFG_DEVICE_ID_NML_302_REG_VALUE         (0x03020004)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define AXI2CFG_PA_SOFT_RESET_IDX                   (30)
+#define AXI2CFG_SHD_GPIO_7_IDX                      (23)
+#define AXI2CFG_SHD_GPIO_6_IDX                      (22)
+#define AXI2CFG_SHD_GPIO_5_IDX                      (21)
+#define AXI2CFG_SHD_GPIO_4_IDX                      (20)
+#define AXI2CFG_SHD_GPIO_3_IDX                      (19)
+#define AXI2CFG_SHD_GPIO_2_IDX                      (18)
+#define AXI2CFG_SHD_GPIO_1_IDX                      (17)
+#define AXI2CFG_SHD_GPIO_0_IDX                      (16)
+#define AXI2CFG_EBI_CLK_DISABLE_IDX                 (15)
+#define AXI2CFG_EXCEPTION_VECT_EN_IDX               (14)
+#define AXI2CFG_RMII_EN_IDX                         (13)
+#define AXI2CFG_REV_MII_EN_IDX                      (12)
+#define AXI2CFG_DECODE_MUX_3_IDX                    (11)
+#define AXI2CFG_DECODE_MUX_2_IDX                    (10)
+#define AXI2CFG_DECODE_MUX_1_IDX                    (9)
+#define AXI2CFG_DECODE_MUX_0_IDX                    (8)
+#define AXI2CFG_MASK_AXI_ERROR_IDX                  (6)
+#define AXI2CFG_REMAP_IDX                           (5)
+#define AXI2CFG_WDG_PAUSE_IDX                       (4)
+#define AXI2CFG_DMA_CHAN_6_MUX_IDX                  (3)
+#define AXI2CFG_DMA_CHAN_7_MUX_IDX                  (2)
+#define AXI2CFG_BOOT_MODE_IDX                       (0)
+
+#define AXI2CFG_PA_SOFT_RESET               (1 << AXI2CFG_PA_SOFT_RESET_IDX)
+#define AXI2CFG_SHD_GPIO_7                  (1 << AXI2CFG_SHD_GPIO_7_IDX)
+#define AXI2CFG_SHD_GPIO_6                  (1 << AXI2CFG_SHD_GPIO_6_IDX)
+#define AXI2CFG_SHD_GPIO_5                  (1 << AXI2CFG_SHD_GPIO_5_IDX)
+#define AXI2CFG_SHD_GPIO_4                  (1 << AXI2CFG_SHD_GPIO_4_IDX)
+#define AXI2CFG_SHD_GPIO_3                  (1 << AXI2CFG_SHD_GPIO_3_IDX)
+#define AXI2CFG_SHD_GPIO_2                  (1 << AXI2CFG_SHD_GPIO_2_IDX)
+#define AXI2CFG_SHD_GPIO_1                  (1 << AXI2CFG_SHD_GPIO_1_IDX)
+#define AXI2CFG_SHD_GPIO_0                  (1 << AXI2CFG_SHD_GPIO_0_IDX)
+#define AXI2CFG_EBI_CLK_DISABLE             (1 << AXI2CFG_EBI_CLK_DISABLE_IDX)
+#define AXI2CFG_EXCEPTION_VECT_EN           (1 << AXI2CFG_EXCEPTION_VECT_EN_IDX)
+#define AXI2CFG_RMII_EN                     (1 << AXI2CFG_RMII_EN_IDX)
+#define AXI2CFG_REV_MII_EN                  (1 << AXI2CFG_REV_MII_EN_IDX)
+#define AXI2CFG_DECODE_MUX_3                (1 << AXI2CFG_DECODE_MUX_3_IDX)
+#define AXI2CFG_DECODE_MUX_2                (1 << AXI2CFG_DECODE_MUX_2_IDX)
+#define AXI2CFG_DECODE_MUX_1                (1 << AXI2CFG_DECODE_MUX_1_IDX)
+#define AXI2CFG_DECODE_MUX_0                (1 << AXI2CFG_DECODE_MUX_0_IDX)
+#define AXI2CFG_MASK_AXI_ERROR              (1 << AXI2CFG_MASK_AXI_ERROR_IDX)
+#define AXI2CFG_REMAP                       (1 << AXI2CFG_REMAP_IDX)
+#define AXI2CFG_WDG_PAUSE                   (1 << AXI2CFG_WDG_PAUSE_IDX)
+#define AXI2CFG_DMA_CHAN_6_MUX              (1 << AXI2CFG_DMA_CHAN_6_MUX_IDX)
+#define AXI2CFG_DMA_CHAN_7_MUX              (1 << AXI2CFG_DMA_CHAN_7_MUX_IDX)
+#define AXI2CFG_BOOT_MODE                   (1 << AXI2CFG_BOOT_MODE_IDX)
+
+#endif /* __PC3XX_AXI2CFG_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/ebi.h b/arch/arm/include/asm/arch-pc3xx/ebi.h
new file mode 100644
index 0000000..44ff838
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/ebi.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file ebi.h
+* \brief Definitions for the PC3xx EBI Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_EBI_H__
+#define __PC3XX_EBI_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define SDRAM_CON_REG_OFFSET                    (0x00)
+#define SDRAM_TIM0_REG_OFFSET                   (0x04)
+#define SDRAM_TIM1_REG_OFFSET                   (0x08)
+#define SDRAM_CTL_REG_OFFSET                    (0x0C)
+#define SDRAM_REFRESH_REG_OFFSET                (0x10)
+#define SCHIP_SEL_REGION0_LOW_REG_OFFSET        (0x14)
+#define SCHIP_SEL_REGION1_LOW_REG_OFFSET        (0x18)
+#define SCHIP_SEL_REGION2_LOW_REG_OFFSET        (0x1C)
+#define SCHIP_SEL_REGION3_LOW_REG_OFFSET        (0x20)
+#define SCHIP_SEL_REGION4_LOW_REG_OFFSET        (0x24)
+#define SCHIP_SEL_REGION5_LOW_REG_OFFSET        (0x28)
+#define SCHIP_SEL_REGION6_LOW_REG_OFFSET        (0x2C)
+#define SCHIP_SEL_REGION7_LOW_REG_OFFSET        (0x30)
+#define SCHIP_SEL_REGION0_HGH_REG_OFFSET        (0x34)
+#define SCHIP_SEL_REGION1_HGH_REG_OFFSET        (0x38)
+#define SCHIP_SEL_REGION2_HGH_REG_OFFSET        (0x3C)
+#define SCHIP_SEL_REGION3_HGH_REG_OFFSET        (0x40)
+#define SCHIP_SEL_REGION4_HGH_REG_OFFSET        (0x44)
+#define SCHIP_SEL_REGION5_HGH_REG_OFFSET        (0x48)
+#define SCHIP_SEL_REGION6_HGH_REG_OFFSET        (0x4C)
+#define SCHIP_SEL_REGION7_HGH_REG_OFFSET        (0x50)
+#define SMASK0_REG_OFFSET                       (0x54)
+#define SMASK1_REG_OFFSET                       (0x58)
+#define SMASK2_REG_OFFSET                       (0x5C)
+#define SMASK3_REG_OFFSET                       (0x60)
+#define SMASK4_REG_OFFSET                       (0x64)
+#define SMASK5_REG_OFFSET                       (0x68)
+#define SMASK6_REG_OFFSET                       (0x6C)
+#define SMASK7_REG_OFFSET                       (0x70)
+#define CHIP_SEL_ALIAS0_LOW_REG_OFFSET          (0x74)
+#define CHIP_SEL_ALIAS1_LOW_REG_OFFSET          (0x78)
+#define CHIP_SEL_ALIAS0_HGH_REG_OFFSET          (0x7C)
+#define CHIP_SEL_ALIAS1_HGH_REG_OFFSET          (0x80)
+#define CHIP_SEL_REMAP0_LOW_REG_OFFSET          (0x84)
+#define CHIP_SEL_REMAP1_LOW_REG_OFFSET          (0x88)
+#define CHIP_SEL_REMAP0_HGH_REG_OFFSET          (0x8C)
+#define CHIP_SEL_REMAP1_HGH_REG_OFFSET          (0x90)
+#define STATIC_MEM_TIMSET0_REG_OFFSET           (0x94)
+#define STATIC_MEM_TIMSET1_REG_OFFSET           (0x98)
+#define STATIC_MEM_TIMSET2_REG_OFFSET           (0x9C)
+#define FLASH_TRPDR_REG_OFFSET                  (0xA0)
+#define STATICM_EMCONTROL_REG_OFFSET            (0xA4)
+#define SYNC_FLASH_OPCODE_REG_OFFSET            (0xA8)
+#define EXTEND_MODE_REG_OFFSET                  (0xAC)
+#define SYNC_FLASH_CONFIG_REG_OFFSET            (0xB0)
+#define SYNC_FLASH_CONTROL_REG_OFFSET           (0xB4)
+#define SYNC_FLASH_TIM_REG_OFFSET               (0xB8)
+
+/* Macros ------------------------------------------------------------------ */
+
+#define SETLOWFREQDEV                           (1<<27)
+#define RESETLOWFREQDEV                         (0<<27)
+#define SETREADYMODE                            (1<<26)
+#define RESETREADYMODE                          (0<<26)
+#define SETPAGEMODE                             (1<<26)
+#define RESETPAGEMODE                           (0<<26)
+#define PAGESIZE4                               (0<<24)
+#define PAGESIZE8                               (1<<24)
+#define PAGESIZE16                              (2<<24)
+#define PAGESIZE32                              (3<<24)
+#define T_PRC_0                                 (4)
+#define T_BTA_0                                 (7)
+#define T_WP_0                                  (20<<10)
+#define T_WR_0                                  (3)
+#define T_AS_0                                  (1)
+#define T_RC_0                                  (32)
+#define T_PRC_1                                 (1)
+#define T_BTA_1                                 (1)
+#define T_WP_1                                  (2)
+#define T_WR_1                                  (1)
+#define T_AS_1                                  (1)
+#define T_RC_1                                  (4)
+#define T_PRC_2                                 (1)
+#define T_BTA_2                                 (1)
+#define T_WP_2                                  (2)
+#define T_WR_2                                  (1)
+#define T_AS_2                                  (1)
+#define T_RC_2                                  (4)
+
+#define EBI_DECODE_0                            (0)
+#define EBI_DECODE_1                            (1)
+#define EBI_DECODE_2                            (2)
+#define EBI_DECODE_3                            (3)
+
+#define EBI_SMSKR_REG_SELECT_SHIFT              (8)
+#define EBI_SMSKR_REG_SELECT_MASK               (3)
+#define EBI_REG_SELECT_TIMING_SET_0             (0)
+#define EBI_REG_SELECT_TIMING_SET_1             (1)
+#define EBI_REG_SELECT_TIMING_SET_2             (2)
+
+#define EBI_SMSKR_MEM_TYPE_SHIFT                (5)
+#define EBI_SMSKR_MEM_TYPE_MASK                 (3)
+#define EBI_MEM_TYPE_SDRAM                      (0)
+#define EBI_MEM_TYPE_SRAM                       (1)
+#define EBI_MEM_TYPE_FLASH                      (2)
+
+#define EBI_SMSKR_MEM_SIZE_SHIFT                (0)
+#define EBI_SMSKR_MEM_SIZE_MASK                 (0x1F)
+#define EBI_MEM_SIZE_NO_MEMORY                  (0x00)
+#define EBI_MEM_SIZE_64KB                       (0x01)
+#define EBI_MEM_SIZE_128KB                      (0x02)
+#define EBI_MEM_SIZE_256KB                      (0x03)
+#define EBI_MEM_SIZE_512KB                      (0x04)
+#define EBI_MEM_SIZE_1MB                        (0x05)
+#define EBI_MEM_SIZE_2MB                        (0x06)
+#define EBI_MEM_SIZE_4MB                        (0x07)
+#define EBI_MEM_SIZE_8MB                        (0x08)
+#define EBI_MEM_SIZE_16MB                       (0x09)
+#define EBI_MEM_SIZE_32MB                       (0x0A)
+#define EBI_MEM_SIZE_64MB                       (0x0B)
+#define EBI_MEM_SIZE_128MB                      (0x0C)
+#define EBI_MEM_SIZE_256MB                      (0x0D)
+#define EBI_MEM_SIZE_512MB                      (0x0E)
+#define EBI_MEM_SIZE_1GB                        (0x0F)
+#define EBI_MEM_SIZE_2GB                        (0x10)
+#define EBI_MEM_SIZE_4GB                        (0x11)
+
+#define EBI_TIMING_SET_0                        (0)
+#define EBI_TIMING_SET_1                        (1)
+#define EBI_TIMING_SET_2                        (2)
+
+#define EBI_SMTMGR_REG_READ_PIPE_SHIFT          (28)
+#define EBI_SMTMGR_REG_READ_PIPE_MASK           (3)
+
+#define EBI_SMTMGR_REG_CLK_SYNC_SHIFT           (27)
+#define EBI_SMTMGR_REG_CLK_SYNC_MASK            (1)
+
+#define EBI_SMTMGR_REG_READY_MODE_SHIFT         (26)
+#define EBI_SMTMGR_REG_READY_MODE_MASK          (1)
+
+#define EBI_SMTMGR_REG_PAGE_SIZE_SHIFT          (24)
+#define EBI_SMTMGR_REG_PAGE_SIZE_MASK           (3)
+#define EBI_PAGE_SIZE_4                         (0)
+#define EBI_PAGE_SIZE_8                         (1)
+#define EBI_PAGE_SIZE_16                        (2)
+#define EBI_PAGE_SIZE_32                        (3)
+
+#define EBI_SMTMGR_REG_PAGE_MODE_SHIFT          (23)
+#define EBI_SMTMGR_REG_PAGE_MODE_MASK           (1)
+
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT    (19)
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK     (0xF)
+
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT    (16)
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK     (0x7)
+
+#define EBI_SMTMGR_REG_WRITE_PULSE_SHIFT        (10)
+#define EBI_SMTMGR_REG_WRITE_PULSE_MASK         (0x3F)
+
+#define EBI_SMTMGR_REG_ADDR_HOLD_SHIFT          (8)
+#define EBI_SMTMGR_REG_ADDR_HOLD_MASK           (3)
+
+#define EBI_SMTMGR_REG_ADDR_SETUP_SHIFT         (6)
+#define EBI_SMTMGR_REG_ADDR_SETUP_MASK          (3)
+
+#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK   (0x1F)
+
+#endif /* __PC3XX_EBI_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/emac.h b/arch/arm/include/asm/arch-pc3xx/emac.h
new file mode 100644
index 0000000..55b0456
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/emac.h
@@ -0,0 +1,189 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file emac.h
+* \brief Definitions for the PC3xx EMAC Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_EMAC_H__
+#define __PC3XX_EMAC_H__
+
+/* Constant-s -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define EMAC_NETWORK_CTRL_REG_OFFSET                                (0x0000)
+#define EMAC_NETWORK_CFG_REG_OFFSET                                 (0x0004)
+#define EMAC_NETWORK_STATUS_REG_OFFSET                              (0x0008)
+#define EMAC_USER_IO_REG_OFFSET                                     (0x000C)
+#define EMAC_DMA_CFG_REG_OFFSET                                     (0x0010)
+#define EMAC_TX_STATUS_REG_OFFSET                                   (0x0014)
+#define EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x0018)
+#define EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x001C)
+#define EMAC_RX_STATUS_REG_OFFSET                                   (0x0020)
+#define EMAC_INT_STATUS_REG_OFFSET                                  (0x0024)
+#define EMAC_INT_ENABLE_REG_OFFSET                                  (0x0028)
+#define EMAC_INT_DISABLE_REG_OFFSET                                 (0x002C)
+#define EMAC_INT_MASK_REG_OFFSET                                    (0x0030)
+#define EMAC_PHY_MAINTAIN_REG_OFFSET                                (0x0034)
+#define EMAC_RX_PAUSE_QUANTUM_REG_OFFSET                            (0x0038)
+#define EMAC_TX_PAUSE_QUATNUM_REG_OFFSET                            (0x003C)
+#define EMAC_HASH_BOT_32_0_REG_OFFSET                               (0x0080)
+#define EMAC_HASH_TOP_63_32_REG_OFFSET                              (0x0084)
+#define EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET                        (0x0088)
+#define EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET                       (0x008C)
+#define EMAC_SPEC_ADDR_2_BOT_31_0_REG_OFFSET                        (0x0090)
+#define EMAC_SPEC_ADDR_2_TOP_47_32_REG_OFFSET                       (0x0094)
+#define EMAC_SPEC_ADDR_3_BOT_31_0_REG_OFFSET                        (0x0098)
+#define EMAC_SPEC_ADDR_3_TOP_47_32_REG_OFFSET                       (0x009C)
+#define EMAC_SPEC_ADDR_4_BOT_31_0_REG_OFFSET                        (0x00A0)
+#define EMAC_SPEC_ADDR_4_TOP_47_32_REG_OFFSET                       (0x00A4)
+#define EMAC_TYPE_ID_MATCH_1_REG_OFFSET                             (0x00A8)
+#define EMAC_TYPE_ID_MATCH_2_REG_OFFSET                             (0x00AC)
+#define EMAC_TYPE_ID_MATCH_3_REG_OFFSET                             (0x00B0)
+#define EMAC_TYPE_ID_MATCH_4_REG_OFFSET                             (0x00B4)
+#define EMAC_WOL_REG_OFFSET                                         (0x00B8)
+#define EMAC_IPG_STRETCH_REG_OFFSET                                 (0x00BC)
+#define EMAC_STACKED_VLAN_REG_OFFSET                                (0x00C0)
+
+#define EMAC_MODULE_ID_REG_OFFSET                                   (0x00FC)
+
+#define EMAC_OCTETS_TX_31_0_REG_OFFSET                              (0x0100)
+#define EMAC_OCTETS_TX_47_32_REG_OFFSET                             (0x0104)
+#define EMAC_FRAMES_TX_NO_ERROR_REG_OFFSET                          (0x0108)
+#define EMAC_BROADCAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x010C)
+#define EMAC_MULTICAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x0110)
+#define EMAC_TX_PAUSE_FRAMES_REG_OFFSET                             (0x0114)
+#define EMAC_64_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET                  (0x0118)
+#define EMAC_65_127_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET              (0x011C)
+#define EMAC_128_255_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0120)
+#define EMAC_256_511_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0124)
+#define EMAC_512_1023_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET            (0x0128)
+#define EMAC_1024_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET           (0x012C)
+#define EMAC_GREATER_THAN_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET   (0x0130)
+#define EMAC_TX_UNDER_RUN_ERROR_REG_OFFSET                          (0x0134)
+#define EMAC_SINGLE_COLLISION_FRAMES_REG_OFFSET                     (0x0138)
+#define EMAC_MULTIPLE_COLLISION_FRAMES_REG_OFFSET                   (0x013C)
+#define EMAC_EXCESSIVE_COLLISIONS_REG_OFFSET                        (0x0140)
+#define EMAC_LATE_COLLISIONS_REG_OFFSET                             (0x0144)
+#define EMAC_DEFFERED_TX_FRAMES_REG_OFFSET                          (0x0148)
+#define EMAC_CARRIER_SENSE_ERRORS_REG_OFFSET                        (0x014C)
+#define EMAC_OCTETS_RX_31_0_NO_ERROR_REG_OFFSET                     (0x0150)
+#define EMAC_OCTETS_RX_47_32_NO_ERROR_REG_OFFSET                    (0x0154)
+#define EMAC_FRAMES_RX_NO_ERROR_REG_OFFSET                          (0x0158)
+#define EMAC_BROADCAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x015C)
+#define EMAC_MULTICAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x0160)
+#define EMAC_PAUSE_FRAME_RX_REG_OFFSET                              (0x0164)
+#define EMAC_64_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET                  (0x0168)
+#define EMAC_65_127_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x016C)
+#define EMAC_128_255_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0170)
+#define EMAC_256_511_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0174)
+#define EMAC_512_1023_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET            (0x0178)
+#define EMAC_1024_1518_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET           (0x017C)
+#define EMAC_1519_TO_MAX_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x0180)
+#define EMAC_UNDERSIZE_FRAMES_RX_REG_OFFSET                         (0x0184)
+#define EMAC_OVERSIZE_FRAMES_RX_REG_OFFSET                          (0x0188)
+#define EMAC_JABBER_FRAMES_RX_REG_OFFSET                            (0x018C)
+#define EMAC_FCS_ERRORS_REG_OFFSET                                  (0x0190)
+#define EMAC_LENGTH_FIELD_FRAME_ERRORS_REG_OFFSET                   (0x0194)
+#define EMAC_RX_SYMBOL_ERRORS_REG_OFFSET                            (0x0198)
+#define EMAC_ALLIGNMENT_ERRORS_REG_OFFSET                           (0x019C)
+#define EMAC_RX_RESOURCE_ERRORS_REG_OFFSET                          (0x01A0)
+#define EMAC_RX_OVERRUN_ERRORS_REG_OFFSET                           (0x01A4)
+#define EMAC_IP_HDR_CHECKSUM_ERRORS_REG_OFFSET                      (0x01A8)
+#define EMAC_TCP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01AC)
+#define EMAC_UDP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01B0)
+
+#define EMAC_1588_TIMERS_SECONDS_REG_OFFSET                         (0x01D0)
+#define EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET                     (0x01D4)
+#define EMAC_1588_TIMER_ADJUST_REG_OFFSET                           (0x01D8)
+#define EMAC_1588_TIMER_INCREMENT_REG_OFFSET                        (0x01DC)
+
+#define EMAC_PTP_EVENT_FRAME_TX_SECONDS_REG_OFFSET                  (0x01E0)
+#define EMAC_PTP_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET             (0x01E4)
+#define EMAC_PTP_EVENT_FRAME_RX_SECONDS_REG_OFFSET                  (0x01E8)
+#define EMAC_PTP_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET             (0x01EC)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_SECONDS_REG_OFFSET             (0x01F0)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET        (0x01F4)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_SECONDS_REG_OFFSET             (0x01F8)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET        (0x01FC)
+
+#define EMAC_PCS_CTRL_REG_OFFSET                                    (0x0200)
+#define EMAC_PCS_STATUS_REG_OFFSET                                  (0x0204)
+#define EMAC_PCS_UPPER_PHY_ID_REG_OFFSET                            (0x0208)
+#define EMAC_PCS_LOWER_PHY_ID_REG_OFFSET                            (0x020C)
+#define EMAC_PCS_AUTO_NEG_ADVERT_REG_OFFSET                         (0x0210)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_AB_REG_OFFSET                (0x0214)
+#define EMAC_PCS_AUTO_NEG_EXPANSION_REG_OFFSET                      (0x0218)
+#define EMAC_PCS_AUTO_NEG_NEXT_PAGE_REG_OFFSET                      (0x021C)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_NEXT_PAGE_REG_OFFSET         (0x0220)
+#define EMAC_PCS_EXTENDED_STATUS_REG_OFFSET                         (0x023C)
+
+/* EMAC_NETWORK_CTRL_REG_OFFSET bits */
+#define EMAC_TRANSMIT_HALT                                          (((unsigned int)1) << 10)
+#define EMAC_START_TX                                               (((unsigned int)1) << 9)
+#define EMAC_CLEAR_STATS_REGISTERS                                  (((unsigned int)1) << 5)
+#define EMAC_MDIO_ENABLE                                            (((unsigned int)1) << 4)
+#define EMAC_TX_ENABLE                                              (((unsigned int)1) << 3)
+#define EMAC_RX_ENABLE                                              (((unsigned int)1) << 2)
+
+/* EMAC_NETWORK_CFG_REG_OFFSET bits */
+#define EMAC_64_BIT_AMBA_DATA_BUS_WITDH                             (((unsigned int)1) << 21)
+#define EMAC_MDC_CLOCK_DIV_MASK                                     (0x7 << 18)
+#define EMAC_MDC_CLOCK_DIV_96                                       (0x5 << 18)
+#define EMAC_FCS_REMOVE                                             (((unsigned int)1) << 17)
+#define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (((unsigned int)1) << 16)
+#define EMAC_FULL_DUPLEX                                            (((unsigned int)1) << 1)
+#define EMAC_SPEED_100_MBPS                                         (((unsigned int)1) << 0)
+
+/* EMAC_NETWORK_STATUS_REG_OFFSET bits */
+#define EMAC_PHY_MANAGEMENT_IDLE                                    (((unsigned int)1) << 2)
+
+/* EMAC_DMA_CFG_REG_OFFSET bits */
+#define EMAC_DMA_RX_BUFFER_SIZE_IDX                                 (16)
+#define EMAC_DMA_RX_BUFFER_SIZE_MASK                                (0xFF << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+#define EMAC_DMA_RX_BUFFER_SIZE                                     (0x18 << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+
+/* EMAC_PHY_MAINTAIN_REG_OFFSET bits */
+#define EMAC_PHY_ID_MASK                                            (0x1F)
+#define EMAC_PHY_ID_SHIFT                                           (23)
+#define EMAC_PHY_REG_MASK                                           (0x1F)
+#define EMAC_PHY_REG_SHIFT                                          (18)
+#define EMAC_PHY_DATA_MASK                                          (0xFFFF)
+
+/* EMAC_TX_STATUS_REG_OFFSET bits */
+#define EMAC_TRANSMIT_COMPLETE                                      (((unsigned int)1) << 5)
+#define EMAC_TRANSMIT_GO                                            (((unsigned int)1) << 3)
+
+/* Rx Descriptor Bits */
+#define EMAC_RX_DESC_WRAP                                           (((unsigned int)1) << 1)
+#define EMAC_RX_DESC_HOST_OWN                                       (((unsigned int)1) << 0)
+
+#define EMAC_RX_DESC_END_OF_FRAME                                   (((unsigned int)1) << 15)
+#define EMAC_RX_DESC_START_OF_FRAME                                 (((unsigned int)1) << 14)
+#define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
+
+/* Tx Descriptor Bits */
+#define EMAC_TX_DESC_HOST_OWN                                       (((unsigned int)1) << 31)
+#define EMAC_TX_DESC_WRAP                                           (((unsigned int)1) << 30)
+#define EMAC_TX_RETRY_ERROR                                         (((unsigned int)1) << 29)
+#define EMAC_TX_UNDERRUN_ERROR                                      (((unsigned int)1) << 28)
+#define EMAC_TX_FRAME_CORRUPTION_ERROR                              (((unsigned int)1) << 27)
+#define EMAC_TX_LATE_COLLISION_ERROR                                (((unsigned int)1) << 26)
+#define EMAC_TX_NO_CRC_APPEND                                       (((unsigned int)1) << 16)
+#define EMAC_TX_LAST_BUFFER                                         (((unsigned int)1) << 15)
+#define EMAC_TX_BUFFER_LENGTH_MASK                                  (0x3FFF)
+
+#endif /* __PC3XX_EMAC_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/fuse.h b/arch/arm/include/asm/arch-pc3xx/fuse.h
new file mode 100644
index 0000000..30f0bad
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/fuse.h
@@ -0,0 +1,76 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file fuse.h
+* \brief Definitions for the PC3xx Fuse Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef __PC3XX_FUSE_H__
+#define __PC3XX_FUSE_H__
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define FUSE_MAP_0_REG_OFFSET           (0x00)
+#define FUSE_MAP_1_REG_OFFSET           (0x04)
+#define FUSE_MAP_2_REG_OFFSET           (0x08)
+#define FUSE_MAP_3_REG_OFFSET           (0x0C)
+
+#define FUSE_MAP_4_REG_OFFSET           (0x10)
+#define FUSE_MAP_5_REG_OFFSET           (0x14)
+#define FUSE_MAP_6_REG_OFFSET           (0x18)
+#define FUSE_MAP_7_REG_OFFSET           (0x1C)
+
+#define FUSE_MAP_8_REG_OFFSET           (0x20)
+#define FUSE_MAP_9_REG_OFFSET           (0x24)
+#define FUSE_MAP_10_REG_OFFSET          (0x28)
+#define FUSE_MAP_11_REG_OFFSET          (0x2C)
+
+#define FUSE_MAP_12_REG_OFFSET          (0x30)
+#define FUSE_MAP_13_REG_OFFSET          (0x34)
+#define FUSE_MAP_14_REG_OFFSET          (0x38)
+#define FUSE_MAP_15_REG_OFFSET          (0x3C)
+
+#define FUSE_MAP_16_REG_OFFSET          (0x40)
+#define FUSE_MAP_17_REG_OFFSET          (0x44)
+#define FUSE_MAP_18_REG_OFFSET          (0x48)
+#define FUSE_MAP_19_REG_OFFSET          (0x4C)
+
+#define FUSE_MAP_20_REG_OFFSET          (0x50)
+#define FUSE_MAP_21_REG_OFFSET          (0x54)
+#define FUSE_MAP_22_REG_OFFSET          (0x58)
+#define FUSE_MAP_23_REG_OFFSET          (0x5C)
+
+#define FUSE_MAP_24_REG_OFFSET          (0x60)
+#define FUSE_MAP_25_REG_OFFSET          (0x64)
+#define FUSE_MAP_26_REG_OFFSET          (0x68)
+#define FUSE_MAP_27_REG_OFFSET          (0x6C)
+
+#define FUSE_MAP_28_REG_OFFSET          (0x70)
+#define FUSE_MAP_29_REG_OFFSET          (0x74)
+#define FUSE_MAP_30_REG_OFFSET          (0x78)
+#define FUSE_MAP_31_REG_OFFSET          (0x7C)
+
+#define FUSE_CONTROL_REG_OFFSET         (0x80)
+#define FUSE_WRITE_BIT_ADDR_REG_OFFSET  (0x84)
+#define FUSE_WRITE_PERFORM              (0x88)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define FUSE_WRITE_FUSE_ENABLE          (0x66757365)
+
+#endif /* __PC3XX_FUSE_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/gpio.h b/arch/arm/include/asm/arch-pc3xx/gpio.h
new file mode 100644
index 0000000..e7ab91a
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/gpio.h
@@ -0,0 +1,74 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file gpio.h
+* \brief Definitions for the PC3xx GPIO Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_GPIO_H__
+#define __PC3XX_GPIO_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define GPIO_SW_PORT_A_DR_REG_OFFSET        (0x00)
+#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    (0x04)
+#define GPIO_SW_PORT_A_CTL_REG_OFFSET       (0x08)
+#define GPIO_SW_PORT_B_DR_REG_OFFSET        (0x0C)
+#define GPIO_SW_PORT_B_DDR_REG_OFFSET	    (0x10)
+#define GPIO_SW_PORT_B_CTL_REG_OFFSET       (0x14)
+#define GPIO_SW_PORT_C_DR_REG_OFFSET        (0x18)
+#define GPIO_SW_PORT_C_DDR_REG_OFFSET	    (0x1C)
+#define GPIO_SW_PORT_C_CTL_REG_OFFSET       (0x20)
+#define GPIO_SW_PORT_D_DR_REG_OFFSET        (0x24)
+#define GPIO_SW_PORT_D_DDR_REG_OFFSET	    (0x28)
+#define GPIO_SW_PORT_D_CTL_REG_OFFSET       (0x2C)
+
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_OFFSET              (0x30)
+#define GPIO_INT_MASK_REG_OFFSET            (0x34)
+#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    (0x38)
+#define GPIO_INT_POLARITY_REG_OFFSET 	    (0x3c)
+
+#define GPIO_INT_STATUS_REG_OFFSET	    (0x40)
+#define GPIO_RAW_INT_STATUS_REG_OFFSET	    (0x44)
+
+/* no debounce */
+#define GPIO_PORT_A_EOI_REG_OFFSET          (0x4c)
+#define GPIO_EXT_PORT_A_REG_OFFSET          (0x50)
+#define GPIO_EXT_PORT_B_REG_OFFSET          (0x54)
+#define GPIO_EXT_PORT_C_REG_OFFSET          (0x58)
+#define GPIO_EXT_PORT_D_REG_OFFSET          (0x5C)
+
+#define GPIO_LS_SYNC_REG_OFFSET		    (0x60)
+#define GPIO_ID_CODE_REG_OFFSET		    (0x64)
+#define GPIO_RESERVED_REG_OFFSET            (0x68)
+#define GPIO_COMP_VERSION_REG_OFFSET	    (0x6c)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Useful bit definitions */
+#define GPIO_BIT_7  (0x80)
+#define GPIO_BIT_6  (0x40)
+#define GPIO_BIT_5  (0x20)
+#define GPIO_BIT_4  (0x10)
+#define GPIO_BIT_3  (0x08)
+#define GPIO_BIT_2  (0x04)
+#define GPIO_BIT_1  (0x02)
+#define GPIO_BIT_0  (0x01)
+
+#endif /* __PC3XX_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mem_arm.h b/arch/arm/include/asm/arch-pc3xx/mem_arm.h
new file mode 100644
index 0000000..5c61cf5
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/mem_arm.h
@@ -0,0 +1,129 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mem_arm.h
+* \brief Definitions for the PC3xx Memif-ARM Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_MEM_ARM_H__
+#define __PC3XX_MEM_ARM_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define MEMIF_ARM_INDIRECT_RW_CMD_OFFSET    (0x00 * 4)
+#define MEMIF_ARM_RSVD_0_OFFSET             (0x01 * 4)
+#define MEMIF_ARM_HPR_OFFSET                (0x02 * 4)
+#define MEMIF_ARM_LPR_OFFSET                (0x03 * 4)
+#define MEMIF_ARM_WR_OFFSET                 (0x04 * 4)
+#define MEMIF_ARM_DRAM_PARAM_0_OFFSET       (0x05 * 4)
+#define MEMIF_ARM_DRAM_PARAM_1_OFFSET       (0x06 * 4)
+#define MEMIF_ARM_DRAM_PARAM_2_OFFSET       (0x07 * 4)
+#define MEMIF_ARM_DRAM_PARAM_3_OFFSET       (0x08 * 4)
+#define MEMIF_ARM_DRAM_PARAM_4_OFFSET       (0x09 * 4)
+#define MEMIF_ARM_DRAM_INIT_PARAM_OFFSET    (0x0A * 4)
+#define MEMIF_ARM_DRAM_EMR2_EMR3_OFFSET     (0x0B * 4)
+#define MEMIF_ARM_DRAM_EMR_MR_OFFSET        (0x0C * 4)
+#define MEMIF_ARM_DRAM_BL_OFFSET            (0x0D * 4)
+#define MEMIF_ARM_DRAM_FORCE_LPR_OFFSET     (0x0E * 4)
+#define MEMIF_ARM_ADDR_MAP_0_OFFSET         (0x0F * 4)
+#define MEMIF_ARM_ADDR_MAP_1_OFFSET         (0x10 * 4)
+#define MEMIF_ARM_ADDR_MAP_2_OFFSET         (0x11 * 4)
+#define MEMIF_ARM_DRAM_ODT_OFFSET           (0x12 * 4)
+#define MEMIF_ARM_PHY_DEBUG_0_OFFSET        (0x13 * 4)
+#define MEMIF_ARM_PHY_CMD_RDC_OFFSET        (0x14 * 4)
+#define MEMIF_ARM_CTRL_MODE_OFFSET          (0x15 * 4)
+#define MEMIF_ARM_DLL_CALIB_OFFSET          (0x16 * 4)
+#define MEMIF_ARM_ODT_CTRL_OFFSET           (0x17 * 4)
+#define MEMIF_ARM_DDRC_CTRL_0_OFFSET        (0x18 * 4)
+#define MEMIF_ARM_DDRC_CTRL_1_OFFSET        (0x19 * 4)
+#define MEMIF_ARM_PHY_SLV_DLL_OFFSET        (0x1A * 4)
+#define MEMIF_ARM_PHY_DEBUG_1_OFFSET        (0x1B * 4)
+#define MEMIF_ARM_PHY_DEBUG_2_OFFSET        (0x1C * 4)
+#define MEMIF_ARM_PHY_DEBUG_3_OFFSET        (0x1D * 4)
+#define MEMIF_ARM_PHY_DEBUG_4_OFFSET        (0x1E * 4)
+#define MEMIF_ARM_PHY_LOCAL_ODT_OFFSET      (0x1F * 4)
+#define MEMIF_ARM_GP0_OFFSET                (0x20 * 4)
+#define MEMIF_ARM_GP1_OFFSET                (0x21 * 4)
+#define MEMIF_ARM_GP2_OFFSET                (0x22 * 4)
+#define MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET \
+        (MEMIF_ARM_GP2_OFFSET)
+#define MEMIF_ARM_GP3_OFFSET                (0x23 * 4)
+#define MEMIF_ARM_GP4_OFFSET                (0x24 * 4)
+
+#define MEMIF_ARM_AXI_HP_MSTR_0_OFFSET      (0x3A * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_1_OFFSET      (0x3B * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_2_OFFSET      (0x3C * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_3_OFFSET      (0x3D * 4)
+#define MEMIF_ARM_AXI_START_ADDR_OFFSET     (0x3E * 4)
+#define MEMIF_ARM_AXI_END_ADDR_OFFSET       (0x3F * 4)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+/* Set up values for a single 512Mbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_512Mbx16   (0x00000F77)  /* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_512Mbx16   (0xFFF00000)  /* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_512Mbx16   (0x0FF22222)  /* row */
+
+/* Set up values for a single 1Gbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16     (0x00000777)  /* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16     (0xFFF00000)  /* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16     (0x0FF33333)  /* row */
+
+#define MEMIF_ARM_DRAM_EMR_MR_VAL           (0x00000A63)
+
+/* final wait after ddr initialisation sequence is 8 cycles */
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX     (0)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK     (0x3F)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL     (0x8)
+
+/* pre cke assertion delay must be 200us */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX   (14)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL   (0x50)
+
+/* post cke assertion is 400ns */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX   (22)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL   (0x2)
+
+/*****************************************************************************/
+/* Base Addresses                                                            */
+/*****************************************************************************/
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [1:0]  = axaddr[12:11] */
+/* row  [12:0] = axaddr[25:13] */
+#define BANK0_BASE_512Mbx16                 (0x00000000)
+#define BANK1_BASE_512Mbx16                 (0x00000800)
+#define BANK2_BASE_512Mbx16                 (0x00001000)
+#define BANK3_BASE_512Mbx16                 (0x00001800)
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [2:0]  = axaddr[13:11] */
+/* row  [13:0] = axaddr[27:14] */
+#define BANK0_BASE_1Gbx8                    (0x00000000)
+#define BANK1_BASE_1Gbx8                    (0x00000800)
+#define BANK2_BASE_1Gbx8                    (0x00001000)
+#define BANK3_BASE_1Gbx8                    (0x00001800)
+#define BANK4_BASE_1Gbx8                    (0x00002000)
+#define BANK5_BASE_1Gbx8                    (0x00002800)
+#define BANK6_BASE_1Gbx8                    (0x00003000)
+#define BANK7_BASE_1Gbx8                    (0x00003800)
+
+#endif /* __PC3XX_MEM_ARM_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mem_shd.h b/arch/arm/include/asm/arch-pc3xx/mem_shd.h
new file mode 100644
index 0000000..80e3f10
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/mem_shd.h
@@ -0,0 +1,395 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mem_shd.h
+* \brief Definitions for the PC3xx Memif-Shared Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_MEM_SHD_H__
+#define __PC3XX_MEM_SHD_H__
+
+/* Includes ---------------------------------------------------------------- */
+#include "pa.h"
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define ADDR_PA_BUF0_SETUP                  (0x0000)
+#define ADDR_PA_BUF0_ADDR                   (0x0001)
+#define ADDR_PA_BUF1_SETUP                  (0x0002)
+#define ADDR_PA_BUF1_ADDR                   (0x0003)
+#define ADDR_PA_BUF2_SETUP                  (0x0004)
+#define ADDR_PA_BUF2_ADDR                   (0x0005)
+#define ADDR_PA_BUF3_SETUP                  (0x0006)
+#define ADDR_PA_BUF3_ADDR                   (0x0007)
+#define ADDR_PA_BUF4_SETUP                  (0x0008)
+#define ADDR_PA_BUF4_ADDR                   (0x0009)
+#define ADDR_PA_BUF5_SETUP                  (0x000A)
+#define ADDR_PA_BUF5_ADDR                   (0x000B)
+#define ADDR_PA_BUF6_SETUP                  (0x000C)
+#define ADDR_PA_BUF6_ADDR                   (0x000D)
+#define ADDR_PA_BUF7_SETUP                  (0x000E)
+#define ADDR_PA_BUF7_ADDR                   (0x000F)
+#define ADDR_PA_BUF8_SETUP                  (0x0010)
+#define ADDR_PA_BUF8_ADDR                   (0x0011)
+#define ADDR_PA_BUF9_SETUP                  (0x0012)
+#define ADDR_PA_BUF9_ADDR                   (0x0013)
+#define ADDR_SDRAM_ARB_G0_S0_S1             (0x0020)
+#define ADDR_SDRAM_ARB_G0_S2_S3             (0x0021)
+#define ADDR_SDRAM_ARB_G1_S0_S1             (0x0022)
+#define ADDR_SDRAM_ARB_G1_S2_S3             (0x0023)
+#define ADDR_SDRAM_ARB_G2_S0_S1             (0x0024)
+#define ADDR_SDRAM_ARB_G2_S2_S3             (0x0025)
+#define ADDR_SDRAM_ARB_G3_S0_S1             (0x0026)
+#define ADDR_SDRAM_ARB_G3_S2_S3             (0x0027)
+#define ADDR_SDRAM_ARB_G4_S0_S1             (0x0028)
+#define ADDR_SDRAM_ARB_G4_S2_S3             (0x0029)
+#define ADDR_SDRAM_ARB_G5_S0_S1             (0x002A)
+#define ADDR_SDRAM_ARB_G5_S2_S3             (0x002B)
+#define ADDR_SDRAM_ARB_G6_S0_S1             (0x002C)
+#define ADDR_SDRAM_ARB_G6_S2_S3             (0x002D)
+#define ADDR_SDRAM_ARB_G7_S0_S1             (0x002E)
+#define ADDR_SDRAM_ARB_G7_S2_S3             (0x002F)
+#define ADDR_SDRAM_VALID_GROUPS             (0x0030)
+#define ADDR_SRAM_ARB_S0_S1                 (0x0040)
+#define ADDR_SRAM_ARB_S2_S3                 (0x0041)
+#define ADDR_SRAM_ARB_S4_S5                 (0x0042)
+#define ADDR_SRAM_VALID_SLOTS               (0x0043)
+#define ADDR_ARB_UPDATE                     (0x004F)
+#define ADDR_SDRAM_SETUP                    (0x0050)
+#define ADDR_SDRAM_REFRESH                  (0x0051)
+#define ADDR_SDRAM_MRS                      (0x0052)
+#define ADDR_SDRAM_EMRS                     (0x0053)
+#define ADDR_SDRAM_EMRS2                    (0x0054)
+#define ADDR_SDRAM_EMRS3                    (0x0055)
+#define ADDR_SDRAM_ODT_SETUP                (0x0056)
+#define ADDR_SDRAM_CFG_DONE                 (0x0057)
+#define ADDR_SDRAM_AXI_CONFIG               (0x0058)
+#define ADDR_SDRAM_DEBUG                    (0x0059)
+#define ADDR_SDRAM_STATUS                   (0x005A)
+#define ADDR_PHY_TEST                       (0x0060)
+#define ADDR_PHY_CONFIG                     (0x0061)
+#define ADDR_PHY_LOCAL_ODT_CONFIG           (0x0062)
+#define ADDR_PHY_RDC_FIFO_RST_ERR_CNT       (0x0063)
+#define ADDR_PHY_WR_SLAVE                   (0x0064)
+#define ADDR_PHY_RD_SLAVE                   (0x0065)
+#define ADDR_PHY_DEBUG_WR_DLL0              (0x0066)
+#define ADDR_PHY_DEBUG_RC_DLL0              (0x0068)
+#define ADDR_PHY_DEBUG_RC_DLL1              (0x0069)
+#define ADDR_PHY_IO_CELL_CONFIG             (0x006A)
+#define ADDR_PHY_DEBUG_STATUS_BC            (0x0070)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_0      (0x0071)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_1      (0x0072)
+#define ADDR_PHY_DEBUG_STATUS_MASTER_DLL_0  (0x0073)
+#define ADDR_PHY_DEBUG_STATUS_OF_IN_DELAY_0 (0x0075)
+#define ADDR_PHY_DEBUG_STATUS_OF_OUT_DELAY_0    (0x0076)
+#define ADDR_PA_FIFO_STATUS_LWR             (0x0080)
+#define ADDR_PA_FIFO_STATUS_UPR             (0x0081)
+#define ADDR_PA_ADDR_ERR_LWR                (0x0082)
+#define ADDR_PA_ADDR_ERR_UPR                (0x0083)
+#define ADDR_PA_ADDR_ERR_MASK_LWR           (0x0084)
+#define ADDR_PA_ADDR_ERR_MASK_UPR           (0x0085)
+
+#define CBFM_SLEEPREG_ADDR                  (0xA060)
+#define CBFM_RUNREG_ADDR                    (0xA061)
+#define CBFM_ERRREG_ADDR                    (0xA062)
+#define CBFM_RESETREG_ADDR                  (0xA063)
+#define CBFM_IDREG_ADDR                     (0xA064)
+#define CBFM_RSTRUNMASK_ADDR                (0xA065)
+#define CBFM_BISTEN_ADDR                    (0xA066)
+#define CBFM_BISTDATA_ADDR                  (0xA067)
+#define CBFM_TM_ADDR                        (0xA068)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+#define DDR2_ROW_13_COL_9               (0x2)
+#define DDR2_ROW_13_COL_10              (0x1)
+#define DDR2_ROW_14_COL_10              (0x0)
+#define DDR2_8_BANKS                    (0x1)
+#define DDR2_4_BANKS                    (0x0)
+#define DDR2_BRC_ADDR                   (0x0)
+#define DDR2_RBC_ADDR                   (0x1)
+#define DDR2_RW_GAP                     (0x3)
+#define DDR2_WR_GAP                     (0xa)
+#define DDR2_CAS_4                      (0x4)
+#define DDR2_CAS_5                      (0x5)
+#define DDR2_CAS_6                      (0x6)
+#define DDR2_CAS_7                      (0x7)
+#define DDR2_REFRESH_TIME               (0x07d0)
+#define DDR2_BURST_SEQUENTIAL           (0x0000)
+#define DDR2_WR                         (0x05)
+#define DDR2_DQSN_DISABLE               (0x1)
+
+#define SDRAM_ARB_AXI_SLOT              (0)
+#define SDRAM_ARB_PA_SLOT               (1)
+#define SDRAM_ARB_DET_SLOT              (0)
+#define SDRAM_ARB_OPP_SLOT              (1)
+#define SDRAM_ARB_RD_SLOT               (0)
+#define SDRAM_ARB_WR_SLOT               (1)
+#define SDRAM_ARB_CSP_1_SLOT            (0)
+#define SDRAM_ARB_CSP_2_SLOT            (1)
+#define SDRAM_ARB_CSP_4_SLOT            (2)
+#define SDRAM_ARB_CSP_8_SLOT            (3)
+
+#define SDRAM_ARB_1_VALID_SLOT          (1)
+#define SDRAM_ARB_2_VALID_SLOT          (3)
+#define SDRAM_ARB_3_VALID_SLOT          (7)
+#define SDRAM_ARB_4_VALID_SLOT          (15)
+#define SDRAM_ARB_5_VALID_SLOT          (31)
+#define SDRAM_ARB_6_VALID_SLOT          (63)
+#define SDRAM_ARB_7_VALID_SLOT          (127)
+#define SDRAM_ARB_8_VALID_SLOT          (255)
+
+#define PHY_CONFIG_BL_4                 (2)
+#define PHY_CONFIG_BL_8                 (3)
+#define PHY_CONFIG_RDC_WE_TO_RE_2       (2)
+#define PHY_CONFIG_FIXED_RE             (1)
+
+#define ADDR_SDRAM_STATUS_INIT_DONE_BIT     (0)
+#define ADDR_SDRAM_STATUS_IN_RESET_BIT      (1)
+#define ADDR_SDRAM_STATUS_IN_STB_CLK_BIT    (2)
+#define ADDR_SDRAM_STATUS_IN_INIT_BIT       (3)
+#define ADDR_SDRAM_STATUS_IN_ARB_BIT        (4)
+#define ADDR_SDRAM_STATUS_IN_REF_BIT        (5)
+#define ADDR_SDRAM_STATUS_IN_UPDATE_BIT     (6)
+#define ADDR_SDRAM_STATUS_IN_RW_GAP_BIT     (7)
+#define ADDR_SDRAM_STATUS_IN_WR_GAP_BIT     (8)
+
+#define SDRAM_SETUP_SIZE_IDX            (0)
+#define SDRAM_SETUP_BANK_IDX            (2)
+#define SDRAM_SETUP_RW_GAP_IDX          (3)
+#define SDRAM_SETUP_WR_GAP_IDX          (7)
+#define SDRAM_SETUP_CAS_IDX             (11)
+
+#define SDRAM_AXI_SETUP_RBC_IDX         (0)
+#define SDRAM_AXI_SETUP_SIZE_IDX        (1)
+#define SDRAM_AXI_SETUP_BANK_IDX        (3)
+
+#define SDRAM_ARB_S0_AP_IDX             (0)
+#define SDRAM_ARB_S0_APOD_IDX           (1)
+#define SDRAM_ARB_S0_RW_IDX             (2)
+#define SDRAM_ARB_S0_RWOD_IDX           (3)
+#define SDRAM_ARB_S0_CSP_IDX            (4)
+
+#define SDRAM_ARB_S1_AP_IDX             (8)
+#define SDRAM_ARB_S1_APOD_IDX           (9)
+#define SDRAM_ARB_S1_RW_IDX             (10)
+#define SDRAM_ARB_S1_RWOD_IDX           (11)
+#define SDRAM_ARB_S1_CSP_IDX            (12)
+
+#define SDRAM_ARB_S2_AP_IDX             (0)
+#define SDRAM_ARB_S2_APOD_IDX           (1)
+#define SDRAM_ARB_S2_RW_IDX             (2)
+#define SDRAM_ARB_S2_RWOD_IDX           (3)
+#define SDRAM_ARB_S2_CSP_IDX            (4)
+
+#define SDRAM_ARB_S3_AP_IDX             (8)
+#define SDRAM_ARB_S3_APOD_IDX           (9)
+#define SDRAM_ARB_S3_RW_IDX             (10)
+#define SDRAM_ARB_S3_RWOD_IDX           (11)
+#define SDRAM_ARB_S3_CSP_IDX            (12)
+
+#define PHY_CONFIG_FIRST_RD_IDX         (0)
+#define PHY_CONFIG_FIRST_WR_IDX         (4)
+#define PHY_CONFIG_BL_IDX               (8)
+#define PHY_CONFIG_RDC_WE_TO_RE_IDX     (11)
+#define PHY_CONFIG_FIXED_RE_IDX         (13)
+
+#define MRS_PHY_CONFIG_BL_IDX           (0)
+#define MRS_DDR2_BURST_SEQUENTIAL_IDX   (3)
+#define MRS_DDR2_CAS_IDX                (4)
+#define MRS_DDR2_WR_IDX                 (9)
+
+#define EMRS_ODT_LOW_BIT_IDX            (2)
+#define EMRS_ODT_HIGH_BIT_IDX           (6)
+#define EMRS_DQSN_DISABLE_IDX           (10)
+
+/*****************************************************************************/
+/* Used to create a 'load file' for the pA                                   */
+/*****************************************************************************/
+
+#define LF_PA_AEID_MEMIF                (PA_AEID_MEMIF | PA_CONFIG_AEID)
+
+#define LF_CBFM_SLEEPREG_ADDR           (CBFM_SLEEPREG_ADDR | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S0_S1      (ADDR_SDRAM_ARB_G0_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S2_S3      (ADDR_SDRAM_ARB_G0_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S0_S1      (ADDR_SDRAM_ARB_G1_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S2_S3      (ADDR_SDRAM_ARB_G1_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_VALID_GROUPS      (ADDR_SDRAM_VALID_GROUPS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_SETUP             (ADDR_SDRAM_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_REFRESH           (ADDR_SDRAM_REFRESH | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ODT_SETUP         (ADDR_SDRAM_ODT_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_AXI_CONFIG        (ADDR_SDRAM_AXI_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_MRS               (ADDR_SDRAM_MRS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_EMRS              (ADDR_SDRAM_EMRS | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_CONFIG              (ADDR_PHY_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_LOCAL_ODT_CONFIG    (ADDR_PHY_LOCAL_ODT_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_RD_SLAVE            (ADDR_PHY_RD_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_WR_SLAVE            (ADDR_PHY_WR_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_IO_CELL_CONFIG      (ADDR_PHY_IO_CELL_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_CFG_DONE          (ADDR_SDRAM_CFG_DONE | PA_CONFIG_ADDR)
+
+#define ADDR_SDRAM_ARB_G0_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G0_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_VALID_GROUPS_DATA    (0x00000000 | PA_CONFIG_WRITE | SDRAM_ARB_2_VALID_SLOT)
+
+#define ADDR_SDRAM_SETUP_DATA           (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_SETUP_SIZE_IDX)     | \
+                                        (DDR2_8_BANKS       << SDRAM_SETUP_BANK_IDX)     | \
+                                        (DDR2_RW_GAP        << SDRAM_SETUP_RW_GAP_IDX)   | \
+                                        (DDR2_WR_GAP        << SDRAM_SETUP_WR_GAP_IDX)   | \
+                                        (DDR2_CAS_6         << SDRAM_SETUP_CAS_IDX))
+
+#define ADDR_SDRAM_REFRESH_DATA         (0x00000000 | PA_CONFIG_WRITE | DDR2_REFRESH_TIME)
+
+#define ADDR_SDRAM_AXI_CONFIG_DATA      (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_BRC_ADDR      << SDRAM_AXI_SETUP_RBC_IDX)   | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_AXI_SETUP_SIZE_IDX)  | \
+                                        (DDR2_8_BANKS       << SDRAM_AXI_SETUP_BANK_IDX))
+
+#define ADDR_SDRAM_MRS_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_CONFIG_BL_4        << MRS_PHY_CONFIG_BL_IDX) | \
+                                        (DDR2_BURST_SEQUENTIAL  << MRS_DDR2_BURST_SEQUENTIAL_IDX) | \
+                                        (DDR2_CAS_6             << MRS_DDR2_CAS_IDX) | \
+                                        (DDR2_WR                << MRS_DDR2_WR_IDX))
+
+#define SDRAM_ODT_75_OHM_LO             (0x1)
+#define SDRAM_ODT_75_OHM_HI             (0x0)
+
+#define ADDR_SDRAM_EMRS_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_75_OHM_LO        << EMRS_ODT_LOW_BIT_IDX) | \
+                                        (SDRAM_ODT_75_OHM_HI        << EMRS_ODT_HIGH_BIT_IDX) | \
+                                        (DDR2_DQSN_DISABLE << EMRS_DQSN_DISABLE_IDX))
+
+#define ADDR_PHY_CONFIG_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_CAS_6                 << PHY_CONFIG_FIRST_RD_IDX) | \
+                                        ((DDR2_CAS_6 - 1)           << PHY_CONFIG_FIRST_WR_IDX) | \
+                                        (PHY_CONFIG_BL_4            << PHY_CONFIG_BL_IDX)       | \
+                                        (PHY_CONFIG_RDC_WE_TO_RE_2  << PHY_CONFIG_RDC_WE_TO_RE_IDX) | \
+                                        (PHY_CONFIG_FIXED_RE        << PHY_CONFIG_FIXED_RE_IDX))
+
+#define SDRAM_ODT_ENABLE_IDX            (0)
+#define SDRAM_ODT_ON_DELAY_IDX          (1)
+#define SDRAM_ODT_ON_DURN_IDX           (4)
+#define SDRAM_ODT_ENABLE                (0x1)
+#define SDRAM_ODT_ON_DURN               (0x2)
+
+#define ADDR_SDRAM_ODT_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_ENABLE   << SDRAM_ODT_ENABLE_IDX) | \
+                                        ((DDR2_CAS_6 - 4)   << SDRAM_ODT_ON_DELAY_IDX) | \
+                                        (SDRAM_ODT_ON_DURN  << SDRAM_ODT_ON_DURN_IDX))
+
+#define PHY_LOCAL_ODT_75_OHM            (0x1)
+#define PHY_LOCAL_ODT_OFF               (0x0)
+#define PHY_LOCAL_ODT_READ_IDX          (0)
+#define PHY_LOCAL_ODT_WRITE_IDX         (2)
+#define PHY_LOCAL_ODT_IDLE_IDX          (4)
+
+#define ADDR_PHY_LOCAL_ODT_CONFIG_DATA  (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM   << PHY_LOCAL_ODT_READ_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_WRITE_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_IDLE_IDX))
+
+#define PHY_RD0_DLL_SLAVE_DELAY         (0x30)
+#define PHY_RD1_DLL_SLAVE_DELAY         (0x30)
+#define PHY_WR_DLL_SLAVE_DELAY          (0x40)
+
+#define PHY_RD0_DLL_SLAVE_IDX           (0)
+#define PHY_RD1_DLL_SLAVE_IDX           (8)
+#define PHY_WR_DLL_SLAVE_IDX            (0)
+
+
+#define ADDR_PHY_RD_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_RD0_DLL_SLAVE_DELAY << PHY_RD0_DLL_SLAVE_IDX) | \
+                                        (PHY_RD1_DLL_SLAVE_DELAY << PHY_RD1_DLL_SLAVE_IDX))
+
+#define ADDR_PHY_WR_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_WR_DLL_SLAVE_DELAY << PHY_WR_DLL_SLAVE_IDX))
+
+
+#define PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX   (4)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF              (1)
+#define PHY_DATA_DRV_STRENGTH_HALF              (1)
+#define PHY_CLK_DRV_STRENGTH_HALF               (1)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF           (1)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF_IDX          (0)
+#define PHY_DATA_DRV_STRENGTH_HALF_IDX          (1)
+#define PHY_CLK_DRV_STRENGTH_HALF_IDX           (2)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX       (3)
+
+
+#define ADDR_PHY_IO_CELL_CONFIG_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM           << PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX) | \
+                                        (PHY_FIFO_WE_DRV_STRENGTH_HALF  << PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CLK_DRV_STRENGTH_HALF      << PHY_CLK_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_DATA_DRV_STRENGTH_HALF     << PHY_DATA_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CTRL_DRV_STRENGTH_HALF     << PHY_CTRL_DRV_STRENGTH_HALF_IDX))
+
+#define ADDR_SDRAM_CFG_DONE_DATA        (0x0001 | PA_CONFIG_WRITE)
+
+#define PA_WRITE_ZERO_DATA              (PA_CONFIG_WRITE)
+
+#endif /* __PC3XX_MEM_SHD_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mux.h b/arch/arm/include/asm/arch-pc3xx/mux.h
new file mode 100644
index 0000000..736093c
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/mux.h
@@ -0,0 +1,53 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mux.h
+* \brief Definitions for the PC3xx gpio muxing
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_MUX_H__
+#define __PC3XX_MUX_H__
+
+/* stringify used in mux.c */
+#define __stringify_1(x...)     #x
+#define __stringify(x...)       __stringify_1(x)
+
+/*
+ * Pins can typically be:
+ *	- a system function such as EBI, SSI etc,
+ *	- ARM controlled GPIO.
+ *	- picoArray controlled GPIO.
+ *	- not multiplexed at all (MUX_UNMUXED).
+ */
+enum mux_setting {
+	MUX_PERIPHERAL	= (1 << 0),
+	MUX_ARM		= (1 << 1),
+	MUX_SD		= (1 << 2),
+	MUX_UNMUXED	= (1 << 3),
+};
+
+int
+pc3xx_pin_set_mux(int pin_nr,
+		  enum mux_setting setting);
+
+int
+pc3xx_group_set_mux(const char *group_name,
+		    enum mux_setting setting);
+
+int
+pc3xx_get_pin_mux(int pin_nr);
+
+void
+pc3xx_muxing_init(void);
+
+#endif /* __PC3XX_MUX_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pa.h b/arch/arm/include/asm/arch-pc3xx/pa.h
new file mode 100644
index 0000000..2e8e240
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/pa.h
@@ -0,0 +1,40 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file pa.h
+* \brief Definitions for the picoArray.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_PA_H__
+#define __PC3XX_PA_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/* Broadcast Id for memif-Shared */
+#define PA_BROADCAST_ID_MEMIF   (0x8020)
+
+/* The memif-Shared aeid changed from PC3x2 devices to PC3x3 devices,
+ * to avoid lots of code changes we just use the memif-Shared
+ * broadcast address instead.
+ */
+#define PA_AEID_MEMIF       (PA_BROADCAST_ID_MEMIF)
+
+#define PA_CONFIG_WRITE     (0x00010000)
+#define PA_CONFIG_READ      (0x00020000)
+#define PA_CONFIG_ADDR      (0x00040000)
+#define PA_CONFIG_AEID      (0x00080000)
+#define PA_CONFIG_VALID     (0x00010000)
+#define PA_CONFIG_FAIL      (0x00020000)
+#define PA_CONFIG_TIMEOUT   (0x00040000)
+
+#endif /* __PC3XX_PA_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pc302.h b/arch/arm/include/asm/arch-pc3xx/pc302.h
new file mode 100644
index 0000000..49934af
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/pc302.h
@@ -0,0 +1,92 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file pc302.h
+* \brief Definitions for the PC3xx ARM sub-system.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_H__
+#define __PC3XX_H__
+
+/*****************************************************************************/
+/* Internal Boot ROM                                                         */
+/*****************************************************************************/
+#define PC302_BOOT_ROM_BASE         (0xFFFF0000)
+
+/*****************************************************************************/
+/* AXI2PICO Buffers                                                          */
+/*****************************************************************************/
+#define PC302_AXI2PICO_BUFFERS_BASE (0xC0000000)
+
+/*****************************************************************************/
+/* Peripheral Bus                                                            */
+/*****************************************************************************/
+#define PC302_MEMIF_BASE            (0x80000000)
+#define PC302_EBI_BASE              (0x80010000)
+#define PC302_EMAC_BASE             (0x80030000)
+#define PC302_DMAC1_BASE            (0x80040000)
+#define PC302_DMAC2_BASE            (0x80050000)
+#define PC302_VIC0_BASE             (0x80060000)
+#define PC302_VIC1_BASE             (0x80064000)
+#define PC302_TZIC_BASE             (0x80068000)
+#define PC302_TZPC_BASE             (0x80070000)
+#define PC302_FUSE_BASE             (0x80080000)
+#define PC302_SSI_BASE              (0x80090000)
+#define PC302_AXI2CFG_BASE          (0x800A0000)
+#define PC302_IPSEC_BASE            (0x80100000)
+#define PC302_SRTP_BASE             (0x80140000)
+#define PC302_CIPHER_BASE           (0x80180000)
+#define PC302_RTCLK_BASE            (0x80200000)
+#define PC302_TIMER_BASE            (0x80210000)
+#define PC302_GPIO_BASE             (0x80220000)
+#define PC302_UART1_BASE            (0x80230000)
+#define PC302_UART2_BASE            (0x80240000)
+#define PC302_WDOG_BASE             (0x80250000)
+
+/*****************************************************************************/
+/* External Memory                                                           */
+/*****************************************************************************/
+#define PC302_DDRBANK_BASE          (0x00000000)
+
+#define PC302_EBI_CS0_BASE          (0x40000000)
+#define PC302_EBI_CS1_BASE          (0x48000000)
+#define PC302_EBI_CS2_BASE          (0x50000000)
+#define PC302_EBI_CS3_BASE          (0x58000000)
+
+#define PC302_FLASH_BASE            (PC302_EBI_CS0_BASE)
+#define PC302_FLASH_START           (PC302_EBI_CS0_BASE)
+#define PC302_FLASH_SIZE            (0x08000000)
+
+/*****************************************************************************/
+/* Internal SRAM Memory                                                      */
+/*****************************************************************************/
+#define PC302_SRAM_BASE             (0x20000000)
+#define PC302_SRAM_START            (0x20000000)
+#define PC302_SRAM_SIZE             (0x00020000)
+
+/*****************************************************************************/
+/* Silicon Revision                                                          */
+/*****************************************************************************/
+#define PC3X2_REV_A                 (0)
+#define PC3X2_REV_D                 (1)
+
+/*****************************************************************************/
+/* Device Ids                                                                */
+/*****************************************************************************/
+#define PC302_DEVICE_ID             (0x03)
+#define PC312_DEVICE_ID             (0x07)
+#define PC313_DEVICE_ID             (0x20)
+#define PC323_DEVICE_ID             (0x21)
+#define PC333_DEVICE_ID             (0x22)
+
+#endif /* __PC3XX_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h b/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
new file mode 100644
index 0000000..2bea499
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
@@ -0,0 +1,214 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file pc3xxgpio.h
+* \brief Definitions for use with the PC3xx gpio library
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __MACH_GPIO_H__
+#define __MACH_GPIO_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/* Use on PC3x2 devices */
+enum {
+	PC302_GPIO_PIN_ARM_0 =  0,  /* ARM GPIO pin identifiers. */
+	PC302_GPIO_PIN_ARM_1,
+	PC302_GPIO_PIN_ARM_2,
+	PC302_GPIO_PIN_ARM_3,
+	PC302_GPIO_PIN_ARM_4,
+	PC302_GPIO_PIN_ARM_5,
+	PC302_GPIO_PIN_ARM_6,
+	PC302_GPIO_PIN_ARM_7,
+	PC302_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
+	PC302_GPIO_PIN_SDGPIO_1,
+	PC302_GPIO_PIN_SDGPIO_2,
+	PC302_GPIO_PIN_SDGPIO_3,
+	PC302_GPIO_PIN_SDGPIO_4,
+	PC302_GPIO_PIN_SDGPIO_5,
+	PC302_GPIO_PIN_SDGPIO_6,
+	PC302_GPIO_PIN_SDGPIO_7,
+	PC302_GPIO_PIN_ARM_8,      /* ARM shared pins. */
+	PC302_GPIO_PIN_ARM_9,
+	PC302_GPIO_PIN_ARM_10,
+	PC302_GPIO_PIN_ARM_11,
+	PC302_GPIO_PIN_ARM_12,
+	PC302_GPIO_PIN_ARM_13,
+	PC302_GPIO_PIN_ARM_14,
+	PC302_GPIO_PIN_ARM_15,
+	PC302_GPIO_PIN_SDGPIO_8,  /* SDGPIO shared pins. */
+	PC302_GPIO_PIN_SDGPIO_9,
+	PC302_GPIO_PIN_SDGPIO_10,
+	PC302_GPIO_PIN_SDGPIO_11,
+	PC302_GPIO_PIN_SDGPIO_12,
+	PC302_GPIO_PIN_SDGPIO_13,
+	PC302_GPIO_PIN_SDGPIO_14,
+	PC302_GPIO_PIN_SDGPIO_15,
+};
+
+/* Use on PC3x3 devices */
+enum {
+	PC3X3_GPIO_PIN_ARM_0,
+	PC3X3_GPIO_PIN_ARM_1,
+	PC3X3_GPIO_PIN_ARM_2,
+	PC3X3_GPIO_PIN_ARM_3,
+	PC3X3_GPIO_PIN_ARM_4,
+	PC3X3_GPIO_PIN_ARM_5,
+	PC3X3_GPIO_PIN_ARM_6,
+	PC3X3_GPIO_PIN_ARM_7,
+	PC3X3_GPIO_PIN_ARM_8,
+	PC3X3_GPIO_PIN_ARM_9,
+	PC3X3_GPIO_PIN_ARM_10,
+	PC3X3_GPIO_PIN_ARM_11,
+	PC3X3_GPIO_PIN_ARM_12,
+	PC3X3_GPIO_PIN_ARM_13,
+	PC3X3_GPIO_PIN_ARM_14,
+	PC3X3_GPIO_PIN_ARM_15,
+	PC3X3_GPIO_PIN_ARM_16,
+	PC3X3_GPIO_PIN_ARM_17,
+	PC3X3_GPIO_PIN_ARM_18,
+	PC3X3_GPIO_PIN_ARM_19,
+	PC3X3_GPIO_PIN_ARM_20,
+	PC3X3_GPIO_PIN_ARM_21,
+	PC3X3_GPIO_PIN_ARM_22,
+	PC3X3_GPIO_PIN_ARM_23,
+	PC3X3_GPIO_PIN_ARM_24,
+	PC3X3_GPIO_PIN_ARM_25,
+	PC3X3_GPIO_PIN_ARM_26,
+	PC3X3_GPIO_PIN_ARM_27,
+	PC3X3_GPIO_PIN_ARM_28,
+	PC3X3_GPIO_PIN_ARM_29,
+	PC3X3_GPIO_PIN_ARM_30,
+	PC3X3_GPIO_PIN_ARM_31,
+	PC3X3_GPIO_PIN_ARM_32,
+	PC3X3_GPIO_PIN_ARM_33,
+	PC3X3_GPIO_PIN_ARM_34,
+	PC3X3_GPIO_PIN_ARM_35,
+	PC3X3_GPIO_PIN_ARM_36,
+	PC3X3_GPIO_PIN_ARM_37,
+	PC3X3_GPIO_PIN_ARM_38,
+	PC3X3_GPIO_PIN_ARM_39,
+	PC3X3_GPIO_PIN_ARM_40,
+	PC3X3_GPIO_PIN_ARM_41,
+	PC3X3_GPIO_PIN_ARM_42,
+	PC3X3_GPIO_PIN_ARM_43,
+	PC3X3_GPIO_PIN_ARM_44,
+	PC3X3_GPIO_PIN_ARM_45,
+	PC3X3_GPIO_PIN_ARM_46,
+	PC3X3_GPIO_PIN_ARM_47,
+	PC3X3_GPIO_PIN_ARM_48,
+	PC3X3_GPIO_PIN_ARM_49,
+	PC3X3_GPIO_PIN_ARM_50,
+	PC3X3_GPIO_PIN_ARM_51,
+	PC3X3_GPIO_PIN_ARM_52,
+	PC3X3_GPIO_PIN_ARM_53,
+	PC3X3_GPIO_PIN_SDGPIO_0,
+	PC3X3_GPIO_PIN_SDGPIO_1,
+	PC3X3_GPIO_PIN_SDGPIO_2,
+	PC3X3_GPIO_PIN_SDGPIO_3,
+	PC3X3_GPIO_PIN_SDGPIO_4,
+	PC3X3_GPIO_PIN_SDGPIO_5,
+	PC3X3_GPIO_PIN_SDGPIO_6,
+	PC3X3_GPIO_PIN_SDGPIO_7,
+	PC3X3_GPIO_PIN_SDGPIO_8,
+	PC3X3_GPIO_PIN_SDGPIO_9,
+	PC3X3_GPIO_PIN_SDGPIO_10,
+	PC3X3_GPIO_PIN_SDGPIO_11,
+	PC3X3_GPIO_PIN_SDGPIO_12,
+	PC3X3_GPIO_PIN_SDGPIO_13,
+	PC3X3_GPIO_PIN_SDGPIO_14,
+	PC3X3_GPIO_PIN_SDGPIO_15,
+	PC3X3_GPIO_PIN_SDGPIO_16,
+	PC3X3_GPIO_PIN_SDGPIO_17,
+	PC3X3_GPIO_PIN_SDGPIO_18,
+	PC3X3_GPIO_PIN_SDGPIO_19,
+	PC3X3_GPIO_PIN_SDGPIO_20,
+	PC3X3_GPIO_PIN_SDGPIO_21,
+	PC3X3_GPIO_PIN_SDGPIO_22,
+	PC3X3_GPIO_PIN_SDGPIO_23,
+};
+
+/* Prototypes--------------------------------------------------------------- */
+/**
+ * Initialise the gpio library for use
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc3xx_gpio_init(void);
+
+/**
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * \param gpio The pin to request.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc3xx_gpio_request(unsigned gpio);
+
+/**
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * \param gpio The GPIO pin to free.
+ */
+void
+pc3xx_gpio_free(unsigned gpio);
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc3xx_gpio_direction_input(unsigned gpio);
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * output.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \param value The initial output value for the gpio pin.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int
+pc3xx_gpio_direction_output(unsigned gpio,
+                            int value);
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value The value to set the pin to.
+ */
+void
+pc3xx_gpio_set_value(unsigned gpio,
+                     int value);
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+int
+pc3xx_gpio_get_value(unsigned gpio);
+
+int
+pc3xx_gpio_configure_dac(unsigned gpio,
+                         u8 converter_size,
+                         u16 analogue_rate);
+
+#endif /* __MACH_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/spi.h b/arch/arm/include/asm/arch-pc3xx/spi.h
new file mode 100644
index 0000000..5e18879
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/spi.h
@@ -0,0 +1,98 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file spi.h
+* \brief Definitions for the PC3xx SSI Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_SSI_H__
+#define __PC3XX_SSI_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define SSI_CTRL_REG_0_REG_OFFSET                   (0x00)
+#define SSI_CTRL_REG_1_REG_OFFSET                   (0x04)
+#define SSI_ENABLE_REG_REG_OFFSET                   (0x08)
+#define SSI_MW_CTRL_REG_OFFSET                      (0x0C)
+#define SSI_SLAVE_ENABLE_REG_OFFSET                 (0x10)
+#define SSI_BAUD_RATE_SEL_REG_OFFSET                (0x14)
+#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            (0x18)
+#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            (0x1C)
+#define SSI_TX_FIFO_LEVEL_REG_OFFSET                (0x20)
+#define SSI_RX_FIFO_LEVEL_REG_OFFSET                (0x24)
+#define SSI_STATUS_REG_OFFSET                       (0x28)
+#define SSI_IMR_REG_OFFSET                          (0x2C)
+#define SSI_ISR_REG_OFFSET                          (0x30)
+#define SSI_RAW_ISR_REG_OFFSET                      (0x34)
+#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x38)
+#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x3C)
+#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_OFFSET    (0x40)
+#define SSI_MM_INT_CLEAR_REG_OFFSET                 (0x44)
+#define SSI_INT_CLEAR_REG_OFFSET                    (0x48)
+#define SSI_DMA_CTRL_REG_OFFSET                     (0x4C)
+#define SSI_DMA_TX_DATA_LEVEL_REG_OFFSET            (0x50)
+#define SSI_DMA_RX_DATA_LEVEL_REG_OFFSET            (0x54)
+#define SSI_DATA_REG_OFFSET                         (0x60)
+
+/* Identification Registers */
+
+#define SSI_ID_REG_OFFSET                           (0x58)
+#define SSI_COMP_VERSION_REG_OFFSET                 (0x5C)
+
+/* Types ------------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+#define PC302_MAX_NUMBER_SPI_CS     (4)
+#define PC302_MAX_NUMBER_SPI_BUSSES (1)
+#define PC302_MIN_SPI_CLK_DIVIDER   (2)
+#define PC302_MAX_SPI_CLK_DIVIDER   (65534)
+
+/* SSI_CTRL_REG_0_REG_OFFSET bites */
+#define PC302_SPI_LOOPBACK_MODE     (1 << 11)
+#define PC302_SPI_NORMAL_MODE       (0)
+#define PC302_SPI_TMOD_TX_RX        (0x0)
+#define PC302_SPI_TMOD_TX           (0x1 << 8)
+#define PC302_SPI_TMOD_RX           (0x2 << 8)
+#define PC302_SPI_TMOD_EEPROM_RX    (0x3 << 8)
+#define PC302_SPI_SCPOL             (1 << 7)
+#define PC302_SPI_SCPH              (1 << 6)
+#define PC302_SPI_MOTO_FORMAT       (0x0)
+#define PC302_SPI_DATA_FRM_8_BIT    (0x7)
+
+
+/* SSI_ENABLE_REG_REG_OFFSET bits */
+#define PC302_SPI_ENABLE            (1)
+#define PC302_SPI_DISABLE           (0)
+
+/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
+#define PC302_SPI_SLAVES_DISABLE    (0)
+
+/* SSI_STATUS_REG_OFFSET bits */
+#define PC302_SPI_STATUS_DCOL       (1 << 6)
+#define PC302_SPI_STATUS_TXE        (1 << 5)
+#define PC302_SPI_STATUS_RFF        (1 << 4)
+#define PC302_SPI_STATUS_RFNE       (1 << 3)
+#define PC302_SPI_STATUS_TFE        (1 << 2)
+#define PC302_SPI_STATUS_TFNF       (1 << 1)
+#define PC302_SPI_STATUS_BUSY       (1 << 0)
+
+/* SSI_IMR_REG_RESET bits */
+#define PC302_SPI_MASK_ALL_INTS     (0xFFFF)
+
+#endif /* __PC302_SSI_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/timer.h b/arch/arm/include/asm/arch-pc3xx/timer.h
new file mode 100644
index 0000000..5cb5094
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/timer.h
@@ -0,0 +1,85 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file timer.h
+* \brief Definitions for the PC3xx Timer Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_TIMER_H__
+#define __PC3XX_TIMER_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Individual definitions */
+#define TIMER1_LOAD_COUNT_REG_OFFSET        (0x00)
+#define TIMER1_CURRENT_VALUE_REG_OFFSET     (0x04)
+#define TIMER1_CONTROL_REG_OFFSET           (0x08)
+#define TIMER1_EOI_REG_OFFSET               (0x0c)
+#define TIMER1_INT_STATUS_REG_OFFSET        (0x10)
+
+#define TIMER2_LOAD_COUNT_REG_OFFSET        (0x14)
+#define TIMER2_CURRENT_VALUE_REG_OFFSET     (0x18)
+#define TIMER2_CONTROL_REG_OFFSET           (0x1c)
+#define TIMER2_EOI_REG_OFFSET               (0x20)
+#define TIMER2_INT_STATUS_REG_OFFSET        (0x24)
+
+#define TIMER3_LOAD_COUNT_REG_OFFSET        (0x28)
+#define TIMER3_CURRENT_VALUE_REG_OFFSET     (0x2c)
+#define TIMER3_CONTROL_REG_OFFSET           (0x30)
+#define TIMER3_EOI_REG_OFFSET               (0x34)
+#define TIMER3_INT_STATUS_REG_OFFSET        (0x38)
+
+#define TIMER4_LOAD_COUNT_REG_OFFSET        (0x3c)
+#define TIMER4_CURRENT_VALUE_REG_OFFSET     (0x40)
+#define TIMER4_CONTROL_REG_OFFSET           (0x44)
+#define TIMER4_EOI_REG_OFFSET               (0x48)
+#define TIMER4_INT_STATUS_REG_OFFSET        (0x4c)
+
+#define TIMERS_INT_STATUS_REG_OFFSET        (0xa0)
+#define TIMERS_EOI_REG_OFFSET               (0xa4)
+#define TIMERS_RAW_INT_STATUS_REG_OFFSET    (0xa8)
+#define TIMERS_COMP_VERSION_REG_OFFSET      (0xac)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Generic definitions 'borrowed' from U-Boot land */
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TIMERNUMBEROFTIMERS                 (4)
+
+/* Register definitions for the timers */
+#define TIMERNLOADCOUNTREGOFFSET(__N)       (0x0000 + (0x14 * (__N)))
+#define TIMERNCURRENTVALUEREGOFFSET(__N)    (0x0004 + (0x14 * (__N)))
+#define TIMERNCONTROLREGOFFSET(__N)         (0x0008 + (0x14 * (__N)))
+#define TIMERNEOIREGOFFSET(__N)             (0x000c + (0x14 * (__N)))
+#define TIMERNINTERRUPTSTATUSREGOFFSET(__N) (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TIMERENABLE                         (0x00000001)
+#define TIMERMODE                           (0x00000002)
+#define TIMERINTERRUPTMASK                  (0x00000004)
+
+
+/* Register definitions for global timer registers */
+#define TIMERSINTERRUPTSTATUSREGOFFSET      (0x00a0)
+#define TIMERSEOIREGOFFSET                  (0x00a4)
+#define TIMERSRAWINTERRUPTSTATUSREGOFFSET   (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define TIMER(__N)                          (0x00000001 << (__N))
+
+#endif /* __PC3XX_TIMER_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/uart.h b/arch/arm/include/asm/arch-pc3xx/uart.h
new file mode 100644
index 0000000..2730160
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/uart.h
@@ -0,0 +1,158 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file uart.h
+* \brief Definitions for the PC3xx UART Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_UART_H__
+#define __PC3XX_UART_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define UART_RX_BUFFER_REG_OFFSET               (0x00)
+#define UART_TX_HOLDING_REG_OFFSET		(0x00)
+#define UART_DIVISOR_LOW_REG_OFFSET		(0x00)
+#define UART_DIVISOR_HIGH_REG_OFFSET		(0x04)
+#define UART_INT_ENABLE_REG_OFFSET		(0x04)
+#define UART_INT_IDENTITY_REG_OFFSET		(0x08)
+#define UART_FIFO_CTRL_REG_OFFSET		(0x08)
+#define UART_LINE_CTRL_REG_OFFSET		(0x0c)
+#define UART_MODEM_CTRL_REG_OFFSET		(0x10)
+#define UART_LINE_STATUS_REG_OFFSET		(0x14)
+#define UART_MODEM_STATUS_REG_OFFSET		(0x18)
+#define UART_SCRATCH_REG_OFFSET			(0x1c)
+
+#define UART_UART_STATUS_REG_OFFSET             (0x7c)
+
+#define UART_SHADOW_RTS_REG_OFFSET		(0x8c)
+#define UART_SHADOW_BRK_CTRL_REG_OFFSET		(0x90)
+#define UART_SHADOW_DMA_MODE_REG_OFFSET		(0x94)
+#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET	(0x98)
+#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET	(0x9c)
+#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET	(0xa0)
+#define UART_HALT_TX_REG_OFFSET			(0xa4)
+#define UART_DMA_SOFT_ACK_REG_OFFSET		(0xa8)
+#define UART_COMP_PARAM_REG_OFFSET		(0xf4)
+#define UART_UART_VERSION_REG_OFFSET		(0xf8)
+#define UART_COMP_TYPE_REG_OFFSET		(0xfc)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* DLL & DLH */
+#define UART_DIVISOR_MASK               (0xFF)
+
+/* IER */
+#define UART_INT_ENABLE_PTIME_IDX	(0x7)	/* Programmable THRE Interrupt Mode Enable that can be */
+						/*  written to only when THRE_MODE_USER == Enabled, */
+						/*  always readable. This is used to enable/disable the */
+						/*  generation of THRE Interrupt. */
+#define UART_INT_ENABLE_EDSSI_IDX       (0x3)   /*  R/W Enable Modem Status Interrupt. */
+#define UART_INT_ENABLE_ELSI_IDX        (0x2)   /*  R/W Enable Receiver Line Status Interrupt. */
+#define UART_INT_ENABLE_ETBEI_IDX       (0x1)   /*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UART_INT_ENABLE_ERBFI_IDX       (0x0)   /*  R/W Enable Received Data Available Interrupt. */
+
+#define UART_INT_ENABLE_PTIME_MASK          (1 << UART_INT_ENABLE_PTIME_IDX)
+#define UART_INT_ENABLE_EDSSI_MASK          (1 << UART_INT_ENABLE_EDSSI_IDX)
+#define UART_INT_ENABLE_ELSI_MASK           (1 << UART_INT_ENABLE_ELSI_IDX)
+#define UART_INT_ENABLE_ETBEI_MASK          (1 << UART_INT_ENABLE_ETBEI_IDX)
+#define UART_INT_ENABLE_ERBFI_MASK          (1 << UART_INT_ENABLE_ERBFI_IDX)
+
+/* IIR */
+#define UART_INT_IDENTITY_MASK	            (0x0F)
+#define UART_INT_IDENTITY_MODEM_STATUS      (0x00)
+#define UART_INT_IDENTITY_NONE	            (0x01)
+#define UART_INT_IDENTITY_THR_EMPTY	    (0x02)
+#define UART_INT_IDENTITY_RX_DATA	    (0x04)
+#define UART_INT_IDENTITY_RX_LINE_STATUS    (0x06)
+#define UART_INT_IDENTITY_BUSY_DETECT       (0x07)
+#define UART_INT_IDENTITY_CHARACTER_TIMEOUT (0x0C)
+
+/* FCR */
+#define UART_FIFO_CTRL_RCVR_MASK	        (0xC0)
+#define UART_FIFO_CTRL_RCVR1_CHAR	        (0x00)  /* 00 = 1 character in the FIFO */
+#define UART_FIFO_CTRL_RCVR_QUARTER_FULL        (0x40)  /* 01 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_HALF_FULL           (0x80)  /* 10 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_2_LESS_THAN_FULL    (0xC0)  /* 11 = FIFO 2 less than full */
+
+#define UART_FIFO_CTRL_TX_EMPTY_MASK	        (0x30)
+#define UART_FIFO_CTRL_TX_EMPTY_EMPTY           (0x00)  /* 00 = FIFO empty */
+#define UART_FIFO_CTRL_TX_EMPTY_2_CHARS         (0x10)  /* 01 = 2 characters in the FIFO */
+#define UART_FIFO_CTRL_TX_EMPTY_QUARTER_FULL    (0x20)  /* 10 = FIFO  full */
+#define UART_FIFO_CTRL_TX_EMPTY_HALF_FULL       (0x30)  /* 11 = FIFO  full */
+
+#define UART_FIFO_CTRL_ENABLE		        (0x01)	/* fifo enable bit */
+
+
+/* LCR indices */
+#define UART_LINE_CTRL_DLAB_IDX                 (7)     /* Divisor latch access bit */
+#define UART_LINE_CTRL_BRK_IDX                  (6)
+#define UART_LINE_CTRL_EPS_IDX                  (4)
+#define UART_LINE_CTRL_PEN_IDX                  (3)
+#define UART_LINE_CTRL_STOP_IDX                 (2)
+#define UART_LINE_CTRL_DLS_IDX                  (0)
+
+/* LCR bit masks */
+#define UART_LINE_CTRL_DLAB_MASK	        (1 << UART_LINE_CTRL_DLAB_IDX)
+#define UART_LINE_CTRL_BRK_MASK	                (1 << UART_LINE_CTRL_BRK_IDX)
+#define UART_LINE_CTRL_EPS_MASK	                (1 << UART_LINE_CTRL_EPS_IDX)
+#define UART_LINE_CTRL_PEN_MASK	                (1 << UART_LINE_CTRL_PEN_IDX)
+#define UART_LINE_CTRL_STOP_MASK                (1 << UART_LINE_CTRL_STOP_IDX)
+#define UART_LINE_CTRL_DLS_MASK	                (3)
+#define UART_LINE_CTRL_DLS_8BITS	        (3)     /* 8 bit data length */
+#define UART_LINE_CTRL_DLS_7BITS	        (2)     /* 7 bit data length */
+#define UART_LINE_CTRL_DLS_6BITS	        (1)     /* 6 bit data length */
+#define UART_LINE_CTRL_DLS_5BITS	        (0)     /* 5 bit data length */
+
+#define UART_LINE_CTRL_1STOP_BIT                (~(UART_LINE_CTRL_STOP_MASK))
+#define UART_LINE_CTRL_PARITY_DISABLE           (~(UART_LINE_CTRL_PEN_MASK))
+
+/* MCR indices */
+#define UART_MODEM_CTRL_LOOPBACK_IDX            (4)
+#define UART_MODEM_CTRL_OUT2_IDX		(3)
+#define UART_MODEM_CTRL_OUT1_IDX		(2)
+#define UART_MODEM_CTRL_CTS_IDX		        (1)
+#define UART_MODEM_CTRL_DTR_IDX		        (0)
+
+/* MCR bit masks */
+#define UART_MODEM_CTRL_LOOPBACK_MASK	        (1 << UART_MODEM_CTRL_LOOPBACK_IDX)
+#define UART_MODEM_CTRL_OUT2_MASK		(1 << UART_MODEM_CTRL_OUT2_IDX)
+#define UART_MODEM_CTRL_OUT1_MASK		(1 << UART_MODEM_CTRL_OUT1_IDX)
+#define UART_MODEM_CTRL_CTS_MASK		(1 << UART_MODEM_CTRL_CTS_IDX)
+#define UART_MODEM_CTRL_DTR_MASK		(1 << UART_MODEM_CTRL_DTR_IDX)
+
+#define UART_MODEM_STATUS_CTS_IDX               (4)     /* CTS input */
+#define UART_MODEM_STATUS_DCTS_IDX              (0)     /* change in CTS input since last read */
+
+#define UART_LINE_STATUS_THRE_IDX	        (5)
+#define UART_LINE_STATUS_DATA_READY_IDX         (0)
+#define UART_LINE_STATUS_THRE_MASK	        (1 << UART_LINE_STATUS_THRE_IDX)
+#define UART_LINE_STATUS_DATA_READY_MASK        (1 << UART_LINE_STATUS_DATA_READY_IDX)
+
+#define UART_UART_STATUS_RFF_IDX                (4)     /* RX FIFO full */
+#define UART_UART_STATUS_RFNE_IDX	        (3)     /* RX FIFO not empty */
+#define UART_UART_STATUS_TFE_IDX	        (2)
+#define UART_UART_STATUS_TFNF_IDX	        (1)
+#define UART_UART_STATUS_BUSY_IDX	        (0)
+
+#define UART_UART_STATUS_RFF_MASK               (1 << UART_UART_STATUS_RFF_IDX)
+#define UART_UART_STATUS_RFNE_MASK              (1 << UART_UART_STATUS_RFNE_IDX)
+#define UART_UART_STATUS_TFE_MASK               (1 << UART_UART_STATUS_TFE_IDX)
+#define UART_UART_STATUS_TFNF_MASK              (1 << UART_UART_STATUS_TFNF_IDX)
+#define UART_UART_STATUS_BUSY_MASK              (1 << UART_UART_STATUS_BUSY_IDX)
+
+#endif /* __PC3XX_UART_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/utilities.h b/arch/arm/include/asm/arch-pc3xx/utilities.h
new file mode 100644
index 0000000..f95a2a2
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/utilities.h
@@ -0,0 +1,133 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file utilities.h
+* \brief Definitions for some useful PC3xx functions.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef __PC3XX_UTILS_H__
+#define __PC3XX_UTILS_H__
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ * \brief Read a 32 bit value from a register.
+ *
+ * \param The address to read from
+ * \return The value read
+ */
+__inline unsigned int
+pc302_read_from_register (const unsigned int address);
+
+/*!
+ * \brief Write a 32 bit value to a register
+ *
+ * \param The address to write to
+ * \param The value to write.
+ */
+__inline void
+pc302_write_to_register (const unsigned int address,
+                         const unsigned int value);
+
+/*!
+ * \brief Read the device identification code from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int
+pc302_read_device_id (void);
+
+/*!
+ * \brief Read the device revision from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int
+pc302_read_device_revision (void);
+
+/*!
+ * \brief Read the die id number from the fuse block
+ *
+ * \param die_number Pointer to an array
+ */
+void
+pc302_read_die_id_number (unsigned int * die_number);
+
+/*!
+ * \brief Return the state of the Reduced MII enabled bit.
+ *
+ * \return 0 - RMII not enabled
+ *         1 - RMII enabled
+ */
+unsigned int
+pc302_get_rmii_enabled (void);
+
+/*!
+ * \brief Read a number of 16 bit words from the PC3xx axi2cfg.
+ *
+ * \param caeid The CAEID of the AE to read from.
+ * \param address The start address in the AE to begin reading from.
+ * \param[out] data The buffer to store the data in.
+ * \param count The number of 16 bit words to read.
+ * \return Returns the number of words read on success, negative on failure.
+ */
+int
+axi2cfg_config_read( u16 caeid,
+                     u16 address,
+                     u16 *data,
+                     u16 count );
+
+/*!
+ * \brief Write a number of 16 bit words to the PC3xx axi2cfg.
+ *
+ * \param caeid The CAEID of the AE to write to.
+ * \param address The start address in the AE to begin writing to.
+ * \param[in] data The buffer to write from.
+ * \param count The number of 16 bit words to write.
+ * \return Returns the number of words written on success, negative on failure.
+ */
+int
+axi2cfg_config_write( u16 caeid,
+                      u16 address,
+                      u16 *data,
+                      u16 count );
+
+/*!
+ * \brief Read the system configuration register.
+ *
+ * \return Returns the value of the system configuration register.
+ */
+u32
+syscfg_read(void);
+
+/*!
+ * \brief Update the system configuration register.
+ *
+ * \param mask Mask of the bits to update.
+ * \param val The value to write.
+ */
+void
+syscfg_update(u32 mask,
+              u32 val);
+
+/*!
+ * \brief Are we running on a PC3x3 ?
+ *
+ * \return 1 if running on a PC3x3 device
+ *         0 if not running on a PC3x3 device
+ */
+__inline int
+is_pc3x3(void);
+
+#endif /* __PC3XX_UTILS_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/wdog.h b/arch/arm/include/asm/arch-pc3xx/wdog.h
new file mode 100644
index 0000000..105a903
--- /dev/null
+++ b/arch/arm/include/asm/arch-pc3xx/wdog.h
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file wdog.h
+* \brief Definitions for the PC3xx WDOG Block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PC3XX_WDOG_H__
+#define __PC3XX_WDOG_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define WDOG_CONTROL_REG_OFFSET             (0x00)
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET       (0x04)
+#define WDOG_CURRENT_COUNT_REG_OFFSET       (0x08)
+#define WDOG_COUNTER_RESTART_REG_OFFSET     (0x0c)
+#define WDOG_INT_STATUS_REG_OFFSET          (0x10)
+#define WDOG_CLEAR_REG_OFFSET               (0x14)
+
+#define WDOG_PARAMS_5_REG_OFFSET            (0xe4)
+#define WDOG_PARAMS_4_REG_OFFSET            (0xe8)
+#define WDOG_PARAMS_3_REG_OFFSET            (0xec)
+#define WDOG_PARAMS_2_REG_OFFSET            (0xf0)
+#define WDOG_PARAMS_1_REG_OFFSET            (0xf4)
+
+#define WDOG_COMP_VERSION_REG_OFFSET        (0xf8)
+#define WDOG_COMP_TYPE_REG_OFFSET           (0xfc)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+/* Kick value */
+#define WDOG_COUNTER_RESTART_KICK_VALUE	    (0x76)
+
+/* Control bits */
+#define WDOGCONTROLREGWDT_ENIDX		    (0)
+#define WDOGCONTROLREGRMODIDX		    (1)
+#define WDOGCONTROLREGRPLIDX		    (2)
+
+/* Masks */
+#define WDOGCONTROLREGWDT_ENMASK	    (1 << WDOGCONTROLREGWDT_ENIDX)
+#define WDOGCONTROLREGRMODMASK		    (1 << WDOGCONTROLREGRMODIDX)
+#define WDOGCONTROLREGRPLMASK		    (0x7 << WDOGCONTROLREGRPLIDX)
+
+#endif /* __PC3XX_WDOG_H__ */
diff --git a/board/picochip/pc7302/Makefile b/board/picochip/pc7302/Makefile
new file mode 100644
index 0000000..e8a6f06
--- /dev/null
+++ b/board/picochip/pc7302/Makefile
@@ -0,0 +1,47 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2011 Picochip Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+SOBJS-y := lowlevel_init.o
+
+COBJS-y	:= pc7302.o
+COBJS-y += mt29f2g08aadwp.o
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS    := $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/picochip/pc7302/config.mk b/board/picochip/pc7302/config.mk
new file mode 100644
index 0000000..13cef69
--- /dev/null
+++ b/board/picochip/pc7302/config.mk
@@ -0,0 +1,26 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file config.mk
+#* \brief Used during the build process.
+#*
+#* Copyright (c) 2006-2011 Picochip Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+PLATFORM_CPPFLAGS += -DPICOCHIP_PLATFORM_VERSION=\"$(DISTRO_VERSION)\"
+
+ifeq ($(PC7302_RUN_FROM_RAM), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_RUN_FROM_RAM
+endif
+
+ifeq ($(PC7302_UBIFS), Y)
+PLATFORM_CPPFLAGS += -DCONFIG_USE_UBIFS
+endif
diff --git a/board/picochip/pc7302/lowlevel_init.S b/board/picochip/pc7302/lowlevel_init.S
new file mode 100644
index 0000000..ab2352d
--- /dev/null
+++ b/board/picochip/pc7302/lowlevel_init.S
@@ -0,0 +1,426 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file lowlevel_init.S
+* \brief Various low level setup functions.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/pc302.h>
+#include <asm/arch/mem_arm.h>
+#include <asm/arch/mem_shd.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/pa.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Macros ------------------------------------------------------------------ */
+/* This gives us a peripheral bus base address of 0x80000000
+   and a memory region size of 4Mbytes */
+#define PERIPHERAL_BUS_SETUP        0x8000000D
+
+#define ASSERT_BOOT_ERROR_PIN       0
+#define NEGATE_BOOT_ERROR_PIN       1
+#define BOOT_ERROR_PIN_IS_OUTPUT    1
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+
+/*****************************************************************************
+ *
+ * configWriteLoadFile
+ *
+ *****************************************************************************/
+.macro  configWriteLoadFile Reg0, Reg1, Reg2, Reg3, Reg4, lfbase, lfwords
+
+        ADR     \Reg0,\lfbase
+        LDR     \Reg1,=PC302_AXI2CFG_BASE
+        LDR     \Reg2,=\lfwords
+0:
+        LDR     \Reg3, [\Reg0],#0x4
+        STR     \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        SUBS    \Reg2, \Reg2, #1
+        BNE     0b
+.endm
+
+/*****************************************************************************
+ *
+ * configRead
+ *
+ *****************************************************************************/
+.macro  configRead Reg0, Reg1, Reg2, aeid, addr
+
+        LDR     \Reg0,=PC302_AXI2CFG_BASE
+
+        /* aeid */
+        LDR     \Reg1,=\aeid
+        ORR     \Reg1,\Reg1,#PA_CONFIG_AEID
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* addr */
+        LDR     \Reg1,=\addr
+        ORR     \Reg1,\Reg1,#PA_CONFIG_ADDR
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+
+        /* data */
+        MOV     \Reg1,#PA_CONFIG_READ
+        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        MOV     \Reg2,#0x20
+
+        /* read */
+0:
+        LDR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
+        TST     \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
+        BNE     1f
+        SUBS    \Reg2,\Reg2,#1
+        BNE     0b
+        MOV     \Reg1, #PA_CONFIG_TIMEOUT
+1:
+        MOV     \Reg0, \Reg1
+
+.endm
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * lowlevel_init
+ *
+ * Description: Perform some low level PC302 initialisation
+ *
+ *****************************************************************************/
+ .global lowlevel_init
+
+ lowlevel_init:
+
+        /* Setup the Periheral Port Memory Remap Register */
+        LDR     r0, =PERIPHERAL_BUS_SETUP
+        MCR     p15, 0, r0, c15, c2, 4
+
+        /* Now we need to remap the flash memory otherwsie we'll not be
+         * able to talk to sdram later on.
+         */
+        orr     pc, pc, #PC302_BOOTABLE_FLASH_BASE
+        nop
+        nop
+
+        /* We are now executing code from the 'correct' flash memory address.
+         * Now we fix up the ip and the lr registers. This ensures that when
+         * we return from here to the cpu_init_crit() and ultimately the
+         * reset() we keep running code in the remapped address.
+         */
+        orr     ip, ip, #PC302_BOOTABLE_FLASH_BASE
+        orr     lr, lr, #PC302_BOOTABLE_FLASH_BASE
+
+        /* Perform the 'remap' in the axi2cfg block
+         * This turns off the address aliasing in the hardware
+         */
+        ldr     r0, =PC302_AXI2CFG_BASE
+        ldr     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
+        bic     r1, #AXI2CFG_SYS_CONFIG_RW_REMAP_MASK
+        str     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
+        nop
+        nop
+
+        /* Preserve the link register across the following
+         * function calls
+         */
+        mov     r11,lr
+
+        /* Initialise the boot error pin */
+        bl      initialiseBootErrorPin
+
+        /* Setup the ARM memory interface */
+        bl      memif_arm_init
+
+        /* Set up the Shared memory interface */
+        bl      memif_shared_init
+
+        /* Restore link register */
+        mov     lr, r11
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * Macro: is_pc3x2
+ *
+ * Description: Check if the device is a PC3X2.
+ *
+ * tmp A temporary register.
+ *
+ * Example:
+ *
+ *  is_pc3x2	r0
+ *  LDREQ	r0, =PC3X2_VALUE
+ *  LDRNE	r0, =PC3X3_VALUE
+ *
+ *****************************************************************************/
+.macro	is_pc3x2, tmp
+	LDR	\tmp, =PC302_AXI2CFG_BASE
+	ORR	\tmp, \tmp, #AXI2CFG_DEVICE_ID_REG_OFFSET
+	LDR	\tmp, [\tmp]	@ Get the device ID.
+
+	ANDS	\tmp, \tmp, #0x0020
+.endm
+
+/*****************************************************************************
+ *
+ * memif_arm_init
+ *
+ * Description: Initialise the ARM Memory Controller
+ *
+ *****************************************************************************/
+memif_arm_init:
+
+        LDR     r3, =PC302_MEMIF_BASE
+
+        /* ;; =MEMIF_ARM_DRAM_INIT_PARAM_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        STR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_0_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_1_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
+
+        /* ;; =MEMIF_ARM_ADDR_MAP_2_OFFSET */
+        LDR     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16
+        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_PARAM_2_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        AND     r4, r4, #0xFFFFFFF0
+        ORR     r4, r4, #0x00000004 ; wl = cl - 2
+        STR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_BL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        BIC     r4, r4, #0x00000001 //; bl = 4
+        STR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+
+        /* ;;  =MEMIF_ARM_DRAM_EMR_MR_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        AND     r4, r4, #0xFFFFFF88
+        ORR     r4, r4, #0x00000002 //; bl = 4
+        ORR     r4, r4, #0x00000060 //; cl = 6
+        ORR     r4, r4, #0x04000000 //; dqs# = 0
+        STR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+
+        /* ;;  =MEMIF_ARM_PHY_CMD_RDC_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        ORR     r4, r4, #0x00000050 //;  phy wl
+        ORR     r4, r4, #0x00000006 //;  phy rl
+        AND     r4, r4, #0xFFFFFCFF
+        ORR     r4, r4, #0x00000300 //;  rdc_we_to_re_delay = 3 clks
+        AND     r4, r4, #0xFFFEFFFF
+        ORR     r4, r4, #0x00010000 //;  use_fixed_re = 1
+        STR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_SLV_DLL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+        AND     r4, r4, #0x0
+        ORR     r4, r4, #0x30000000 //;  dll rd_slave1 ratio
+        ORR     r4, r4, #0x00300000 //;  dll rd_slave0 ratio
+	is_pc3x2    r0
+        ORRNE   r4, r4, #0x00000050 //;  dll wr_slave ratio for PC3X3
+	ORREQ	r4, r4, #0x00000040 //;  dll wr_slave ratio for PC3X2
+        STR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+
+        /* ;; =MEMIF_ARM_DRAM_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_DRAM_ODT_OFFSET]
+        BIC     r4, r4, #0x00000001 //; disable dram odt during reads
+        STR     r4, [r3,#MEMIF_ARM_DRAM_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_ODT_CTRL_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        AND     r4, r4, #0xFFFFFF00
+        AND     r4, r4, #0xFFFF00FF
+        ORR     r4, r4, #0x0010 //; wr_odt_delay, cl-5
+        ORR     r4, r4, #0x3000 //; wr_odt_hold, 4 cycles required
+        STR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_ODT_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        AND     r4, r4, #0xFFFFFFC0
+        ORR     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
+                                //; wr_local_odt = off
+                                //; idle_local_odt = off
+        STR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+
+        /* ;; =MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET]
+        ORR     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
+        ORR     r4, r4, #0x000F //; All control signals half drive strength
+        STR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+
+        /* ;; =MEMIF_ARM_INDIRECT_RW_CMD_OFFSET */
+        LDR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        ORR     r4, r4, #0x1  //; de-assert soft reset
+        STR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+
+/* Check to see if the mem-if ARM is ready yet? */
+memif_arm_init_poll:
+        LDR     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
+        AND     r4, r4, #0x3
+        CMP     r4, #0x1
+        BNE     memif_arm_init_poll
+
+        mov	pc, lr		/* Return to my caller */
+
+/*****************************************************************************
+ *
+ * memif_shared_init
+ *
+ * Description: Initialise the Shared Memory Controller
+ *
+ *****************************************************************************/
+
+/* Data to set-up the memif-Shared Shared, this is effectively a load file */
+
+memif_shared_init_data:
+        .word   LF_PA_AEID_MEMIF, LF_CBFM_SLEEPREG_ADDR, PA_WRITE_ZERO_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S0_S1, ADDR_SDRAM_ARB_G0_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G0_S2_S3, ADDR_SDRAM_ARB_G0_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S0_S1, ADDR_SDRAM_ARB_G1_S0_S1_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ARB_G1_S2_S3, ADDR_SDRAM_ARB_G1_S2_S3_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_VALID_GROUPS, ADDR_SDRAM_VALID_GROUPS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_SETUP, ADDR_SDRAM_SETUP_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_REFRESH, ADDR_SDRAM_REFRESH_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_ODT_SETUP, ADDR_SDRAM_ODT_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_AXI_CONFIG, ADDR_SDRAM_AXI_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_MRS, ADDR_SDRAM_MRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_EMRS, ADDR_SDRAM_EMRS_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_CONFIG, ADDR_PHY_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_LOCAL_ODT_CONFIG, ADDR_PHY_LOCAL_ODT_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_RD_SLAVE, ADDR_PHY_RD_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_WR_SLAVE, ADDR_PHY_WR_SLAVE_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_PHY_IO_CELL_CONFIG, ADDR_PHY_IO_CELL_CONFIG_DATA
+        .word   LF_PA_AEID_MEMIF, LF_ADDR_SDRAM_CFG_DONE, ADDR_SDRAM_CFG_DONE_DATA
+
+memif_shared_init:
+
+        /* Write the intialisation data into the picoArray */
+        configWriteLoadFile r0, r1, r2, r3, r4, memif_shared_init_data, 54
+
+/* Check to see if the mem-if Shared is ready yet? */
+memif_shared_init_poll:
+
+        configRead r0, r1, r2, PA_AEID_MEMIF, ADDR_SDRAM_STATUS
+
+        /* Has it timed out? */
+        TST     r0, #PA_CONFIG_TIMEOUT
+        BNE     memif_shared_init_poll
+
+        /* Has it configured? */
+        TST     r0, #0x01
+        BEQ     memif_shared_init_poll
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * register_initialisation
+ *
+ * Description: Initialise some CPU registers
+ *
+ * Note:
+ * Used to prevent X propagation if running this code in a simulation
+ *
+ *****************************************************************************/
+register_initialisation:
+
+        mov     r0, #0x00000000
+        mov     r1, #0x00000000
+        mov     r2, #0x00000000
+        mov     r3, #0x00000000
+        mov     r4, #0x00000000
+        mov     r5, #0x00000000
+        mov     r6, #0x00000000
+        mov     r7, #0x00000000
+        mov     r8, #0x00000000
+        mov     r9, #0x00000000
+        mov     r10,#0x00000000
+
+        /* Don't noodle with r11 (fp)
+                             r12 (ip)
+                             r13 (sp)
+                             r14 (lr)
+                             r15 (pc)
+           as this would cause big probs ! */
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * initialiseBootErrorPin
+ *
+ * Initialise the GPIO that is used as the Boot Error pin
+ *
+ *****************************************************************************/
+ initialiseBootErrorPin:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Negate the Boot error pin (in the data register) */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+        orr     r1,r1,#NEGATE_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Set up Boot Error pin to be an output */
+        ldr     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+        orr     r1,r1,#BOOT_ERROR_PIN_IS_OUTPUT
+        str     r1,[r0, #GPIO_SW_PORT_C_DDR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+/*****************************************************************************
+ *
+ * assertBootError
+ *
+ * Assert the Boot Error pin.
+ *
+ * Note: On the PC7302 platform this is used to illuminate an led.
+ *
+ *****************************************************************************/
+ .global assertBootError
+
+ assertBootError:
+
+        /* Get base address of the arm gpio block */
+        ldr     r0,=PC302_GPIO_BASE
+
+        /* Assert the Boot Error pin */
+        mov     r1, #ASSERT_BOOT_ERROR_PIN
+        str     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
+
+        /* Return to my caller */
+        mov	pc, lr
+
+       .end
diff --git a/board/picochip/pc7302/mt29f2g08aadwp.c b/board/picochip/pc7302/mt29f2g08aadwp.c
new file mode 100644
index 0000000..88190d2
--- /dev/null
+++ b/board/picochip/pc7302/mt29f2g08aadwp.c
@@ -0,0 +1,199 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file .mt29f2g08aadwp.c
+* \brief Support for the NAND Flash device fitted on PC7302 platform.
+*
+* Copyright (c) 2009-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/*
+ * (C) Copyright 2009 SAGEM Communications
+ * (C) Copyright 2006 DENX Software Engineering
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_CMD_NAND
+
+#include <asm/arch/pc302.h>
+#include <nand.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/pc3xxgpio.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/axi2cfg.h>
+
+/* Constants --------------------------------------------------------------- */
+static unsigned int cle;
+static unsigned int ale;
+static unsigned int nce;
+static unsigned int rdy;
+
+/* Functions --------------------------------------------------------------- */
+/*!
+ * \brief Hardware specific access to control-lines
+ * \param mtd, pointer to the mtd_info structure
+ * \param dat, data to write to the device
+ * \param ctrl, control data to set up the transaction
+ *
+ */
+static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
+				    int dat,
+				    unsigned int ctrl)
+{
+    struct nand_chip *this = mtd->priv;
+
+    if (ctrl & NAND_CTRL_CHANGE)
+    {
+        if (ctrl & NAND_NCE)
+        {
+            /* Assert the chip select */
+            pc3xx_gpio_set_value(nce, 0);
+
+	    if (ctrl & NAND_CLE)
+            {
+	        /* Assert CLE */
+                pc3xx_gpio_set_value(cle, 1);
+            }
+    	    else
+	    {
+                /* Negate CLE */
+                pc3xx_gpio_set_value(cle, 0);
+            }
+
+	    if (ctrl & NAND_ALE)
+	    {
+                /* Assert ALE */
+                pc3xx_gpio_set_value(ale, 1);
+            }
+	    else
+            {
+		/* Negate ALE */
+                pc3xx_gpio_set_value(ale, 0);
+            }
+        }
+        else
+        {
+	    /* Negate the chip select */
+            pc3xx_gpio_set_value(nce, 1);
+        }
+    }
+
+    /* If we have data to write, write it */
+    if (dat != NAND_CMD_NONE)
+    {
+	*(volatile unsigned char *)(this->IO_ADDR_W) = (unsigned char)dat;
+    }
+}
+
+/*!
+ * \brief Return the state of the NAND busy output
+ * \param mtd, pointer to the mtd_info structure
+ * \return 0 - nand busy
+ *         1 - nand ready
+ *
+ */
+static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
+{
+    return pc3xx_gpio_get_value(rdy);
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+    /* Define which gpio bits are used to control the NAND Flash
+     *
+     * Note: These pin definitions mean that we can only use NAND
+     *       Flash if we are running U-Boot from RAM and have NOT booted
+     *       the device from parallel NOR Flash.
+     */
+    if (is_pc3x3())
+    {
+        cle = PC3X3_GPIO_PIN_ARM_4;
+        ale = PC3X3_GPIO_PIN_ARM_3;
+        nce = PC3X3_GPIO_PIN_ARM_2;
+        rdy = PC3X3_GPIO_PIN_ARM_1;
+
+        /* Setup some pin muxing */
+        pc3xx_group_set_mux ("pai_tx_data[3:0]", MUX_PERIPHERAL);
+        pc3xx_pin_set_mux(PC3X3_GPIO_PIN_ARM_4, MUX_ARM);
+    }
+    else
+    {
+        cle = PC302_GPIO_PIN_ARM_4;
+        ale = PC302_GPIO_PIN_ARM_3;
+        nce = PC302_GPIO_PIN_ARM_2;
+        rdy = PC302_GPIO_PIN_ARM_1;
+
+        /* Setup some pin muxing */
+        pc3xx_pin_set_mux(PC302_GPIO_PIN_ARM_4, MUX_ARM);
+    }
+
+    /* Request the required gpio pins */
+    (void)pc3xx_gpio_request(rdy);
+    (void)pc3xx_gpio_request(nce);
+    (void)pc3xx_gpio_request(ale);
+    (void)pc3xx_gpio_request(cle);
+
+    /* Initialise the pin direction */
+    (void)pc3xx_gpio_direction_input(rdy );
+    (void)pc3xx_gpio_direction_output(nce, 1);
+    (void)pc3xx_gpio_direction_output(ale, 0);
+    (void)pc3xx_gpio_direction_output(cle, 0);
+
+    /* Populate some members of the nand structure */
+    nand->cmd_ctrl = mt29f2g08aadwp_cmd_ctrl;
+    nand->ecc.mode = NAND_ECC_SOFT;
+    nand->dev_ready = mt29f2g08aadwp_dev_ready;
+    nand->IO_ADDR_R = (void __iomem *)CONFIG_SYS_NAND_BASE;
+    nand->IO_ADDR_W = (void __iomem *)CONFIG_SYS_NAND_BASE;
+
+    return 0;
+}
+#endif /* CONFIG_CMD_NAND */
diff --git a/board/picochip/pc7302/pc7302.c b/board/picochip/pc7302/pc7302.c
new file mode 100644
index 0000000..259d7a7
--- /dev/null
+++ b/board/picochip/pc7302/pc7302.c
@@ -0,0 +1,245 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file pc7302.c
+* \brief Various useful functions for use on a PC7302 Platform.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pc3xxgpio.h>
+#include <netdev.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Constants --------------------------------------------------------------- */
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ *
+ * Start a timer in free running mode
+ *
+ * \param timer, the timer to start
+ *
+ */
+static void pc302_timer_start(int timer);
+
+/* Functions --------------------------------------------------------------- */
+
+/*****************************************************************************
+ *
+ * show_boot_progress()
+ *
+ * Purpose: Indicate booting progress
+ *
+ * Note: see U-Boot README for a list of 'progress' values.
+ *
+ *****************************************************************************/
+#if defined(CONFIG_SHOW_BOOT_PROGRESS)
+void show_boot_progress(int progress)
+{
+	printf("Boot reached stage %d\n", progress);
+}
+#endif
+
+/*****************************************************************************
+ *
+ * board_init()
+ *
+ * Purpose: Hardware platform initialisation functions
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int board_init (void)
+{
+    /* Setup some kernel boot parameters */
+    gd->bd->bi_boot_params = 0x00000100;
+
+    /* Setup the machine type */
+    gd->bd->bi_arch_number = MACH_TYPE_PC7302;
+
+    gd->flags = 0;
+
+    /* Enable the Instruction Cache */
+    icache_enable ();
+
+    /* Start timer #0 */
+    pc302_timer_start(0);
+
+    /* Initialise the gpio muxing library */
+    pc3xx_muxing_init();
+
+    /* Initialise the gpio library */
+    pc3xx_gpio_init();
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * checkboard()
+ *
+ * Purpose: Display some useful hardware platform information.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int checkboard (void)
+{
+    printf("Board: Picochip "PICOCHIP_PLATFORM" \n");
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * print_cpuinfo()
+ *
+ * Purpose: Display some useful info about the cpu we are running on.
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int print_cpuinfo(void)
+{
+    unsigned int device_id, device_rev;
+    unsigned int die_id[4];
+
+    /* What device are we running on ? */
+    printf("CPU:   ");
+
+    device_id = pc302_read_device_id();         /* Read the device id */
+    device_rev = pc302_read_device_revision();  /* Read the revision code */
+    pc302_read_die_id_number(&die_id[0]);       /* Read the die id */
+
+    switch (device_id)
+    {
+        case PC302_DEVICE_ID:
+        {
+            printf("PC302 Rev %04d\n", device_rev);
+            break;
+        }
+        case PC312_DEVICE_ID:
+        {
+            printf("PC312 Rev %04d\n", device_rev);
+            break;
+        }
+        case PC313_DEVICE_ID:
+        {
+            printf("PC313 Rev %04d\n", device_rev);
+            break;
+        }
+        case PC323_DEVICE_ID:
+        {
+            printf("PC323 Rev %04d\n", device_rev);
+            break;
+        }
+        case PC333_DEVICE_ID:
+        {
+            printf("PC333 Rev %04d\n", device_rev);
+            break;
+        }
+        default:
+        {
+            printf("Unknown !\n");
+        }
+    }
+
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * misc_init_r()
+ *
+ * Purpose: Miscellaneous platform dependent initialisations
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int misc_init_r (void)
+{
+    /* Not used right now, function template left here as a place holder */
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ * dram_init()
+ *
+ * Purpose: Initialize the DDR SDRAM info in the board data structure
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+int dram_init (void)
+{
+    gd->ram_size =
+        get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+
+    return 0;
+}
+
+void dram_init_banksize(void)
+{
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size =
+        get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+}
+
+static void pc302_timer_start(int timer)
+{
+    /* Make sure the timer is disabled */
+    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
+                               TIMERNCONTROLREGOFFSET (timer) ),
+                              0 );
+
+    /* Initialise the timer to all 1's.
+     * We do this  because we want to run
+     * the timer in free running mode.
+     */
+    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
+                               TIMERNLOADCOUNTREGOFFSET (timer) ),
+                              0xFFFFFFFF );
+
+    /* Start the timer in free running mode */
+    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
+                               TIMERNCONTROLREGOFFSET (timer) ),
+                             ( TIMERINTERRUPTMASK | TIMERENABLE ) );
+}
+
+/*****************************************************************************
+ *
+ * board_eth_init()
+ *
+ * Purpose: Initialize the Ethernet controller
+ *
+ * Returns: 0 - Success
+ *
+ *****************************************************************************/
+
+int board_eth_init(bd_t *bis)
+{
+    int ret = -1;
+
+#ifdef CONFIG_DW_EMAC
+    ret = pc302_eth_register(bis);
+#endif
+
+    return ret;
+}
diff --git a/boards.cfg b/boards.cfg
index 3cf75c3..d903edd 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -179,6 +179,8 @@ versatilepb                  arm         arm926ejs   versatile           armltd
 versatileqemu                arm         arm926ejs   versatile           armltd         versatile   versatile:ARCH_VERSATILE_QEMU,ARCH_VERSATILE_PB
 integratorap_cm946es         arm         arm946es    integrator          armltd         -               integratorap:CM946ES
 integratorcp_cm946es         arm         arm946es    integrator          armltd         -               integratorcp:CM946ES
+picochippc7302nor            arm         arm926ejs   pc7302              picochip       picoxcell
+picochippc7302nand           arm         arm926ejs   pc7302              picochip       picoxcell
 ca9x4_ct_vxp                 arm         armv7       vexpress            armltd
 am335x_evm                   arm         armv7       am335x              ti             am33xx
 highbank                     arm         armv7       highbank            -              highbank
diff --git a/include/configs/picochippc7302-common.h b/include/configs/picochippc7302-common.h
new file mode 100644
index 0000000..bac3309
--- /dev/null
+++ b/include/configs/picochippc7302-common.h
@@ -0,0 +1,388 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file picochippc7302.h
+* \brief Configuration file for U-Boot on the PC7302 platform.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/pc302.h>
+#include <asm/arch/uart.h>
+#include <asm/sizes.h>
+
+/*-----------------------------------------------------------------------------
+ * Platform Identification Stuff
+ */
+#define PICOCHIP "picochip"
+
+/* Which hardware platform I am destined for */
+#define PICOCHIP_PLATFORM "PC7302"
+
+/* Specific version of this build */
+#ifndef PICOCHIP_PLATFORM_VERSION
+#define PICOCHIP_PLATFORM_VERSION "dummy_release"
+#endif /* PICOCHIP_PLATFORM_VERSION */
+
+#define CONFIG_IDENT_STRING " "PICOCHIP"-"PICOCHIP_PLATFORM_VERSION \
+                            "-"PICOCHIP_PLATFORM
+
+/*-----------------------------------------------------------------------------
+ * High Level Configuration Options
+ */
+/* Running on Picochip PC3X2 Silicon */
+#define CONFIG_PICOCHIP_PC3X2
+
+/* Running on Picochip PC3X3 Silicon */
+#define CONFIG_PICOCHIP_PC3X3
+
+/* Running on a Picochip PC7302 platform */
+#define CONFIG_PICOCHIP_PC7302
+
+/* Bootable Flash memory has to live here (/ebi_decode0) */
+#define PC302_BOOTABLE_FLASH_BASE   (PC302_FLASH_BASE)
+
+/* Base address of the onchip SRAM */
+#define PC302_ONCHIP_SRAM_BASE      (PC302_SRAM_BASE)
+#define PC302_ONCHIP_SRAM_SIZE      (PC302_SRAM_SIZE)
+
+/* ARM Sub-system peripherals are clocked at 200MHz */
+#define PC302_AHB_CLOCK_FREQ        (200000000)
+
+/* Don't use Interrupts */
+#undef CONFIG_USE_IRQ
+
+/* A time tick is 1 millisecond (this is NOT CPU tick) */
+#define CONFIG_SYS_HZ               (1000)
+
+/* Display board info */
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* Display cpu info */
+#define CONFIG_DISPLAY_CPUINFO
+
+/*-----------------------------------------------------------------------
+ * Stack Sizes
+ *
+ * The stack sizes are set up in arch/arm/lib/board.c using the
+ * settings below
+ */
+#define CONFIG_STACKSIZE	(SZ_256K) 	    /* regular stack */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(SZ_4K)             /* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(SZ_4K)    	    /* FIQ stack */
+#endif /* CONFIG_USE_IRQ */
+
+/*-----------------------------------------------------------------------
+ * Initial Stack Pointer
+ *
+ * Note: This is only used before U-Boot relocation takes place.
+ *       The global data is stored above this address, whilst the stack
+ *       is below this address. After relocation the stack is automatically
+ *       moved to the top of the available sdram.
+ */
+#define CONFIG_SYS_INIT_SP_ADDR (0x00001000)
+
+/*-----------------------------------------------------------------------------
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN   (SZ_1M)
+
+/*-----------------------------------------------------------------------------
+ * Linux Kernel Stuff
+ */
+/* Allow passing of command line args (bootargs) to the linux kernel*/
+#define CONFIG_CMDLINE_TAG          1
+#define CONFIG_SETUP_MEMORY_TAGS    1
+
+/*-----------------------------------------------------------------------------
+ * DDR2 RAM Memory Map
+ *
+ * We have 1 linear addressable RAM bank
+ *
+ * Note: CONFIG_SYS_SDRAM_BASE must start at 0
+ */
+#define CONFIG_SYS_SDRAM_BASE	(0x00000000)
+#define CONFIG_NR_DRAM_BANKS    (1)
+#define PHYS_SDRAM_1		(PC302_DDRBANK_BASE)
+#define PHYS_SDRAM_1_SIZE	(SZ_128M)
+
+/*-----------------------------------------------------------------------------
+ * SPI Flash Memory Stuff
+ */
+#define CONFIG_DW_SPI
+
+/* Include generic support for SPI Flash memory devices */
+#define CONFIG_SPI_FLASH
+
+/* Include support for SPI Flash memory devices from ST Micro/Numonyx */
+#define CONFIG_SPI_FLASH_STMICRO
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Environment Stuff
+ *
+ * Note: See picochippc7302nor.h and pichippc7302nand.h
+ *       for more information.
+ */
+#if !defined(CONFIG_RUN_FROM_RAM) && !defined(CONFIG_CMD_NAND) && \
+    !defined(CONFIG_ENV_SIZE)
+
+/* We are running from ram, therefore no environment */
+#define CONFIG_ENV_IS_NOWHERE
+
+/* Size of environment variables */
+#define CONFIG_ENV_SIZE		(SZ_2K)
+
+#endif /* CONFIG_RUN_FROM_RAM && !defined(CONFIG_CMD_NAMD) &&
+	  !defined(CONFIG_ENV_SIZE) */
+
+/*-----------------------------------------------------------------------------
+ * Timer Stuff
+ */
+#define CONFIG_SYS_TIMERBASE    (PC302_TIMER_BASE)
+
+/*-----------------------------------------------------------------------------
+ * Ethernet Stuff
+ */
+#define CONFIG_DW_EMAC
+#define CONFIG_PHY_ADDR         (1)
+#define CONFIG_NET_MULTI
+
+/*-----------------------------------------------------------------------------
+ * Serial Port Stuff
+ */
+#define CONFIG_DW_APB_UART
+
+/* Baud rate generators clock with a 3.6864 MHz clock */
+#define CONFIG_DW_APB_UART_CLOCK    (3686400)
+
+/* Console on Uart #0 */
+#define CONFIG_CONS_INDEX	    (1)
+
+/* Table of supported baud rates */
+#define CONFIG_SYS_BAUDRATE_TABLE   { 9600, 19200,  \
+                                      38400, 57600, \
+                                      115200, 230400 }
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Memory Test (mtest command) Stuff
+ */
+/* Default start address for memory test */
+#define CONFIG_SYS_MEMTEST_START    (PC302_ONCHIP_SRAM_BASE)
+
+/* Default end address for memory test */
+#define CONFIG_SYS_MEMTEST_END  (CONFIG_SYS_MEMTEST_START + \
+                                 PC302_ONCHIP_SRAM_SIZE - 1)
+
+/* Define this to use the super duper memory test */
+#define CONFIG_SYS_ALT_MEMTEST
+
+/* Use Uart #1 scratch pad reg */
+#define CONFIG_SYS_MEMTEST_SCRATCH  (PC302_UART1_BASE + \
+                                     UART_SCRATCH_REG_OFFSET)
+
+/*-----------------------------------------------------------------------------
+ * U-Boot Supported Commands
+ */
+#include "config_cmd_default.h"
+
+/* Include 'ping' command */
+#define CONFIG_CMD_PING
+
+/* Include commands for SPI Flash memory */
+#define CONFIG_CMD_SF
+
+/* Turn off a bunch of default commands */
+#undef CONFIG_CMD_BOOTD
+#undef CONFIG_CMD_CONSOLE
+#undef CONFIG_CMD_ECHO
+#undef CONFIG_CMD_EDITENV
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_ITEST
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADB
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_SOURCE
+#undef CONFIG_CMD_XIMG
+
+#ifdef CONFIG_SYS_NO_FLASH
+#undef CONFIG_CMD_FLASH
+#endif /* CONFIG_SYS_NO_FLASH */
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+#undef CONFIG_CMD_SAVEENV
+#endif /* CONFIG_ENV_IS_NOWHERE */
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+
+#ifdef  CONFIG_SYS_HUSH_PARSER
+/* This defines the secondary prompt string */
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif /* CONFIG_SYS_HUSH_PARSER */
+
+/* Enable command line editing and history */
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------------
+ * Miscellaneous Configurable Options...
+ */
+/* Use 'long' help messages */
+#define CONFIG_SYS_LONGHELP
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT   "=> "
+
+/* Console I/O Buffer Size*/
+#define CONFIG_SYS_CBSIZE   (SZ_1K)
+
+/* Print buffer size */
+#define CONFIG_SYS_PBSIZE   (CONFIG_SYS_CBSIZE + \
+                             sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Maximum number of command args */
+#define CONFIG_SYS_MAXARGS  (16)
+
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE (CONFIG_SYS_CBSIZE)
+
+/* Default load address for tftp, bootm and friends */
+#define CONFIG_SYS_LOAD_ADDR    0x00200000
+#define CONFIG_LOADADDR         CONFIG_SYS_LOAD_ADDR
+
+/*-----------------------------------------------------------------------
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_DW_EMAC)
+
+/* Picochip OUI
+ *
+ * Note: The MAC Address defined by 'CONFIG_ETHADDR' is based on
+ * Picochip's OUI,see http://standards.ieee.org/regauth/oui/index.shtml
+ * for more information. It will need to be modified for each and every
+ * individual hardware platform.
+ */
+#define CONFIG_ETHADDR          00:15:E1:00:00:00
+
+/* Picochip default for testing, will need noodling by users */
+#define CONFIG_IPADDR           172.17.13.248
+
+#define CONFIG_HOSTNAME	        picopc7302
+#define CONFIG_ROOTPATH	        /var/nfspc7302
+#define CONFIG_BOOTFILE	        uImage-pc7302
+
+#define CONFIG_SERVERIP         172.17.7.100
+#define CONFIG_GATEWAYIP        172.17.0.1
+#define CONFIG_NETMASK          255.255.0.0
+
+/* Enable the MII utility commands */
+#undef CONFIG_CMD_MII
+
+#endif /* CONFIG_DW_EMAC */
+
+/* This is the address in NOR Flash where the Linux kernel
+ * can be found.
+ */
+#define CONFIG_FLASH_KERNEL_BASE   0x40060000
+
+/* This is the offset from the start of NAND Flash
+ * to where the Linux kernel can be found.
+ */
+#define CONFIG_NAND_KERNEL_OFFSET  0x00180000
+
+/* Time in seconds before autoboot, -1 disables auto-boot */
+#define CONFIG_BOOTDELAY        5
+
+/* The boot command will set bootargs */
+#undef  CONFIG_BOOTARGS
+
+/* Default console baud rate */
+#define CONFIG_BAUDRATE	        115200
+
+/* Unless specified here we'll just rely on the kernel default */
+#define OTHERBOOTARGS
+
+/* Define the JFFS2 root filesystem partition (NOR Flash) */
+#define NOR_JFFS2_ROOT          /dev/mtdblock3
+
+/* Define the JFFS2 root filesystem partition (NAND Flash) */
+#define NAND_JFFS2_ROOT         /dev/mtdblock5
+
+/* Define the UBIFS root filesystem partition (NOR Flash) */
+#define NOR_UBIFS_ROOT          3
+
+/* Define the UBIFS root filesystem partition for NAND Flash */
+#define NAND_UBIFS_ROOT         5
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				            \
+   "othbootargs=" MK_STR (OTHERBOOTARGS) "\0"                               \
+   "netdev=eth0\0"                                                          \
+   "consoledev=ttyS0\0"                                                     \
+   "kernel_flash_addr=" MK_STR(CONFIG_FLASH_KERNEL_BASE) "\0"		    \
+   "kernel_nand_offset=" MK_STR(CONFIG_NAND_KERNEL_OFFSET) "\0"             \
+   "nor_jffs2_root=" MK_STR(NOR_JFFS2_ROOT) "\0"		            \
+   "nand_jffs2_root=" MK_STR(NAND_JFFS2_ROOT) "\0"		            \
+   "nor_ubifs_root=" MK_STR(NOR_UBIFS_ROOT) "\0"		            \
+   "nand_ubifs_root=" MK_STR(NAND_UBIFS_ROOT) "\0"		            \
+   "flash_jffs2=run jffs2_args; bootm $kernel_flash_addr\0"		    \
+   "flash_ubifs=run ubifs_args; bootm $kernel_flash_addr\0"		    \
+   "nand_jffs2=run nand_jffs2_args; nboot $loadaddr 0 "                     \
+   "$kernel_nand_offset; bootm $loadaddr\0"                                 \
+   "nand_ubifs=run nand_ubifs_args; nboot $loadaddr 0 "                     \
+   "$kernel_nand_offset; bootm $loadaddr\0"                                 \
+   "fixed_nfs=run nfs_args; tftp; bootm\0"				    \
+   "jffs2_args=setenv bootargs root=$nor_jffs2_root rw rootfstype=jffs2 "   \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "ubifs_args=setenv bootargs root=ubi0:rootfs rw rootfstype=ubifs "       \
+   "ubi.mtd=$nor_ubifs_root "                                               \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nand_jffs2_args=setenv bootargs root=$nand_jffs2_root rw "              \
+   "rootfstype=jffs2 "                                                      \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nand_ubifs_args=setenv bootargs root=ubi0:rootfs rw rootfstype=ubifs "  \
+   "ubi.mtd=$nand_ubifs_root,2048 "                                         \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;\0"                          \
+   "nfs_args=setenv bootargs root=/dev/nfs rw nfsroot=$serverip:$rootpath " \
+   "ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:any "        \
+   "console=$consoledev,$baudrate $othbootargs;"                            \
+
+/* Define CONFIG_BOOTCOMMAND as
+ * "run nand_ubifs" for boot from NAND flash with ubifs filesystem
+ * "run nand_jffs2" for boot from NAND flash with jffs2 filesystem
+ * "run flash_ubifs" for boot from NOR flash with ubifs filesystem
+ * "run flash_jffs2" for boot from NOR flash with jffs2 filesystem
+ * "run fixed_nfs" for standard NFS with fixed IP address.
+ */
+#if defined(CONFIG_CMD_NAND)
+    #if defined(CONFIG_USE_UBIFS)
+        #define CONFIG_BOOTCOMMAND  "run nand_ubifs"
+    #else
+        #define CONFIG_BOOTCOMMAND  "run nand_jffs2"
+    #endif
+#else /* !defined(CONFIG_CMD_NAND) */
+    #if defined(CONFIG_USE_UBIFS)
+        #define CONFIG_BOOTCOMMAND  "run flash_ubifs"
+    #else
+        #define CONFIG_BOOTCOMMAND  "run flash_jffs2"
+    #endif
+#endif
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/picochippc7302nand.h b/include/configs/picochippc7302nand.h
new file mode 100644
index 0000000..35bc317
--- /dev/null
+++ b/include/configs/picochippc7302nand.h
@@ -0,0 +1,86 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file picochippc7302.h
+* \brief Configuration file for U-Boot on the PC7302 platform.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_PC7302_NAND__
+#define __CONFIG_PC7302_NAND__
+
+#include <asm/arch/pc302.h>
+#include <asm/sizes.h>
+
+/*-----------------------------------------------------------------------------
+ * NAND Flash Memory Stuff
+ */
+#define CONFIG_SYS_NAND_BASE        PC302_EBI_CS2_BASE
+#define CONFIG_SYS_NAND_MAX_CHIPS   1
+#define CONFIG_SYS_MAX_NAND_DEVICE  1
+
+/* Define Flash memory sector size */
+#define NAND_FLASH_SECTOR_SIZE      (SZ_128K)
+
+/* Include support / commands for NAND Flash
+ *
+ * Note: Please read the comments in file
+ *       board/picochip/pc7302/mt29f2g08aadwp.c about gpio pins used
+ *       and PC302 booting modes before defining CONFIG_CMD_NAND
+ */
+
+/* Needed for nand_util.c */
+#define CONFIG_SYS_64BIT_VSPRINTF
+
+/* Do not perform any low level initialisation */
+#define CONFIG_SKIP_LOWLEVEL_INIT   1
+
+/* No flash memory in the system */
+#define CONFIG_SYS_NO_FLASH
+
+/* We are runing from ram with NAND support */
+
+/* NAND Flash memory map
+ *
+ *  Block 0-3 U-Boot image
+ *  Block 4-7 Redundant U-Boot image
+ *  Block 8 U-Boot environment
+ *  Block 9 Redundant U-Boot environment
+ *  Block 10 Not Used
+ *  Block 11 Not Used
+ *  Block 12 Linux kernel
+ *
+ */
+#define CONFIG_ENV_IS_IN_NAND
+
+/* Offset address of environment variables */
+#define CONFIG_ENV_OFFSET           (NAND_FLASH_SECTOR_SIZE * 8)
+
+/* Size of environment variables */
+#define CONFIG_ENV_SIZE             (NAND_FLASH_SECTOR_SIZE)
+
+/* Offset address of the redundant envinronment variables */
+#define CONFIG_ENV_OFFSET_REDUND    (NAND_FLASH_SECTOR_SIZE * 9)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_CMD_NAND
+
+#define CONFIG_USE_UBIFS
+
+/* Build U-Boot to run at this address */
+#define CONFIG_SYS_TEXT_BASE 0x06000000
+
+#include <configs/picochippc7302-common.h>
+
+#endif /* __CONFIG_PC7302_NAND__ */
diff --git a/include/configs/picochippc7302nor.h b/include/configs/picochippc7302nor.h
new file mode 100644
index 0000000..603d5bb
--- /dev/null
+++ b/include/configs/picochippc7302nor.h
@@ -0,0 +1,80 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file picochippc7302nor.h
+* \brief Configuration file for U-Boot on the PC7302 platform.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __CONFIG_PC7302_NOR__
+#define __CONFIG_PC7302_NOR__
+
+#include <asm/arch/pc302.h>
+#include <asm/sizes.h>
+
+/* Start address of the flash memory */
+#define CONFIG_SYS_FLASH_BASE   (PC302_BOOTABLE_FLASH_BASE)
+
+/* Define Flash memory sector size */
+#define FLASH_SECTOR_SIZE	(SZ_128K)
+
+/* Use buffered writes to flash memory */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+/* Maximum number of memory banks (devices) */
+#define CONFIG_SYS_MAX_FLASH_BANKS  (1)
+
+/* Maximum number of sectors per flash device */
+#define CONFIG_SYS_MAX_FLASH_SECT   (1024)
+
+/* Timeouts for Flash Erasing and writing */
+#define CONFIG_SYS_FLASH_ERASE_TOUT (2 * CONFIG_SYS_HZ)
+#define CONFIG_SYS_FLASH_WRITE_TOUT (2 * CONFIG_SYS_HZ)
+
+/* Build the cfi mtd driver */
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+
+/* print 'E' for empty sector on flinfo */
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+
+/* U-Boot lives in the bottom of the Flash memory */
+#define CONFIG_SYS_MONITOR_BASE (CONFIG_SYS_FLASH_BASE)
+
+/* U-Boot occupies 2 flash sectors */
+#define CONFIG_SYS_MONITOR_LEN  (2 * FLASH_SECTOR_SIZE)
+
+/* Environment variables stored in Flash memory */
+#define CONFIG_ENV_IS_IN_FLASH
+
+/* Start address of environment variables */
+#define CONFIG_ENV_ADDR         (PC302_BOOTABLE_FLASH_BASE + CONFIG_SYS_MONITOR_LEN)
+
+/* One flash sector for environment varisbles */
+#define CONFIG_ENV_SECT_SIZE    (FLASH_SECTOR_SIZE)
+
+/* But 64 KBytes is sufficient */
+#define CONFIG_ENV_SIZE		(SZ_64K)
+
+/* Turn off wite protection for vendor parameters */
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_RUN_FROM_RAM
+#define CONFIG_SKIP_LOWLEVEL_INIT   1
+#define CONFIG_SYS_TEXT_BASE        0x06000000
+#else
+#define CONFIG_SYS_TEXT_BASE        0x40000000
+#endif /* CONFIG_RUN_FROM_RAM */
+
+#include <configs/picochippc7302-common.h>
+
+#endif /* __CONFIG_PC7302_NOR__ */
diff --git a/include/netdev.h b/include/netdev.h
index 4724717..af42e3b 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -104,6 +104,7 @@ int xilinx_emaclite_initialize(bd_t *bis, unsigned long base_addr,
 							int txpp, int rxpp);
 int xilinx_ll_temac_eth_init(bd_t *bis, unsigned long base_addr, int flags,
 						unsigned long ctrl_addr);
+int pc302_eth_register(bd_t *bis);
 
 /*
  * As long as the Xilinx xps_ll_temac ethernet driver has not its own interface
-- 
1.7.0.4

