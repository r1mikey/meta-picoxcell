From 773cf5d4d75c5841880110aaf17b3ce93b5ef6c5 Mon Sep 17 00:00:00 2001
From: Dave Aldridge <david.aldridge@picochip.com>
Date: Mon, 18 Apr 2011 13:57:50 +0100
Subject: [PATCH 04/70] picoxcell: name change (pc3xx to picoxcell)

---
 Makefile                                           |    4 +-
 arch/arm/cpu/arm926ejs/pc3xx/Makefile              |   69 --
 arch/arm/cpu/arm926ejs/pc3xx/emac.c                |  889 --------------
 arch/arm/cpu/arm926ejs/pc3xx/gpio.c                | 1075 -----------------
 arch/arm/cpu/arm926ejs/pc3xx/mux.c                 | 1274 --------------------
 arch/arm/cpu/arm926ejs/pc3xx/reset.S               |   63 -
 arch/arm/cpu/arm926ejs/pc3xx/spi.c                 |  704 -----------
 arch/arm/cpu/arm926ejs/pc3xx/timer.c               |  146 ---
 arch/arm/cpu/arm926ejs/pc3xx/utilities.c           |  243 ----
 arch/arm/cpu/arm926ejs/picoxcell/Makefile          |   69 ++
 arch/arm/cpu/arm926ejs/picoxcell/emac.c            |  821 +++++++++++++
 arch/arm/cpu/arm926ejs/picoxcell/gpio.c            | 1041 ++++++++++++++++
 arch/arm/cpu/arm926ejs/picoxcell/mux.c             | 1254 +++++++++++++++++++
 arch/arm/cpu/arm926ejs/picoxcell/reset.S           |   58 +
 arch/arm/cpu/arm926ejs/picoxcell/spi.c             |  656 ++++++++++
 arch/arm/cpu/arm926ejs/picoxcell/timer.c           |  146 +++
 arch/arm/cpu/arm926ejs/picoxcell/utilities.c       |  202 ++++
 arch/arm/include/asm/arch-pc3xx/axi2cfg.h          |  162 ---
 arch/arm/include/asm/arch-pc3xx/ebi.h              |  184 ---
 arch/arm/include/asm/arch-pc3xx/emac.h             |  189 ---
 arch/arm/include/asm/arch-pc3xx/fuse.h             |   76 --
 arch/arm/include/asm/arch-pc3xx/gpio.h             |   74 --
 arch/arm/include/asm/arch-pc3xx/mem_arm.h          |  129 --
 arch/arm/include/asm/arch-pc3xx/mem_shd.h          |  395 ------
 arch/arm/include/asm/arch-pc3xx/mux.h              |   53 -
 arch/arm/include/asm/arch-pc3xx/pa.h               |   40 -
 arch/arm/include/asm/arch-pc3xx/pc302.h            |   92 --
 arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h        |  214 ----
 arch/arm/include/asm/arch-pc3xx/spi.h              |   98 --
 arch/arm/include/asm/arch-pc3xx/timer.h            |   85 --
 arch/arm/include/asm/arch-pc3xx/uart.h             |  158 ---
 arch/arm/include/asm/arch-pc3xx/utilities.h        |  133 --
 arch/arm/include/asm/arch-pc3xx/wdog.h             |   60 -
 arch/arm/include/asm/arch-picoxcell/axi2cfg.h      |  161 +++
 arch/arm/include/asm/arch-picoxcell/ebi.h          |  184 +++
 arch/arm/include/asm/arch-picoxcell/emac.h         |  189 +++
 arch/arm/include/asm/arch-picoxcell/fuse.h         |   76 ++
 arch/arm/include/asm/arch-picoxcell/gpio.h         |   73 ++
 arch/arm/include/asm/arch-picoxcell/mem_arm.h      |  129 ++
 arch/arm/include/asm/arch-picoxcell/mem_shd.h      |  392 ++++++
 arch/arm/include/asm/arch-picoxcell/mux.h          |   47 +
 arch/arm/include/asm/arch-picoxcell/pa.h           |   40 +
 arch/arm/include/asm/arch-picoxcell/picoxcell.h    |   89 ++
 .../include/asm/arch-picoxcell/picoxcell_gpio.h    |  204 ++++
 arch/arm/include/asm/arch-picoxcell/spi.h          |   97 ++
 arch/arm/include/asm/arch-picoxcell/timer.h        |   84 ++
 arch/arm/include/asm/arch-picoxcell/uart.h         |  157 +++
 arch/arm/include/asm/arch-picoxcell/utilities.h    |  108 ++
 arch/arm/include/asm/arch-picoxcell/wdog.h         |   60 +
 board/picochip/pc7302/lowlevel_init.S              |  260 ++---
 board/picochip/pc7302/mt29f2g08aadwp.c             |  186 ++--
 board/picochip/pc7302/pc7302.c                     |  176 ++--
 include/configs/picochippc7302-common.h            |   29 +-
 include/configs/picochippc7302nand.h               |   10 +-
 include/configs/picochippc7302nor.h                |    6 +-
 include/netdev.h                                   |    2 +-
 56 files changed, 6638 insertions(+), 6977 deletions(-)
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/Makefile
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/emac.c
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/gpio.c
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/mux.c
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/reset.S
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/spi.c
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/timer.c
 delete mode 100644 arch/arm/cpu/arm926ejs/pc3xx/utilities.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/Makefile
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/emac.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/gpio.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/mux.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/reset.S
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/spi.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/timer.c
 create mode 100644 arch/arm/cpu/arm926ejs/picoxcell/utilities.c
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/axi2cfg.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/ebi.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/emac.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/fuse.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/gpio.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/mem_arm.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/mem_shd.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/mux.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/pa.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/pc302.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/spi.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/timer.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/uart.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/utilities.h
 delete mode 100644 arch/arm/include/asm/arch-pc3xx/wdog.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/axi2cfg.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/ebi.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/emac.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/fuse.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/gpio.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/mem_arm.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/mem_shd.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/mux.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/pa.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/picoxcell.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/picoxcell_gpio.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/spi.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/timer.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/uart.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/utilities.h
 create mode 100644 arch/arm/include/asm/arch-picoxcell/wdog.h

diff --git a/Makefile b/Makefile
index 7796fc7..b7a3ccf 100644
--- a/Makefile
+++ b/Makefile
@@ -686,10 +686,10 @@ SX1_config:		unconfig
 	@$(MKCONFIG) -n $@ SX1 arm arm925t sx1
 
 picochippc7302nand_config :	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip pc3xx
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip picoxcell
 
 picochippc7302nor_config :	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip pc3xx
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs pc7302 picochip picoxcell
 
 #########################################################################
 ## ARM1176 Systems
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/Makefile b/arch/arm/cpu/arm926ejs/pc3xx/Makefile
deleted file mode 100644
index 91d9792..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/Makefile
+++ /dev/null
@@ -1,69 +0,0 @@
-#/*****************************************************************************
-# * $picoChipHeaderSubst$
-# *****************************************************************************/
-
-#/*!
-#* \file Makefile
-#* \brief
-#*
-#* Copyright (c) 2006-2011 Picochip Ltd
-#*
-#* This program is free software; you can redistribute it and/or modify
-#* it under the terms of the GNU General Public License version 2 as
-#* published by the Free Software Foundation.
-#*
-#* All enquiries to support@picochip.com
-#*/
-
-#
-# (C) Copyright 2000-2006
-# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(SOC).o
-
-SOBJS-y := reset.o
-
-COBJS-y += emac.o
-COBJS-y += timer.o
-COBJS-y += spi.o
-COBJS-y += utilities.o
-COBJS-y += mux.o
-COBJS-y += gpio.o
-
-SRCS    := $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
-OBJS    := $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
-
-all:	$(obj).depend $(LIB)
-
-$(LIB):	$(OBJS)
-	$(call cmd_link_o_target, $(OBJS))
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/emac.c b/arch/arm/cpu/arm926ejs/pc3xx/emac.c
deleted file mode 100644
index 0e63c1a..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/emac.c
+++ /dev/null
@@ -1,889 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file emac.c
-* \brief Ethernet driver for the PC302.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-
-#ifdef CONFIG_DW_EMAC
-
-#include <malloc.h>
-#include <asm/errno.h>
-#include <net.h>
-#include <miiphy.h>
-#include <asm/io.h>
-#include <asm/arch/pc302.h>
-#include <asm/arch/emac.h>
-#include <asm/arch/utilities.h>
-
-/* Macros ------------------------------------------------------------------ */
-
-/*!
- * \brief Timeout value (in uS) for various EMAC operations
- */
-#define EMAC_TX_TIMEOUT             (1000)
-
-/*!
- * \brief Timeout value (in mS) for various PHY operations
- */
-#define EMAC_PHY_TIMEOUT            (2000)
-
-/*!
- * \brief Length (in bytes) of a MAC address
- */
-#define EMAC_LENGTH_OF_MAC_ADDRESS  (6)
-
-/*!
- * \brief Default receive and transmit ring lengths
- */
-#define EMAC_RX_NUM_DESCRIPTOR      (8)
-#define EMAC_TX_NUM_DESCRIPTOR      (2)
-#define EMAC_DESCRIPTOR_BUF_SIZE    (2048)
-
-/*!
- * \brief Values used in the emac_priv structure
- */
-#define EMAC_PHY_SPEED_10           (0)
-#define EMAC_PHY_SPEED_100          (1)
-#define EMAC_PHY_DUPLEX_HALF        (0)
-#define EMAC_PHY_DUPLEX_FULL        (1)
-#define EMAC_PHY_LINK_DOWN          (0)
-#define EMAC_PHY_LINK_UP            (1)
-#define EMAC_PHY_AUTO_NEG_COMPLETE  (1)
-
-/*!
- * \brief Macros used to read from, and write to, emac registers
- */
-#define EMAC_READ(__offset) \
-                 (*((volatile u32*)(PC302_EMAC_BASE + __offset)))
-
-#define EMAC_WRITE(__value, __offset) \
-                  (*((volatile u32*)(PC302_EMAC_BASE + __offset)) = __value)
-
-/*!
- * \brief Define the auto-negotiation advertisement register
- *        value.
- *
- * Note: This advertises 100 mpbs capability only.
- */
-#define PHY_AUTO_NEG_ADVERT_VALUE   (0x0181)
-
-/*!
- * \brief Align an item to a 64-bit boundary.
- */
-#define __align64b	    __attribute__((aligned(8)))
-
-/* Constants --------------------------------------------------------------- */
-
-/*!
- * \brief This structure defines the format of the Ethernet MAC
- *        Tx and Rx descriptors.
- */
-struct emac_dma_descriptor
-{
-    /*! Used to define the Rx/Tx buffer address */
-    unsigned int buffer;
-
-    /*! Used to contain the status of the Rx/Tx operation */
-    unsigned int status;
-};
-
-/*!
- * \brief This structure is used to hold private data for the network code
- */
-struct emac_priv
-{
-    /* Useful phy state */
-    unsigned int auto_negotiation;
-    unsigned int speed;
-    unsigned int duplex;
-    unsigned int link;
-
-    /* Rx descriptor count */
-    unsigned int rx_desc;
-
-    /* Tx descriptor count */
-    unsigned int tx_desc;
-};
-
-/*!
- * \brief Assign some memory for the Rx descriptors
- */
-static volatile struct
-emac_dma_descriptor __align64b rx_descriptor[EMAC_RX_NUM_DESCRIPTOR];
-
-/*!
- * \brief Assign some memory for the Tx descriptors
- */
-static volatile struct
-emac_dma_descriptor __align64b tx_descriptor[EMAC_TX_NUM_DESCRIPTOR];
-
-/*!
- * \brief Assign some memory for the Rx buffers
- * \n Note: The Rx buffers have to be 64 bit aligned otherwise
- *          very bad things happen.
- */
-static unsigned char __align64b
-rx_buffer[EMAC_RX_NUM_DESCRIPTOR][EMAC_DESCRIPTOR_BUF_SIZE];
-
-/* Types ------------------------------------------------------------------- */
-
-/* Prototypes--------------------------------------------------------------- */
-
-/*!
- *
- * \brief Read a register in a phy connected to the emac management port.
- *
- * \param phy_id The phy id of the phy to access
- * \param register_number The register to read from
- * \return The value read
- *
- */
-static unsigned short emac_mii_read(unsigned int phy_id,
-                                    unsigned int register_number);
-
-/*!
- *
- * \brief Write to a register in a phy connected to the emac management port.
- *
- * \param phy_id The phy id of the phy to access
- * \param register_number The register to write to
- * \param data The data to write
- *
- */
-static void emac_mii_write(unsigned int phy_id,
-                           unsigned int register_number,
-                           unsigned short data);
-
-#if defined (CONFIG_CMD_MII)
-static int pc302emac_miiphy_read(char *devname,
-                                 uchar addr,
-                                 uchar reg,
-                                 ushort *val);
-
-static int pc302emac_miiphy_write(char *devname,
-                                  uchar addr,
-                                  uchar reg,
-                                  ushort val);
-#endif /*CONFIG_CMD_MII */
-
-/*!
- *
- * \brief Initialise the emac mdio interface
- *
- */
-static void emac_init_mdio(void);
-
-/*!
- *
- * \brief Initialise the phy connected to the emac management port.
- *
- * \param dev Pointer to the eth_device structure
- *
- */
-static int emac_init_phy(struct eth_device *dev);
-
-/*!
- *
- * \brief Obtain the link status from the phy.
- *
- * \param dev Pointer to the eth_device structure
- *
- */
-static void emac_phy_get_link_status(struct eth_device *dev);
-
-/*!
- *
- * \brief Set up the MAC address in the emac.
- *
- * \param dev Pointer to the eth_device structure
- * \return Zero on success, non zero on error.
- *
- */
-static int emac_set_mac_addr(struct eth_device *dev);
-
-/*!
- *
- * \brief Initialise the emac registers.
- *
- * \param dev Pointer to the eth_device structure
- *
- */
-static void emac_startup(struct eth_device *dev);
-
-/*!
- *
- * \brief Initialise the emac buffer descriptors and phy.
- *
- * \param dev Pointer to the eth_device structure
- * \param bis Pointer to the board init structure
- * \return Zero on success, non zero on error
- *
- */
-static int emac_open(struct eth_device *dev, bd_t *bis);
-
-/*!
- *
- * \brief Receive a packet
- *
- * \param dev Pointer to the eth_device structure
- * \return Zero on success, non zero on error
- *
- */
-static int emac_rx_packet(struct eth_device *dev);
-
-/*!
- *
- * \brief Transmit a packet
- *
- * \param dev Pointer to the eth_device structure
- * \param packet Pointer to the packet data to transmit
- * \param length  Length (in bytes) of the packet to send
- * \return Zero on success, non zero on error
- *
- */
-static int emac_tx_packet(struct eth_device *dev,
-                          volatile void *packet,
-                          int length);
-
-/*!
- *
- * \brief Stop the emac
- *
- * \param dev Pointer to the eth_device structure
- *
- */
-static void emac_halt(struct eth_device *dev);
-
-/* Functions --------------------------------------------------------------- */
-
-static unsigned short emac_mii_read(unsigned int phy_id,
-                                    unsigned int register_number)
-{
-    unsigned int write_data = 0x60020000;
-    unsigned int phy_management_idle = 0;
-    unsigned short value_read = 0;
-
-    /* Mask input parameters */
-    phy_id &= EMAC_PHY_ID_MASK;
-    register_number &= EMAC_PHY_REG_MASK;
-
-    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
-                  (register_number << EMAC_PHY_REG_SHIFT));
-
-    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
-
-    /* Wait for the phy access to complete */
-    do
-    {
-        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
-        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
-    }
-    while(!phy_management_idle);
-
-    /* Read back the data obtained from the phy */
-    value_read = (unsigned short)EMAC_READ(EMAC_PHY_MAINTAIN_REG_OFFSET);
-    return(value_read);
-}
-
-static void emac_mii_write(unsigned int phy_id,
-                           unsigned int register_number,
-                           unsigned short data)
-{
-    unsigned int write_data = 0x50020000;
-    unsigned int phy_management_idle = 0;
-
-    /* Mask input parameters */
-    phy_id &= EMAC_PHY_ID_MASK;
-    register_number &= EMAC_PHY_REG_MASK;
-
-    write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
-                   (register_number << EMAC_PHY_REG_SHIFT) | data);
-    EMAC_WRITE(write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
-
-    /* Wait for the phy access to complete */
-    do
-    {
-        phy_management_idle = EMAC_READ(EMAC_NETWORK_STATUS_REG_OFFSET);
-        phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
-    }
-    while (!phy_management_idle);
-}
-
-#if defined (CONFIG_CMD_MII)
-static int pc302emac_miiphy_read(char *devname, uchar addr, uchar reg, ushort *val)
-{
-    /* Make sure the mdio bus is initialised */
-    emac_init_mdio();
-
-    /* Perform the mii bus read */
-    *val = emac_mii_read((unsigned int)addr,(unsigned int)reg);
-    return 0;
-}
-
-static int pc302emac_miiphy_write(char *devname, uchar addr, uchar reg, ushort val)
-{
-    /* Make sure the mdio bus is initialised */
-    emac_init_mdio();
-
-    /* Perform the mdio bis write */
-    emac_mii_write((unsigned int)addr,(unsigned int)reg, (unsigned short)val);
-    return 0;
-}
-#endif /*CONFIG_CMD_MII */
-
-static void emac_init_mdio(void)
-{
-    unsigned int network_control_register = 0;
-    unsigned int network_config_register = 0;
-
-    /* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
-    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
-    network_config_register &= ~(EMAC_MDC_CLOCK_DIV_MASK);
-    network_config_register |= EMAC_MDC_CLOCK_DIV_96;
-    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
-
-    /* Enable phy management */
-    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
-    network_control_register |= EMAC_MDIO_ENABLE;
-    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
-}
-
-static int emac_init_phy(struct eth_device *dev)
-{
-    struct emac_priv *priv = dev->priv;
-
-    unsigned int device_id = pc302_read_device_id();
-    unsigned int device_rev = pc302_read_device_revision();
-
-    /* Setup the MDIO bus for Phy communications */
-    emac_init_mdio ();
-
-    /* If we are running on PC3x2 Rev D silicon and we are using a
-     * Reduced MII (RMII) connected Ethernet Phy then we need the
-     * link speed to be 100 mbps.
-     */
-    if (((device_id == PC302_DEVICE_ID) || (device_id == PC312_DEVICE_ID)) &&
-         (device_rev == PC3X2_REV_D) &&
-         pc302_get_rmii_enabled())
-    {
-        /* Are we already set for 100 mpbs ? */
-        emac_phy_get_link_status(dev);
-        if (priv->speed == EMAC_PHY_SPEED_100)
-        {
-            /* No need to do anything */
-        }
-        else
-        {
-            /* Setup the phy auto-negotiation advertisement register */
-            emac_mii_write(CONFIG_PHY_ADDR, MII_ADVERTISE,
-                           PHY_AUTO_NEG_ADVERT_VALUE);
-
-            /* Re-start auto-negotiation */
-            emac_mii_write(CONFIG_PHY_ADDR, MII_BMCR,
-                           (BMCR_ANENABLE | BMCR_ANRESTART));
-
-            /* Allow some time for the auto-negotiation process to start */
-            udelay(100);
-        }
-    }
-
-    /* Get the phy status */
-    emac_phy_get_link_status(dev);
-
-    if (priv->link == EMAC_PHY_LINK_DOWN)
-    {
-        /* Oops, no valid link established, time to bail out */
-        printf("%s: Link down !\n", dev->name);
-        return (-1);
-    }
-    else
-    {
-        /* We have a valid link established
-         * so we can report the phy setup
-         */
-        printf("%s: Link up\n", dev->name);
-
-        if (priv->auto_negotiation == EMAC_PHY_AUTO_NEG_COMPLETE)
-        {
-            printf("%s: Auto-Negotiation complete\n", dev->name);
-        }
-
-        if (priv->speed == EMAC_PHY_SPEED_100)
-        {
-            printf("%s: 100Mbps\n", dev->name);
-        }
-        else
-        {
-            printf("%s: 10Mbps\n", dev->name);
-        }
-
-        if (priv->duplex == EMAC_PHY_DUPLEX_FULL)
-        {
-            printf("%s: Full-duplex\n", dev->name);
-        }
-        else
-        {
-            printf("%s: Half-duplex\n", dev->name);
-        }
-    }
-    return(0);
-}
-
-static void emac_phy_get_link_status(struct eth_device *dev)
-{
-    struct emac_priv *priv = dev->priv;
-    unsigned short phy_control = 0;
-    unsigned short phy_status = 0;
-    unsigned short ana = 0;
-    unsigned short anlpa = 0;
-    unsigned int timebase = 0;
-
-    /* Initialise the phy status parameters in the private data structure */
-    priv->auto_negotiation = ~(EMAC_PHY_AUTO_NEG_COMPLETE);
-    priv->link = EMAC_PHY_LINK_DOWN;
-    priv->speed = EMAC_PHY_SPEED_10;
-    priv->duplex = EMAC_PHY_DUPLEX_HALF;
-
-    /* Check to make sure the phy has auto-negotiation enabled */
-    phy_control = emac_mii_read(CONFIG_PHY_ADDR, MII_BMCR);
-    if (phy_control & BMCR_ANENABLE)
-    {
-        /* Auto-negotiation is enabled
-         * now need to check on auto-negotiation progress
-         */
-        phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
-        if (phy_status & BMSR_ANEGCAPABLE)
-        {
-            /* The phy is auto-negotiation capable */
-            timebase = get_timer(0);
-            do
-            {
-                phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
-                if (phy_status & BMSR_ANEGCOMPLETE)
-                {
-                    /* Auto-negotiation has completed */
-                    priv->auto_negotiation = EMAC_PHY_AUTO_NEG_COMPLETE;
-                    break;
-                }
-            }
-            while (get_timer (timebase) < EMAC_PHY_TIMEOUT);
-
-            if (phy_status & BMSR_LSTATUS)
-            {
-                /* We have a valid link established */
-                priv->link = EMAC_PHY_LINK_UP;
-            }
-            else
-            {
-                /* We do not have a valid link established */
-                priv->link = EMAC_PHY_LINK_DOWN;
-            }
-
-            /* Read the auto-negotiation advertisement register */
-            ana = emac_mii_read(CONFIG_PHY_ADDR, MII_ADVERTISE);
-
-            /* Read the auto-negotiation link partner ability register */
-            anlpa = emac_mii_read(CONFIG_PHY_ADDR, MII_LPA);
-
-            anlpa &= ana;
-
-            if (anlpa & (LPA_100FULL | LPA_100HALF))
-            {
-                priv->speed = EMAC_PHY_SPEED_100;
-
-                if (anlpa & LPA_100FULL)
-                {
-                    priv->duplex = EMAC_PHY_DUPLEX_FULL;
-                }
-            }
-            else
-            {
-                if (anlpa & LPA_10FULL)
-                {
-                    priv->duplex = EMAC_PHY_DUPLEX_FULL;
-                }
-            }
-        }
-    }
-
-    if (priv->auto_negotiation != EMAC_PHY_AUTO_NEG_COMPLETE)
-    {
-        /* Auto-negotiation is not enabled or failed for some reason
-         * so we just get phy setup from the status and control registers
-         */
-        phy_control = emac_mii_read(CONFIG_PHY_ADDR, MII_BMCR);
-        phy_status = emac_mii_read(CONFIG_PHY_ADDR, MII_BMSR);
-        if (phy_status & BMSR_LSTATUS)
-        {
-            priv->link = EMAC_PHY_LINK_UP;
-        }
-        else
-        {
-            priv->link = EMAC_PHY_LINK_DOWN;
-        }
-
-        if (phy_control & BMCR_SPEED100)
-        {
-            priv->speed = EMAC_PHY_SPEED_100;
-        }
-        else
-        {
-            priv->speed = EMAC_PHY_SPEED_10;
-        }
-
-        if (phy_control & BMCR_FULLDPLX)
-        {
-            priv->duplex = EMAC_PHY_DUPLEX_FULL;
-        }
-        else
-        {
-            priv->duplex = EMAC_PHY_DUPLEX_HALF;
-        }
-    }
-}
-
-static int emac_set_mac_addr(struct eth_device *dev)
-{
-    unsigned int mac_addr_bottom = 0;
-    unsigned int mac_addr_top = 0;
-
-    mac_addr_bottom = dev->enetaddr[0] |
-                      dev->enetaddr[1] << 8 |
-                      dev->enetaddr[2] << 16 |
-                      dev->enetaddr[3] << 24;
-
-    mac_addr_top = dev->enetaddr[4] |
-                   dev->enetaddr[5] << 8;
-
-    EMAC_WRITE(mac_addr_bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
-    EMAC_WRITE(mac_addr_top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
-
-    return 0;
-}
-
-static void emac_startup(struct eth_device *dev)
-{
-    struct emac_priv *priv = dev->priv;
-    unsigned int network_config_register = 0;
-    unsigned int network_control_register = 0;
-    unsigned int dma_config_register = 0;
-
-    /* Make sure the Tx & Rx are halted */
-    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
-    network_control_register &= ~(EMAC_RX_ENABLE | EMAC_TX_ENABLE);
-    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
-
-    /* Get the MAC address from environment variables
-     *
-     * Note: We do this again here just incase the MAC
-     * address has been changed since U-Boot has started up
-     */
-    eth_getenv_enetaddr("ethaddr", dev->enetaddr);
-
-    /* Set the hardware MAC address
-     *
-     * Note: We do this again here just incase the MAC
-     * address has been changed since U-Boot has started up
-     */
-    (void)emac_set_mac_addr(dev);
-
-    /* Setup the Rx Buffer Queue Base Address */
-    EMAC_WRITE((unsigned int)&rx_descriptor,
-                EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET);
-
-    /* Setup the Tx Buffer Queue Base Address */
-    EMAC_WRITE((unsigned int)&tx_descriptor,
-                EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET);
-
-    /* Setup the size of the DMA Receive Buffer */
-    dma_config_register = EMAC_READ(EMAC_DMA_CFG_REG_OFFSET);
-    dma_config_register &= ~(EMAC_DMA_RX_BUFFER_SIZE_MASK);
-    dma_config_register |= EMAC_DMA_RX_BUFFER_SIZE;
-    EMAC_WRITE(dma_config_register, EMAC_DMA_CFG_REG_OFFSET);
-
-    /* Setup the Network Configuration Register */
-    network_config_register = EMAC_READ(EMAC_NETWORK_CFG_REG_OFFSET);
-    network_config_register |= EMAC_64_BIT_AMBA_DATA_BUS_WITDH;
-    network_config_register |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
-    network_config_register |= EMAC_FCS_REMOVE;
-
-    if (priv->duplex == EMAC_PHY_DUPLEX_FULL)
-    {
-        network_config_register |= EMAC_FULL_DUPLEX;
-    }
-    else
-    {
-        network_config_register &= ~(EMAC_FULL_DUPLEX);
-    }
-
-    if (priv->speed == EMAC_PHY_SPEED_100)
-    {
-        network_config_register |= EMAC_SPEED_100_MBPS;
-    }
-    else
-    {
-        network_config_register &= ~(EMAC_SPEED_100_MBPS);
-    }
-
-    EMAC_WRITE(network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
-
-    /* Setup the Network Control Register */
-    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
-    network_control_register |= (EMAC_RX_ENABLE | EMAC_TX_ENABLE);
-    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
-}
-
-static int emac_open(struct eth_device *dev, bd_t *bis)
-{
-    struct emac_priv *priv = dev->priv;
-    unsigned int i = 0;;
-    unsigned int buffer_address = 0;
-    unsigned int ret = 0;
-
-    /* Initialise the Rx descriptor count */
-    priv->rx_desc = 0;
-
-    /* Initialise the Tx descriptor count */
-    priv->tx_desc = 0;
-
-    /* Initialise the Rx descriptors */
-    for (i = 0; i < EMAC_RX_NUM_DESCRIPTOR; i++)
-    {
-        buffer_address = (unsigned int)&rx_buffer[i][0];
-        if (i == (EMAC_RX_NUM_DESCRIPTOR - 1))
-        {
-            /* we are on the last descriptor entry */
-            buffer_address |= EMAC_RX_DESC_WRAP;
-        }
-        rx_descriptor[i].buffer = buffer_address;
-        rx_descriptor[i].status = 0;
-    }
-
-    /* Initialise the Tx descriptors */
-    for (i = 0; i < EMAC_TX_NUM_DESCRIPTOR; i++)
-    {
-        tx_descriptor[i].buffer = 0;
-        tx_descriptor[i].status = EMAC_TX_DESC_HOST_OWN;
-
-        if (i == (EMAC_TX_NUM_DESCRIPTOR - 1))
-        {
-            /* we are on the last descriptor entry */
-            tx_descriptor[i].status |= EMAC_TX_DESC_WRAP;
-        }
-    }
-
-    /* Check out the phy status */
-    ret = emac_init_phy(dev);
-    if (ret != 0)
-    {
-        /* Oops, we've had an error */
-        return(ret);
-    }
-
-    /* Initialise the emac registers */
-    emac_startup(dev);
-
-    return (0);
-}
-
-static int emac_rx_packet(struct eth_device *dev)
-{
-    struct emac_priv *priv = dev->priv;
-    unsigned int start_of_frame = 0;
-    unsigned int end_of_frame = 0;
-    unsigned int frame_error = 0;
-    unsigned int length = 0;
-    void * buffer_start;
-
-    if (rx_descriptor[priv->rx_desc].buffer & EMAC_RX_DESC_HOST_OWN)
-    {
-        /* We have some received data */
-
-        /* Make sure we have a whole frame */
-        start_of_frame = rx_descriptor[priv->rx_desc].status &
-                         EMAC_RX_DESC_START_OF_FRAME;
-        end_of_frame = rx_descriptor[priv->rx_desc].status &
-                       EMAC_RX_DESC_END_OF_FRAME;
-        if (start_of_frame && end_of_frame)
-        {
-            /* We have a complete frame */
-            length = rx_descriptor[priv->rx_desc].status &
-                     EMAC_RX_DESC_LENGTH_MASK;
-
-            /* Noodle the buffer start address for the higher level
-             * network stack. The start address should be 8 byte aligned,
-             * also bits 0 & 1 can be set by the emac, so these need to
-             * be masked out as well
-             */
-
-            buffer_start = (void *)
-                           (rx_descriptor[priv->rx_desc].buffer & 0xFFFFFFF8);
-
-            /* Send received packet to the higher network layers */
-            NetReceive(buffer_start, length);
-        }
-        else
-        {
-            /* Oops, not a complete frame */
-            frame_error++;
-        }
-
-        /* Reclaim the buffer just used */
-        rx_descriptor[priv->rx_desc].buffer &= ~(EMAC_RX_DESC_HOST_OWN);
-
-        /* Increment the Rx descriptor counter */
-        priv->rx_desc++;
-        if (priv->rx_desc == EMAC_RX_NUM_DESCRIPTOR)
-        {
-            /* We have exhausted the supply of Rx descriptors */
-            priv->rx_desc = 0;
-        }
-    }
-
-    if (frame_error)
-    {
-        printf ("frame error\n");
-        return (1);
-    }
-
-    return(0);
-}
-
-static int emac_tx_packet(struct eth_device *dev,
-                          volatile void *packet,
-                          int length)
-{
-    struct emac_priv *priv = dev->priv;
-    unsigned int i = 0;
-    unsigned int network_control_register = 0;
-
-    /* Set up the Tx descriptor */
-
-    /* Make sure the wrap bit is set for the last descriptor */
-    if (priv->tx_desc == (EMAC_TX_NUM_DESCRIPTOR - 1))
-    {
-        /* we are on the last descriptor entry */
-        tx_descriptor[priv->tx_desc].status = EMAC_TX_DESC_WRAP;
-    }
-
-    tx_descriptor[priv->tx_desc].status |= length & EMAC_TX_BUFFER_LENGTH_MASK;
-    tx_descriptor[priv->tx_desc].status |= EMAC_TX_LAST_BUFFER;
-    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_NO_CRC_APPEND);
-    tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_DESC_HOST_OWN);
-
-    /* Setup the Tx descriptor buffer */
-    tx_descriptor[priv->tx_desc].buffer = (unsigned int)packet;
-
-    /* Start the packet transmission */
-    network_control_register = EMAC_READ(EMAC_NETWORK_CTRL_REG_OFFSET);
-    network_control_register |= EMAC_START_TX;
-    EMAC_WRITE(network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
-
-    /* Wait for transmission to complete */
-    for (i = 0; i <= EMAC_TX_TIMEOUT; i++)
-    {
-	if (tx_descriptor[priv->tx_desc].status & EMAC_TX_DESC_HOST_OWN)
-        {
-            /* The emac has completed transmission */
-            break;
-        }
-	udelay(1);
-    }
-
-    /* Increment the Tx descriptor counter */
-    priv->tx_desc++;
-    if (priv->tx_desc == EMAC_TX_NUM_DESCRIPTOR)
-    {
-        /* We have exhausted the supply of Tx descriptors */
-        priv->tx_desc = 0;
-    }
-
-    /* We could add some error reporting in here, but no one cares anyway */
-    return(0);
-}
-
-static void emac_halt(struct eth_device *dev)
-{
-    unsigned int status_register = 0;
-
-    /* Halt the Tx & Rx */
-    EMAC_WRITE(0, EMAC_NETWORK_CTRL_REG_OFFSET);
-
-    /* Clear the statistics counters */
-    EMAC_WRITE(EMAC_CLEAR_STATS_REGISTERS, EMAC_NETWORK_CTRL_REG_OFFSET);
-
-    /* Clear the Tx status registers */
-    status_register = EMAC_READ(EMAC_TX_STATUS_REG_OFFSET);
-    EMAC_WRITE(status_register, EMAC_TX_STATUS_REG_OFFSET);
-
-    /* Clear the Rx status registers */
-    status_register = EMAC_READ(EMAC_RX_STATUS_REG_OFFSET);
-    EMAC_WRITE(status_register, EMAC_RX_STATUS_REG_OFFSET);
-}
-
-int pc302_eth_register(bd_t *bis)
-{
-    struct eth_device *dev = NULL;
-    struct emac_priv *priv = NULL;
-
-    /* Create some storage for useful structures */
-    dev = (struct eth_device *) malloc(sizeof (*dev));
-    if (dev == NULL)
-    {
-        /* Oops, no memory available */
-        return -ENOMEM;
-    }
-
-    priv = (struct emac_priv *) malloc(sizeof (*priv));
-    if (priv == NULL)
-    {
-        /* Oops, no memory available */
-        free (dev);
-        return -ENOMEM;
-    }
-
-    dev->priv = priv;
-
-    /* Reset the private data */
-    memset(priv, 0, sizeof(struct emac_priv));
-
-    /* Define our name */
-    sprintf(dev->name, "pc302_emac");
-
-    dev->init = emac_open;
-    dev->recv = emac_rx_packet;
-    dev->send = emac_tx_packet;
-    dev->halt = emac_halt;
-    dev->write_hwaddr = emac_set_mac_addr;
-
-    /* Register our emac driver with the networking environment */
-    (void)eth_register(dev);
-
-    /* Get the MAC address from environment variables */
-    eth_getenv_enetaddr("ethaddr", dev->enetaddr);
-
-    /* Set the hardware MAC address */
-    (void)emac_set_mac_addr(dev);
-
-#if defined (CONFIG_CMD_MII)
-    miiphy_register(dev->name, pc302emac_miiphy_read, pc302emac_miiphy_write);
-#endif
-
-    return 0;
-}
-
-#endif /* CONFIG_DW_EMAC */
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/gpio.c b/arch/arm/cpu/arm926ejs/pc3xx/gpio.c
deleted file mode 100644
index 72e4305..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/gpio.c
+++ /dev/null
@@ -1,1075 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*
- * Copyright (c) 2009-2011 Picochip Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * All enquiries to support@picochip.com
- */
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-#include <asm/errno.h>
-#include <asm/arch/utilities.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/mux.h>
-#include <asm/arch/pc3xxgpio.h>
-
-/* Macros ------------------------------------------------------------------ */
-#define __iomem
-#define _ioa (void __iomem *)
-#define readl(addr) (pc302_read_from_register((unsigned int)addr))
-#define writel(val, addr) (pc302_write_to_register((unsigned int)addr, val))
-
-/* The number of gpio pins that this drover can handle */
-#define ARCH_NR_GPIOS 128
-
-#define BITS_PER_BYTE 8
-#define BITS_TO_LONGS(nr) \
-        DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
-
-#define DECLARE_BITMAP(name,bits) \
-        unsigned long name[BITS_TO_LONGS(bits)]
-
-/* Constants --------------------------------------------------------------- */
-/**
- * struct gpio_chip - abstract a GPIO controller
- * @label: for diagnostics
- * @request: optional hook for chip-specific activation, such as
- *	enabling module power and clock; may sleep
- * @free: optional hook for chip-specific deactivation, such as
- *	disabling module power and clock; may sleep
- * @direction_input: configures signal "offset" as input, or returns error
- * @get: returns value for signal "offset"; for output signals this
- *	returns either the value actually sensed, or zero
- * @direction_output: configures signal "offset" as output, or returns error
- * @set: assigns output value for signal "offset"
- * @base: identifies the first GPIO number handled by this chip; or, if
- *	negative during registration, requests dynamic ID allocation.
- * @ngpio: the number of GPIOs handled by this controller; the last GPIO
- *	handled is (base + ngpio - 1).
- * @names: if set, must be an array of strings to use as alternative
- *      names for the GPIOs in this chip. Any entry in the array
- *      may be NULL if there is no alias for the GPIO, however the
- *      array must be @ngpio entries long.
- *
- * A gpio_chip can help platforms abstract various sources of GPIOs so
- * they can all be accessed through a common programing interface.
- * Example sources would be SOC controllers, FPGAs, multifunction
- * chips, dedicated GPIO expanders, and so on.
- *
- * Each chip controls a number of signals, identified in method calls
- * by "offset" values in the range 0..(@ngpio - 1).  When those signals
- * are referenced through calls like gpio_get_value(gpio), the offset
- * is calculated by subtracting @base from the gpio number.
- */
-struct gpio_chip {
-	const char		*label;
-
-	int			(*request)(struct gpio_chip *chip,
-						unsigned offset);
-	void			(*free)(struct gpio_chip *chip,
-						unsigned offset);
-
-	int			(*direction_input)(struct gpio_chip *chip,
-						unsigned offset);
-	int			(*get)(struct gpio_chip *chip,
-						unsigned offset);
-	int			(*direction_output)(struct gpio_chip *chip,
-						unsigned offset, int value);
-	void			(*set)(struct gpio_chip *chip,
-						unsigned offset, int value);
-
-	int			base;
-	u16			ngpio;
-	char			**names;
-};
-
-DECLARE_BITMAP(pin_status, ARCH_NR_GPIOS);
-
-struct gpio_desc {
-	struct gpio_chip	*chip;
-};
-
-static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
-
-/* Functions --------------------------------------------------------------- */
-static int
-armgpio_request(struct gpio_chip *chip,
-		unsigned offset)
-{
-	enum mux_setting mux;
-
-	if (test_and_set_bit(offset + chip->base, pin_status))
-		return -EBUSY;
-
-	/* Check the pin has been correctly multiplexed. */
-	mux = pc3xx_get_pin_mux(offset + chip->base);
-	if (!(mux & (MUX_ARM | MUX_UNMUXED))) {
-		/* The pin has an inconsistent mux setting. */
-		printf("attempt to request armgpio%u which is not correctly multiplexed\n",
-			   chip->base + offset);
-		test_and_clear_bit(offset + chip->base, pin_status);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static void
-armgpio_free(struct gpio_chip *chip,
-	     unsigned offset)
-{
-	test_and_clear_bit(offset + chip->base, pin_status);
-}
-
-#define GPIO_SW_PORT_A_EXT_REG_OFFSET	GPIO_EXT_PORT_A_REG_OFFSET
-#define GPIO_SW_PORT_B_EXT_REG_OFFSET	GPIO_EXT_PORT_B_REG_OFFSET
-#define GPIO_SW_PORT_D_EXT_REG_OFFSET	GPIO_EXT_PORT_D_REG_OFFSET
-
-static inline int
-armgpio_block_nr(unsigned gpio_nr)
-{
-	if (!is_pc3x3()) {
-		/*
-		 * PC3X2 has GPIOs numbered in non contiguous blocks.
-		 */
-		if (gpio_nr < PC302_GPIO_PIN_ARM_8)
-			return gpio_nr - PC302_GPIO_PIN_ARM_0;
-		else
-			return gpio_nr - PC302_GPIO_PIN_ARM_8 + 8;
-	} else {
-		/*
-		 * For PC3X3, ARM GPIO's are numbered from 0->MAX.
-		 */
-		return gpio_nr;
-	}
-
-	return -ENXIO;
-}
-
-#define __ARMGPIO_REG(_gpio_base, _reg)					    \
-	({								    \
-		void __iomem *ret = NULL;				    \
-		int __gpio_nr = armgpio_block_nr(_gpio_base);		    \
-		if (__gpio_nr < 8)					    \
-			ret = _ioa(PC302_GPIO_BASE +			    \
-				GPIO_SW_PORT_A_##_reg##_REG_OFFSET);	    \
-		else if (__gpio_nr < 24)				    \
-			ret = _ioa(PC302_GPIO_BASE +			    \
-				GPIO_SW_PORT_B_##_reg##_REG_OFFSET);	    \
-		else							    \
-			ret = _ioa(PC302_GPIO_BASE +			    \
-				GPIO_SW_PORT_D_##_reg##_REG_OFFSET);	    \
-		ret;							    \
-	})
-
-#define ARMGPIO_DR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DR)
-#define ARMGPIO_DDR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DDR)
-#define ARMGPIO_CTL(_gpio_base)	    __ARMGPIO_REG(_gpio_base, CTL)
-#define ARMGPIO_EXT(_gpio_base)	    __ARMGPIO_REG(_gpio_base, EXT)
-
-static inline unsigned
-armgpio_offset(unsigned offset)
-{
-	if (is_pc3x3()) {
-		/*
-		 * The arm gpios in PC3x3 are controlled via three sets of
-		 * registers. The register addressing is already taken care
-		 * of by the __ARMGPIO_REG macro, this takes care of the bit
-		 * offsets within each register.
-		 */
-		if (offset < 8) /* GPIO Port A*/
-			return offset;
-		else if (offset < 24) /* GPIO Port B */
-			return offset - 8;
-		else /* GPIO Port D */
-			return offset - 24;
-	}
-
-	return offset;
-}
-
-static int
-armgpio_direction_input(struct gpio_chip *chip,
-			unsigned offset)
-{
-	void __iomem *ddr = ARMGPIO_DDR(chip->base + offset);
-	void __iomem *cr = ARMGPIO_CTL(chip->base + offset);
-	unsigned long val, bit_offset = armgpio_offset(offset);
-
-	/* Mark the pin as an output. */
-	val = readl(ddr);
-	val &= ~(1 << bit_offset);
-        writel(val, ddr);
-
-	/* Set the pin as software controlled. */
-	val = readl(cr);
-	val &= ~(1 << bit_offset);
-        writel(val, cr);
-
-	return 0;
-}
-
-static void
-armgpio_set(struct gpio_chip *chip,
-	    unsigned offset,
-	    int value);
-
-static int
-armgpio_direction_output(struct gpio_chip *chip,
-			 unsigned offset,
-			 int value)
-{
-	void __iomem *ddr = ARMGPIO_DDR(chip->base + offset);
-	void __iomem *cr = ARMGPIO_CTL(chip->base + offset);
-	unsigned long val, bit_offset = armgpio_offset(offset);
-
-	/* Set the value first so we don't glitch. */
-	armgpio_set(chip, offset, value);
-
-	/* Mark the pin as an output. */
-	val = readl(ddr);
-	val |= (1 << bit_offset);
-        writel(val, ddr);
-
-	/* Set the pin as software controlled. */
-	val = readl(cr);
-	val &= ~(1 << bit_offset);
-	writel(val, cr);
-
-	return 0;
-}
-
-static int
-armgpio_get(struct gpio_chip *chip,
-	    unsigned offset)
-{
-	void __iomem *ext = ARMGPIO_EXT(chip->base + offset);
-	unsigned long bit_offset = armgpio_offset(offset);
-
-	return !!(readl(ext) & (1 << bit_offset));
-}
-
-static void
-armgpio_set(struct gpio_chip *chip,
-	    unsigned offset,
-	    int value)
-{
-	void __iomem *dr = ARMGPIO_DR(chip->base + offset);
-	unsigned long val, bit_offset = armgpio_offset(offset);
-
-	val = readl(dr);
-	val &= ~(1 << bit_offset);
-	val |= (!!value << bit_offset);
-	writel(val, dr);
-}
-
-/*
- * PC3X2 ARM GPIO chips. One chip per port.
- */
-#ifdef CONFIG_PICOCHIP_PC3X2
-char *pc3x2_armgpio_lo_pins[] = {
-	"arm0",
-	"arm1",
-	"arm2",
-	"arm3",
-	"arm4",
-	"arm5",
-	"arm6",
-	"arm7",
-};
-
-static struct gpio_chip pc3x2_arm_gpio_lo = {
-	.label		    = "armgpio_lo",
-	.request	    = armgpio_request,
-	.free		    = armgpio_free,
-	.direction_input    = armgpio_direction_input,
-	.direction_output   = armgpio_direction_output,
-	.get		    = armgpio_get,
-	.set		    = armgpio_set,
-	.base		    = PC302_GPIO_PIN_ARM_0,
-	.ngpio		    = ARRAY_SIZE(pc3x2_armgpio_lo_pins),
-	.names		    = pc3x2_armgpio_lo_pins,
-};
-
-char *pc3x2_armgpio_shared_pins[] = {
-	"arm8",
-	"arm9",
-	"arm10",
-	"arm11",
-	"arm12",
-	"arm13",
-	"arm14",
-	"arm15",
-};
-
-static struct gpio_chip pc3x2_arm_gpio_shared = {
-	.label		    = "armgpio_shared",
-	.request	    = armgpio_request,
-	.free		    = armgpio_free,
-	.direction_input    = armgpio_direction_input,
-	.direction_output   = armgpio_direction_output,
-	.get		    = armgpio_get,
-	.set		    = armgpio_set,
-	.ngpio		    = ARRAY_SIZE(pc3x2_armgpio_shared_pins),
-	.base		    = PC302_GPIO_PIN_ARM_8,
-	.names		    = pc3x2_armgpio_shared_pins,
-};
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-
-#ifdef CONFIG_PICOCHIP_PC3X3
-/*
- * PC3X3 ARM GPIO chip.
- */
-char *pc3x3_armgpio_pins[] = {
-	"arm0",
-	"arm1",
-	"arm2",
-	"arm3",
-	"arm4",
-	"arm5",
-	"arm6",
-	"arm7",
-	"arm8",
-	"arm9",
-	"arm10",
-	"arm11",
-	"arm12",
-	"arm13",
-	"arm14",
-	"arm15",
-	"arm16",
-	"arm17",
-	"arm18",
-	"arm19",
-	"arm20",
-	"arm21",
-	"arm22",
-	"arm23",
-	"arm24",
-	"arm25",
-	"arm26",
-	"arm27",
-	"arm28",
-	"arm29",
-	"arm30",
-	"arm31",
-	"arm32",
-	"arm33",
-	"arm34",
-	"arm35",
-	"arm36",
-	"arm37",
-	"arm38",
-	"arm39",
-	"arm40",
-	"arm41",
-	"arm42",
-	"arm43",
-	"arm44",
-	"arm45",
-	"arm46",
-	"arm47",
-	"arm48",
-	"arm49",
-	"arm50",
-	"arm51",
-        "arm52",
-        "arm53",
-};
-
-static struct gpio_chip pc3x3_arm_gpio = {
-	.label		    = "armgpio",
-	.request	    = armgpio_request,
-	.free		    = armgpio_free,
-	.direction_input    = armgpio_direction_input,
-	.direction_output   = armgpio_direction_output,
-	.get		    = armgpio_get,
-	.set		    = armgpio_set,
-	.base		    = PC3X3_GPIO_PIN_ARM_0,
-	.ngpio		    = ARRAY_SIZE(pc3x3_armgpio_pins),
-	.names		    = pc3x3_armgpio_pins,
-};
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-
-/* The base address of SD-GPIO config registers in the AXI2Pico. */
-#define PC302_GPIO_SD_PIN_CONFIG_BASE		0x9800
-/* The base address of SD-GPIO analogue value registers in the AXI2Pico. */
-#define PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE	0x9801
-/* The base address of SD-GPIO analogue rate registers in the AXI2Pico. */
-#define PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE	0x9802
-/* The address of the control value register in the AXI2Pico. */
-#define PC302_GPIO_SD_CONTROL_VAL_REG		0x9882
-/* The address of the control value high register in the AXI2Pico (pc3x3). */
-#define PC302_GPIO_SD_CONTROL_VAL_HI_REG	0x9883
-/* The address of the output value register in the AXI2Pico. */
-#define PC302_GPIO_SD_OUTPUT_VAL_REG		0x9884
-/* The address of the output value high register in the AXI2Pico (pc3x3). */
-#define PC302_GPIO_SD_OUTPUT_HI_VAL_REG		0x9885
-/* The address of the input value register in the AXI2Pico. */
-#define PC302_GPIO_SD_INPUT_VAL_REG		0x9880
-/* The address of the input value high register in the AXI2Pico (pc3x3). */
-#define PC302_GPIO_SD_INPUT_VAL_HI_REG		0x9880
-/* The address of the sleep register in the AXI2Pico. */
-#define PC302_AXI2PICO_SLEEP_REG		0xA060
-/* The spacing between SD-GPIO config registers. */
-#define PC302_GPIO_SD_PIN_CONFIG_SPACING	4
-/* Control source bit. */
-#define PC302_GPIO_SD_CONFIG_CS_MASK		~(1 << 15)
-/* Analogue not digital bit. */
-#define PC302_GPIO_SD_CONFIG_AND		(1 << 14)
-/* The mask for analogue converter size in the config register. */
-#define PC302_GPIO_SD_CONV_SZ_MASK		0xF
-/* Soft reset lock bit. */
-#define PC302_GPIO_SD_CONFIG_SR_LOCK		(1 << 13)
-/* PC302 AXI2Pico CAEID. */
-#define PC302_AXI2PICO_CAEID			(0x9000)
-
-/*
- * Get the address of a config register for a SD-GPIO pin.
- *
- * @_n The SD-GPIO pin number.
- *
- * Returns the base address of the register.
- */
-#define PC302_GPIO_SD_PIN_CONFIG(_n) \
-    PC302_GPIO_SD_PIN_CONFIG_BASE + ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
-
-/*
- * Get the address of a analogue rate register for a SD-GPIO pin.
- *
- * @_n The SD-GPIO pin number.
- *
- * Returns the base address of the register.
- */
-#define PC302_GPIO_SD_PIN_ANALOGUE_RATE(_n) \
-    PC302_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
-        ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
-
-/*
- * Get the address of a analogue value register for a SD-GPIO pin.
- *
- * @_n The SD-GPIO pin number.
- *
- * Returns the base address of the register.
- */
-#define PC302_GPIO_SD_PIN_ANALOGUE_VAL(_n) \
-    PC302_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
-        ((_n) * PC302_GPIO_SD_PIN_CONFIG_SPACING)
-
-static int
-sdgpio_reset_config(unsigned block_pin,
-		    int value)
-{
-	int ret;
-	u16 data;
-
-	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-				  PC302_GPIO_SD_PIN_CONFIG(block_pin),
-				  &data, 1);
-	if (1 != ret) {
-		printf("failed to read config register for SDGPIO pin %u\n",
-		       block_pin );
-		return -EIO;
-	}
-
-	if (value)
-		data |= PC302_GPIO_SD_CONFIG_SR_LOCK;
-	else
-		data &= ~PC302_GPIO_SD_CONFIG_SR_LOCK;
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-				   PC302_GPIO_SD_PIN_CONFIG(block_pin),
-				   &data, 1);
-	if (1 != ret) {
-		printf("failed to write config register for SDGPIO pin %u\n",
-		       block_pin );
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static inline int
-sdgpio_block_nr(unsigned gpio_nr)
-{
-	if (is_pc3x3()) {
-		return gpio_nr - PC3X3_GPIO_PIN_SDGPIO_0;
-	} else {
-		if (gpio_nr >= PC302_GPIO_PIN_SDGPIO_0 &&
-		    gpio_nr < PC302_GPIO_PIN_SDGPIO_7)
-			return gpio_nr - PC302_GPIO_PIN_SDGPIO_0;
-		else
-			return (gpio_nr - PC302_GPIO_PIN_SDGPIO_8) + 8;
-	}
-}
-
-static int
-sdgpio_request(struct gpio_chip *chip,
-	       unsigned offset)
-{
-	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
-	enum mux_setting mux;
-
-	if (test_and_set_bit(offset + chip->base, pin_status))
-		return -EBUSY;
-
-	if (sdgpio_reset_config(block_pin, 1)) {
-		test_and_clear_bit(offset + chip->base, pin_status);
-		return -EIO;
-	}
-
-	/* Check the pin has been correctly multiplexed. */
-	mux = pc3xx_get_pin_mux(offset + chip->base);
-	if (!(mux & (MUX_SD | MUX_UNMUXED))) {
-		/* The pin has an inconsistent mux setting. */
-		printf("attempt to request sdgpio%u which is not correctly multiplexed\n",
-			   block_pin);
-		test_and_clear_bit(offset + chip->base, pin_status);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static void
-sdgpio_free(struct gpio_chip *chip,
-	    unsigned offset)
-{
-	test_and_clear_bit(offset + chip->base, pin_status);
-	pc3xx_gpio_configure_dac(chip->base + offset, 0, 0);
-}
-
-/*
- * Create a map of which pins are analogue and not digital. We have a separate
- * function for configuring pins as analogue. When we set analogue pins, we
- * don't treat the int parameter as a boolean anymore.
- */
-DECLARE_BITMAP(a_not_d_map, ARCH_NR_GPIOS);
-
-static int
-sdgpio_get_digital_out_status(u32 *v)
-{
-	u16 data[2] = { 0, 0 };
-
-	if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-				PC302_GPIO_SD_OUTPUT_VAL_REG, &data[0], 1))
-		return -EIO;
-
-	if (is_pc3x3()) {
-		if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-					PC302_GPIO_SD_OUTPUT_HI_VAL_REG,
-					&data[1], 1))
-			return -EIO;
-	}
-
-	*v = data[0] | (data[1] << 16);
-
-	return 0;
-}
-
-static int
-sdgpio_set_digital_out_status(u32 v)
-{
-	u16 data[2] = { (u16)(v & 0xFFFF), (u16)((v >> 16) & 0xFFFF) };
-
-	if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-				PC302_GPIO_SD_OUTPUT_VAL_REG, &data[0], 1))
-		return -EIO;
-
-	if (is_pc3x3()) {
-		if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-					PC302_GPIO_SD_OUTPUT_HI_VAL_REG,
-					&data[1], 1))
-			return -EIO;
-	}
-
-	return 0;
-}
-
-static void
-sdgpio_set(struct gpio_chip *chip,
-	   unsigned offset,
-	   int value)
-{
-	int ret;
-	u16 data;
-	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
-
-	if (!test_bit(chip->base + offset, a_not_d_map)) {
-		u32 status;
-
-		if (sdgpio_get_digital_out_status(&status)) {
-			printf("failed to read SDGPIO output value reg\n");
-			return;
-		}
-
-		status &= ~(1 << block_pin);
-		status |= (!!value) << block_pin;
-
-		if (sdgpio_set_digital_out_status(status)) {
-			printf("failed to output control register for SDGPIO pin %u\n",
-			       block_pin);
-			return;
-		}
-	} else {
-		/* Analogue mode */
-		data = (u16)value;
-		ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-				PC302_GPIO_SD_PIN_ANALOGUE_VAL(block_pin),
-				&data, 1);
-		if (1 != ret) {
-			printf("failed to write analogue value register for SDGPIO pin %u\n",
-			       block_pin);
-			return;
-		}
-	}
-}
-
-static int
-sdgpio_get_digital_in_status(u32 *v)
-{
-	u16 data[2] = { 0, 0 };
-
-	if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-				PC302_GPIO_SD_INPUT_VAL_REG, &data[0], 1))
-		return -EIO;
-
-	if (is_pc3x3()) {
-		if (1 != axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-					PC302_GPIO_SD_INPUT_VAL_HI_REG,
-					&data[1], 1))
-			return -EIO;
-	}
-
-	*v = data[0] | (data[1] << 16);
-
-	return 0;
-}
-
-static int
-sdgpio_get(struct gpio_chip *chip,
-	   unsigned offset)
-{
-	int ret;
-	u16 data;
-	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
-
-	if (!test_bit(chip->base + offset, a_not_d_map)) {
-		u32 status;
-
-		if (sdgpio_get_digital_in_status(&status))
-			return -EIO;
-
-		return !!(status & (1 << block_pin));
-	} else {
-		/* Analogue mode */
-		ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-				PC302_GPIO_SD_PIN_ANALOGUE_VAL(block_pin),
-				&data, 1);
-		if (1 != ret) {
-			printf("failed to read the analogue value register for SDGPIO pin %u\n",
-			       block_pin);
-			return -EIO;
-		}
-
-		return (int)data;
-	}
-}
-
-static int
-sdgpio_set_direction(unsigned block_pin,
-		     int input)
-{
-	int ret;
-	u16 data;
-
-	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
-	if (1 != ret) {
-		printf("failed to read config register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	data &= PC302_GPIO_SD_CONFIG_CS_MASK;
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
-	if (1 != ret) {
-		printf("failed to write config register for SDGPIO pin %u\n",
-		       block_pin );
-		return -EIO;
-	}
-
-	/* Configure the pin to drive or not drive the output as appropriate. */
-	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
-	if (1 != ret) {
-		printf("failed to read SDGPIO control value register\n");
-		return -EIO;
-	}
-
-	if (input)
-		data &= ~(1 << block_pin);
-	else
-		data |= (1 << block_pin);
-
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
-	if (1 != ret) {
-		printf("failed to write control value register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static int
-sdgpio_direction_output(struct gpio_chip *chip,
-			unsigned offset,
-			int value)
-{
-	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
-	int ret = sdgpio_set_direction(block_pin, 0);
-
-	if (ret)
-		return ret;
-
-	sdgpio_set(chip, offset, value);
-
-	return 0;
-}
-
-static int
-sdgpio_direction_input(struct gpio_chip *chip,
-		       unsigned offset)
-{
-	unsigned block_pin = sdgpio_block_nr(chip->base + offset);
-
-	return sdgpio_set_direction(block_pin, 1);
-}
-
-int
-pc3xx_gpio_configure_dac(unsigned gpio,
-                         u8 converter_size,
-                         u16 analogue_rate)
-{
-	int ret;
-	u16 data;
-	unsigned block_pin = sdgpio_block_nr(gpio);
-
-	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
-	if (1 != ret) {
-		printf("failed to read config register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	data &= PC302_GPIO_SD_CONFIG_CS_MASK;
-	data &= ~PC302_GPIO_SD_CONV_SZ_MASK;
-	if (!analogue_rate && !converter_size)
-		data &= ~PC302_GPIO_SD_CONFIG_AND;
-	else
-		data |= PC302_GPIO_SD_CONFIG_AND;
-	data |= (converter_size & PC302_GPIO_SD_CONV_SZ_MASK);
-
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_PIN_CONFIG(block_pin), &data, 1);
-	if (1 != ret) {
-		printf("failed to write config register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	/* Configure the pin to drive the output. */
-	ret = axi2cfg_config_read(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
-	if (1 != ret) {
-		printf("failed to read SDGPIO control value register\n");
-		return -EIO;
-	}
-
-	data |= (1 << block_pin);
-
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_CONTROL_VAL_REG, &data, 1);
-	if (1 != ret) {
-		printf("failed to write control value register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	/* Write the analogue rate register */
-	data = analogue_rate;
-	ret = axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-			PC302_GPIO_SD_PIN_ANALOGUE_RATE(block_pin), &data, 1);
-	if (1 != ret) {
-		printf("failed to write analogue rate register for SDGPIO pin %u\n",
-		       block_pin);
-		return -EIO;
-	}
-
-	if (analogue_rate || converter_size)
-		test_and_set_bit(gpio, a_not_d_map);
-	else
-		test_and_clear_bit(gpio, a_not_d_map);
-
-	return 0;
-}
-
-/*
- * PC3X2 SD-GPIO.
- */
-#ifdef CONFIG_PICOCHIP_PC3X2
-char *sdgpio_lo_pins[] = {
-	"sdgpio0",
-	"sdgpio1",
-	"sdgpio2",
-	"sdgpio3",
-	"sdgpio4",
-	"sdgpio5",
-	"sdgpio6",
-	"sdgpio7",
-};
-
-static struct gpio_chip pc3x2_sd_gpio_lo = {
-	.label		    = "sdpio_lo",
-	.request	    = sdgpio_request,
-	.free		    = sdgpio_free,
-	.direction_input    = sdgpio_direction_input,
-	.direction_output   = sdgpio_direction_output,
-	.get		    = sdgpio_get,
-	.set		    = sdgpio_set,
-	.ngpio		    = ARRAY_SIZE(sdgpio_lo_pins),
-	.base		    = PC302_GPIO_PIN_SDGPIO_0,
-	.names		    = sdgpio_lo_pins,
-};
-
-char *sdgpio_shared_pins[] = {
-	"sdgpio8",
-	"sdgpio9",
-	"sdgpio10",
-	"sdgpio11",
-	"sdgpio12",
-	"sdgpio13",
-	"sdgpio14",
-	"sdgpio15",
-};
-
-static struct gpio_chip pc3x2_sd_gpio_shared = {
-	.label		    = "sdgpio_shared",
-	.request	    = sdgpio_request,
-	.free		    = sdgpio_free,
-	.direction_input    = sdgpio_direction_input,
-	.direction_output   = sdgpio_direction_output,
-	.get		    = sdgpio_get,
-	.set		    = sdgpio_set,
-	.ngpio		    = ARRAY_SIZE(sdgpio_shared_pins),
-	.base		    = PC302_GPIO_PIN_SDGPIO_8,
-	.names		    = sdgpio_shared_pins,
-};
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-
-/*
- * PC3X3 SD-GPIO.
- */
-#ifdef CONFIG_PICOCHIP_PC3X3
-char *pc3x3_sdgpio_pins[] = {
-	"sdgpio0",
-	"sdgpio1",
-	"sdgpio2",
-	"sdgpio3",
-	"sdgpio4",
-	"sdgpio5",
-	"sdgpio6",
-	"sdgpio7",
-	"sdgpio8",
-	"sdgpio9",
-	"sdgpio10",
-	"sdgpio11",
-	"sdgpio12",
-	"sdgpio13",
-	"sdgpio14",
-	"sdgpio15",
-	"sdgpio16",
-	"sdgpio17",
-	"sdgpio18",
-	"sdgpio19",
-	"sdgpio20",
-	"sdgpio21",
-	"sdgpio22",
-	"sdgpio23",
-};
-
-static struct gpio_chip pc3x3_sd_gpio = {
-	.label		    = "sdgpio",
-	.request	    = sdgpio_request,
-	.free		    = sdgpio_free,
-	.direction_input    = sdgpio_direction_input,
-	.direction_output   = sdgpio_direction_output,
-	.get		    = sdgpio_get,
-	.set		    = sdgpio_set,
-	.ngpio		    = ARRAY_SIZE(pc3x3_sdgpio_pins),
-	.base		    = PC3X3_GPIO_PIN_SDGPIO_0,
-	.names		    = pc3x3_sdgpio_pins,
-};
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-
-static struct gpio_chip *pc3x2_chips[] = {
-#ifdef CONFIG_PICOCHIP_PC3X2
-	&pc3x2_arm_gpio_lo,
-	&pc3x2_arm_gpio_shared,
-	&pc3x2_sd_gpio_lo,
-	&pc3x2_sd_gpio_shared,
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-};
-
-static struct gpio_chip *pc3x3_chips[] = {
-#ifdef CONFIG_PICOCHIP_PC3X3
-	&pc3x3_arm_gpio,
-	&pc3x3_sd_gpio,
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-};
-
-/* Public API -------------------------------------------------------------- */
-
-int
-pc3xx_gpio_init(void)
-{
-	int num_chips, i, ret = 0, id;
-	u16 data = 0;
-	struct gpio_chip **all_chips, *chip;
-
-	/*
-	 * Make sure that the AXI2Pico is awake for the SDGPIO transactions.
-	 */
-	if (1 != axi2cfg_config_write(PC302_AXI2PICO_CAEID,
-				      PC302_AXI2PICO_SLEEP_REG, &data, 1)) {
-		printf("unable to wake axi2pico\n");
-		return -EIO;
-	}
-
-	if (is_pc3x3()) {
-		num_chips = ARRAY_SIZE(pc3x3_chips);
-		all_chips = pc3x3_chips;
-	} else {
-		num_chips = ARRAY_SIZE(pc3x2_chips);
-		all_chips = pc3x2_chips;
-	}
-
-        /* Populate the gpio_desc[] array */
-	for (chip = all_chips[0], i = 0; i < num_chips; ++i, ++chip) {
-                int base = chip->base;
-                for (id = base; id < base + chip->ngpio; id++) {
-			gpio_desc[id].chip = chip;
-		}
-	}
-
-	return ret;
-}
-
-int
-pc3xx_gpio_request(unsigned gpio)
-{
-    	struct gpio_desc	*desc;
-	struct gpio_chip	*chip;
-        int			status = -EINVAL;
-
-        desc = &gpio_desc[gpio];
-	chip = desc->chip;
-
-        if (chip == NULL)
-		goto done;
-
-        if (chip->request) {
-		status = chip->request(chip, gpio - chip->base);
-	}
-done:
-        return status;
-}
-
-void
-pc3xx_gpio_free(unsigned gpio)
-{
-	struct gpio_desc	*desc;
-	struct gpio_chip	*chip;
-
-        desc = &gpio_desc[gpio];
-	chip = desc->chip;
-
-        if (chip->free) {
-		chip->free(chip, gpio - chip->base);
-	}
-}
-
-int
-pc3xx_gpio_direction_input(unsigned gpio)
-{
-    	struct gpio_chip	*chip;
-	struct gpio_desc	*desc = &gpio_desc[gpio];
-	int			status = -EINVAL;
-        chip = desc->chip;
-	if (!chip || !chip->get || !chip->direction_input)
-		goto fail;
-	gpio -= chip->base;
-	if (gpio >= chip->ngpio)
-		goto fail;
-
-        status = chip->direction_input(chip, gpio);
-
-fail:
-        return status;
-}
-
-int
-pc3xx_gpio_direction_output(unsigned gpio,
-                            int value)
-
-{
-        struct gpio_chip	*chip;
-	struct gpio_desc	*desc = &gpio_desc[gpio];
-	int			status = -EINVAL;
-
-        chip = desc->chip;
-	if (!chip || !chip->set || !chip->direction_output)
-		goto fail;
-	gpio -= chip->base;
-	if (gpio >= chip->ngpio)
-		goto fail;
-
-        status = chip->direction_output(chip, gpio, value);
-
-fail:
-        return status;
-}
-
-void
-pc3xx_gpio_set_value(unsigned gpio,
-                     int value)
-
-{
-    	struct gpio_chip	*chip;
-	struct gpio_desc	*desc = &gpio_desc[gpio];
-
-        chip = desc->chip;
-
-        chip->set(chip, gpio - chip->base, value);
-}
-
-int
-pc3xx_gpio_get_value(unsigned gpio)
-{
-    	struct gpio_chip	*chip;
-	struct gpio_desc	*desc = &gpio_desc[gpio];
-
-        chip = desc->chip;
-
-        return chip->get ? chip->get(chip, gpio - chip->base) : 0;
-}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/mux.c b/arch/arm/cpu/arm926ejs/pc3xx/mux.c
deleted file mode 100644
index 3793aa4..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/mux.c
+++ /dev/null
@@ -1,1274 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
- * \file mux.c
- * \brief Muxing control for the gpio pins.
- *
- * Copyright (c) 2009-2011 Picochip Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * All enquiries to support@picochip.com
- */
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-#include <asm/errno.h>
-#include <asm/arch/pc302.h>
-#include <asm/arch/utilities.h>
-#include <asm/arch/axi2cfg.h>
-#include <asm/arch/mux.h>
-#include <asm/arch/pc3xxgpio.h>
-
-/* Constants --------------------------------------------------------------- */
-/*
- * A multiplexed pin. This defines the SD and ARM pins that are on the pad. If
- * the pin does not have an SD or ARM pin then set the appropriate field to
- * -1.
- */
-struct muxed_pin {
-	const char	*name;
-	int		is_dedicated_gpio;
-	int		sd_pin;
-	int		arm_pin;
-	int		(*set_mux)(struct muxed_pin *pin,
-			           enum mux_setting setting);
-	int		(*get_mux)(struct muxed_pin *pin);
-};
-
-/*
- * A logical group of multiplexed pins. Typically this is grouped by what the
- * pins are multiplexed with e.g. system peripheral.
- */
-struct pin_group {
-	int		    nr_pins;
-	const char	    *name;
-	struct muxed_pin    *pins;
-};
-
-/* Macros ------------------------------------------------------------------ */
-#define __PIN(_name, _sd, _arm, _set, _get)		        \
-	.name		    = __stringify(_name),		\
-	.is_dedicated_gpio  = 0,				\
-	.sd_pin		    = (_sd),				\
-	.arm_pin    	    = (_arm),				\
-	.set_mux    	    = _set,				\
-	.get_mux    	    = _get
-/*
- * Declare a function pin that is also multiplexed with GPIO pins.
- */
-#define PIN(_name, _sd, _arm, _set, _get) {			\
-	__PIN(_name, _sd, _arm, _set, _get),			\
-	.is_dedicated_gpio  = 0,				\
-}
-
-/*
- * Declare a pure GPIO pin.
- */
-#define GPIO(_name, _sd, _arm, _set, _get) {			\
-	__PIN(_name, _sd, _arm, _set, _get),			\
-	.is_dedicated_gpio  = 1,				\
-}
-
-/* Functions --------------------------------------------------------------- */
-/*****************************************************************************
- * PC302 pin multiplexing.
- ****************************************************************************/
-#ifdef CONFIG_PICOCHIP_PC3X2
-
-static int
-pai_get_mux(struct muxed_pin *pin)
-{
-#define PAI_GPIO_PIN_ARM_4	0xB
-#define PAI_GPIO_PIN_ARM_5	0xA
-#define PAI_GPIO_PIN_ARM_6	0x9
-#define PAI_GPIO_PIN_ARM_7	0x8
-#define PAI_GPIO_PIN_SDGPIO_4	0x7
-#define PAI_GPIO_PIN_SDGPIO_5	0x6
-#define PAI_GPIO_PIN_SDGPIO_6	0x5
-#define PAI_GPIO_PIN_SDGPIO_7	0x4
-#define PC302_PAI_CAEID		0x8080
-#define PAI_SLEEP_REG		0xA060
-#define PAI_IO_CTRL_REG		0x0009
-
-	/* Make sure that the PAI block is awake. */
-	u16 data = 0, sd_mask = 0, arm_mask = 0;
-	int ret = axi2cfg_config_write(PC302_PAI_CAEID, PAI_SLEEP_REG,
-				       &data, 1);
-	if (1 != ret) {
-		printf("unable to wake up PAI\n");
-		return -EIO;
-	}
-
-	/* Get the current PAI muxing configuration. */
-	ret = axi2cfg_config_read(PC302_PAI_CAEID, PAI_IO_CTRL_REG,
-				  &data, 1);
-	if (1 != ret) {
-		printf("unable to read PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_4;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_5;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_6;
-	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
-		sd_mask |= PAI_GPIO_PIN_SDGPIO_7;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
-		arm_mask |= PAI_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
-		arm_mask |= PAI_GPIO_PIN_ARM_5;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
-		arm_mask |= PAI_GPIO_PIN_ARM_6;
-	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
-		arm_mask |= PAI_GPIO_PIN_ARM_7;
-	} else {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	if (data & sd_mask)
-		ret = MUX_SD;
-	else if (data & arm_mask)
-		ret = MUX_ARM;
-	else
-		ret = MUX_PERIPHERAL;
-
-out:
-	return ret;
-}
-
-static int
-pai_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting)
-{
-	/* Make sure that the PAI block is awake. */
-	u16 data = 0;
-	int err = axi2cfg_config_write(PC302_PAI_CAEID, PAI_SLEEP_REG,
-				       &data, 1);
-	if (1 != err) {
-		printf("unable to wake up PAI\n");
-		return -EIO;
-	}
-
-	/* Get the current PAI muxing configuration. */
-	err = axi2cfg_config_read(PC302_PAI_CAEID, PAI_IO_CTRL_REG,
-				  &data, 1);
-	if (1 != err) {
-		printf("unable to read PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	if (MUX_SD == setting) {
-		if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
-			data |= PAI_GPIO_PIN_SDGPIO_4;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
-			data |= PAI_GPIO_PIN_SDGPIO_5;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
-			data |= PAI_GPIO_PIN_SDGPIO_6;
-		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
-			data |= PAI_GPIO_PIN_SDGPIO_7;
-		} else {
-			err = -EINVAL;
-			goto out;
-		}
-	} else if (MUX_ARM == setting) {
-		if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
-			data |= PAI_GPIO_PIN_ARM_4;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
-			data |= PAI_GPIO_PIN_ARM_5;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
-			data |= PAI_GPIO_PIN_ARM_6;
-		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
-			data |= PAI_GPIO_PIN_ARM_7;
-		} else {
-			err = -EINVAL;
-			goto out;
-		}
-	} else if (MUX_PERIPHERAL == setting) {
-		/*
-		 * We don't do anything here. The PAI is only driven by the
-		 * picoArray so this will be automatically set in the loadfile
-		 * when the design is next loaded.
-		 */
-		err = 0;
-	} else if (MUX_UNMUXED == setting) {
-		/* This can't be changed at run-time! */
-		return -EPERM;
-	}
-
-	err = axi2cfg_config_write(PC302_PAI_CAEID, PAI_IO_CTRL_REG, &data, 1);
-	if (1 != err) {
-		printf("unable to write PAI I/O control reg\n");
-		return -EIO;
-	}
-
-	err = 0;
-
-out:
-	return err;
-}
-
-static struct muxed_pin pai_pins[] = {
-PIN(sdgpio4, PC302_GPIO_PIN_SDGPIO_4, -1, pai_set_mux, pai_get_mux),
-PIN(sdgpio5, PC302_GPIO_PIN_SDGPIO_5, -1, pai_set_mux, pai_get_mux),
-PIN(sdgpio6, PC302_GPIO_PIN_SDGPIO_6, -1, pai_set_mux, pai_get_mux),
-PIN(sdgpio7, PC302_GPIO_PIN_SDGPIO_7, -1, pai_set_mux, pai_get_mux),
-PIN(arm4, -1, PC302_GPIO_PIN_ARM_4, pai_set_mux, pai_get_mux),
-PIN(arm5, -1, PC302_GPIO_PIN_ARM_5, pai_set_mux, pai_get_mux),
-PIN(arm6, -1, PC302_GPIO_PIN_ARM_6, pai_set_mux, pai_get_mux),
-PIN(arm7, -1, PC302_GPIO_PIN_ARM_7, pai_set_mux, pai_get_mux),
-};
-
-static struct pin_group pai_group = {
-	.nr_pins    = ARRAY_SIZE(pai_pins),
-	.name	    = "pai/ebi",
-	.pins	    = pai_pins,
-};
-
-static int
-shd_get_mux(struct muxed_pin *pin)
-{
-	unsigned bit;
-	unsigned long syscfg = syscfg_read();
-
-	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
-		return MUX_PERIPHERAL;
-
-	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_0) {
-		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
-			return MUX_PERIPHERAL;
-		else
-			return MUX_SD;
-	}
-
-	bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-			pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
-
-	return syscfg & bit ? MUX_ARM : MUX_SD;
-}
-
-static int
-shd_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting)
-{
-	unsigned bit;
-	unsigned long syscfg = syscfg_read();
-
-	/*
-	 * In parallel boot mode, shared pin 7 can't be used as it is always
-	 * on the EBI.
-	 */
-	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
-		return -EBUSY;
-
-	switch (setting) {
-	case MUX_PERIPHERAL:
-		/*
-		 * SDGPIO pin 0 is shared with the Frac-N.
-		 */
-		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
-			syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
-				      AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
-			break;
-		}
-		return -EIO;
-
-	case MUX_SD:
-		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-			    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
-		syscfg_update(bit, 0);
-		break;
-
-	case MUX_ARM:
-		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin)
-			return -EINVAL;
-		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
-			    pin->arm_pin - PC302_GPIO_PIN_ARM_8);
-		syscfg_update(bit, bit);
-		break;
-
-	case MUX_UNMUXED:
-		/* This can't be changed at run-time! */
-		return -EPERM;
-	}
-
-	return 0;
-}
-
-static struct muxed_pin shared_pins[] = {
-GPIO(shared0, PC302_GPIO_PIN_SDGPIO_8, PC302_GPIO_PIN_ARM_8, shd_set_mux,
-     shd_get_mux),
-GPIO(shared1, PC302_GPIO_PIN_SDGPIO_9, PC302_GPIO_PIN_ARM_9, shd_set_mux,
-     shd_get_mux),
-GPIO(shared2, PC302_GPIO_PIN_SDGPIO_10, PC302_GPIO_PIN_ARM_10, shd_set_mux,
-     shd_get_mux),
-GPIO(shared3, PC302_GPIO_PIN_SDGPIO_11, PC302_GPIO_PIN_ARM_11, shd_set_mux,
-     shd_get_mux),
-GPIO(shared4, PC302_GPIO_PIN_SDGPIO_12, PC302_GPIO_PIN_ARM_12, shd_set_mux,
-     shd_get_mux),
-GPIO(shared5, PC302_GPIO_PIN_SDGPIO_13, PC302_GPIO_PIN_ARM_13, shd_set_mux,
-     shd_get_mux),
-GPIO(shared6, PC302_GPIO_PIN_SDGPIO_14, PC302_GPIO_PIN_ARM_14, shd_set_mux,
-     shd_get_mux),
-PIN(shared7, PC302_GPIO_PIN_SDGPIO_15, PC302_GPIO_PIN_ARM_15, shd_set_mux,
-    shd_get_mux),
-};
-
-static struct pin_group shd_group = {
-	.nr_pins    = ARRAY_SIZE(shared_pins),
-	.name	    = "shared/ebi",
-	.pins	    = shared_pins,
-};
-
-static struct muxed_pin fracn_pins[] = {
-PIN(sdgpio0, PC302_GPIO_PIN_SDGPIO_0, -1, shd_set_mux, shd_get_mux),
-};
-
-static struct pin_group fracn_group = {
-	.nr_pins    = ARRAY_SIZE(fracn_pins),
-	.name	    = "fracn/sdgpio0",
-	.pins	    = fracn_pins,
-};
-
-static struct pin_group *pc3x2_groups[] = {
-	&shd_group,
-	&pai_group,
-	&fracn_group,
-};
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-
-/*****************************************************************************
- * PC3X3 pin multiplexing.
- ****************************************************************************/
-#ifdef CONFIG_PICOCHIP_PC3X3
-
-#define SHD_GPIO_MUX_REG        (PC302_AXI2CFG_BASE + \
-				 AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET)
-#define USE_EBI_GPIO_REG	(PC302_AXI2CFG_BASE + \
-				 AXI2CFG_USE_EBI_GPIO_REG_OFFSET)
-#define USE_PAI_GPIO_REG	(PC302_AXI2CFG_BASE + \
-				 AXI2CFG_USE_PAI_GPIO_REG_OFFSET)
-#define USE_DECODE_GPIO_REG	(PC302_AXI2CFG_BASE + \
-				 AXI2CFG_USE_DECODE_GPIO_REG_OFFSET)
-#define USE_MISC_INT_GPIO_REG	(PC302_AXI2CFG_BASE + \
-				 AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET)
-
-/*
- * Set the muxing of one of the shared pins.
- */
-static void
-pc3xx_shd_gpio_set_mux(int arm_pin_nr,
-		       enum mux_setting setting)
-{
-	unsigned long shd_mux = pc302_read_from_register(SHD_GPIO_MUX_REG);
-
-	if (MUX_ARM == setting)
-		shd_mux |= (1 << arm_pin_nr);
-	else
-		shd_mux &= ~(1 << arm_pin_nr);
-
-	pc302_write_to_register(SHD_GPIO_MUX_REG, shd_mux);
-}
-
-static int
-pc3xx_get_shd_mux(struct muxed_pin *pin)
-{
-	unsigned long shd_mux = pc302_read_from_register(SHD_GPIO_MUX_REG);
-	unsigned long syscfg = syscfg_read();
-
-	if (pin->sd_pin == PC3X3_GPIO_PIN_SDGPIO_0) {
-		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
-			return MUX_PERIPHERAL;
-		else
-			return MUX_SD;
-	}
-
-	return shd_mux & (1 << pin->arm_pin) ? MUX_ARM : MUX_SD;
-}
-
-/*
- * Shared ARM/SD gpio pins. These pins go to the arm_gpio[3:0] pads but can
- * be arm or sdgpio.
- */
-static int
-pc3xx_shd_mux(struct muxed_pin *pin,
-	      enum mux_setting setting)
-{
-	if (MUX_PERIPHERAL == setting) {
-		if (pin->sd_pin != PC3X3_GPIO_PIN_SDGPIO_0)
-			return -EINVAL;
-
-		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
-			      AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
-	} else if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
-		syscfg_update(AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
-	}
-
-	if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin && MUX_ARM == setting)
-		return -EINVAL;
-
-	pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
-
-	return 0;
-}
-
-static struct muxed_pin armgpio_0_4[] = {
-GPIO(arm_gpio0, PC3X3_GPIO_PIN_SDGPIO_16, PC3X3_GPIO_PIN_ARM_0, pc3xx_shd_mux,
-     pc3xx_get_shd_mux),
-GPIO(arm_gpio1, PC3X3_GPIO_PIN_SDGPIO_17, PC3X3_GPIO_PIN_ARM_1, pc3xx_shd_mux,
-     pc3xx_get_shd_mux),
-GPIO(arm_gpio2, PC3X3_GPIO_PIN_SDGPIO_18, PC3X3_GPIO_PIN_ARM_2, pc3xx_shd_mux,
-     pc3xx_get_shd_mux),
-GPIO(arm_gpio3, PC3X3_GPIO_PIN_SDGPIO_19, PC3X3_GPIO_PIN_ARM_3, pc3xx_shd_mux,
-     pc3xx_get_shd_mux),
-};
-
-static struct pin_group armgpio_0_4_group = {
-	.nr_pins    = ARRAY_SIZE(armgpio_0_4),
-	.name	    = "arm_gpio[3:0]",
-	.pins	    = armgpio_0_4,
-};
-
-static struct muxed_pin shd_gpio[] = {
-GPIO(shd_gpio, PC3X3_GPIO_PIN_SDGPIO_8, PC3X3_GPIO_PIN_ARM_8, pc3xx_shd_mux,
-     pc3xx_get_shd_mux),
-};
-
-static struct pin_group pc3x3_shd_group = {
-	.nr_pins    = ARRAY_SIZE(shd_gpio),
-	.name	    = "shd_gpio",
-	.pins	    = shd_gpio,
-};
-
-/*
- * boot_mode[1:0] pads - the pins switch to gpio automatically after boot and
- * can be either arm or sdgpio.
- */
-static struct muxed_pin boot_mode_0_1[] = {
-GPIO(boot_mode0, PC3X3_GPIO_PIN_SDGPIO_9, PC3X3_GPIO_PIN_ARM_9,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-GPIO(boot_mode1, PC3X3_GPIO_PIN_SDGPIO_10, PC3X3_GPIO_PIN_ARM_10,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group boot_mode_group = {
-	.nr_pins    = ARRAY_SIZE(boot_mode_0_1),
-	.name	    = "boot_mode[1:0]",
-	.pins	    = boot_mode_0_1,
-};
-
-/*
- * sdram_speed_sel pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin sdram_speed_sel[] = {
-GPIO(sdram_speed_sel, PC3X3_GPIO_PIN_SDGPIO_11, PC3X3_GPIO_PIN_ARM_11,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group sdram_speed_sel_group = {
-	.nr_pins    = ARRAY_SIZE(sdram_speed_sel),
-	.name	    = "sdram_speed_sel",
-	.pins	    = sdram_speed_sel,
-};
-
-/*
- * mii_rev_en pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_rev_en[] = {
-GPIO(mii_rev_en, PC3X3_GPIO_PIN_SDGPIO_12, PC3X3_GPIO_PIN_ARM_12,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_rev_en_group = {
-	.nr_pins    = ARRAY_SIZE(mii_rev_en),
-	.name	    = "mii_rev_en",
-	.pins	    = mii_rev_en,
-};
-
-/*
- * mii_rmii_en pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_rmii_en[] = {
-GPIO(mii_rmii_en, PC3X3_GPIO_PIN_SDGPIO_13, PC3X3_GPIO_PIN_ARM_13,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_rmii_en_group = {
-	.nr_pins    = ARRAY_SIZE(mii_rmii_en),
-	.name	    = "mii_rmii_en",
-	.pins	    = mii_rmii_en,
-};
-
-/*
- * mii_speed_sel pad - automatically switches to gpio after boot and can be
- * arm or sdgpio.
- */
-static struct muxed_pin mii_speed_sel[] = {
-GPIO(mii_speed_sel, PC3X3_GPIO_PIN_SDGPIO_14, PC3X3_GPIO_PIN_ARM_14,
-     pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group mii_speed_sel_group = {
-	.nr_pins    = ARRAY_SIZE(mii_speed_sel),
-	.name	    = "mii_speed_sel",
-	.pins	    = mii_speed_sel,
-};
-
-static int
-pc3x3_shd_ebi_get_mux(struct muxed_pin *pin)
-{
-	int ebi_pin, err = 0, can_be_sd = 1;
-	unsigned long ebi_mux;
-
-	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
-
-	/*
-	 * Find out what EBI pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else {
-		/* These aren't shared gpio pins. */
-		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
-		can_be_sd = 0;
-	}
-
-	if (!(ebi_mux & (1 << (ebi_pin - 14)))) {
-		err = MUX_PERIPHERAL;
-		goto out;
-	}
-
-	if (can_be_sd)
-		err = pc3xx_get_shd_mux(pin);
-	else
-		err = MUX_ARM;
-
-out:
-	return err;
-}
-
-static int
-pc3x3_shd_ebi_set_mux(struct muxed_pin *pin,
-		      enum mux_setting setting)
-{
-	int ebi_pin, err = 0, can_be_sd = 1;
-	unsigned long ebi_mux;
-
-	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
-
-	/*
-	 * Find out what EBI pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else {
-		/* These aren't shared gpio pins. */
-		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
-		can_be_sd = 0;
-	}
-
-	if (MUX_SD == setting && !can_be_sd) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	/* Use the pin as EBI. */
-	if (MUX_PERIPHERAL == setting)
-		ebi_mux &= ~(1 << (ebi_pin - 14));
-	else
-		ebi_mux |= (1 << (ebi_pin - 14));
-
-	pc302_write_to_register(USE_EBI_GPIO_REG, ebi_mux);
-
-	/*
-	 * Make sure that the configuration is valid (the GPIO isn't going to
-	 * the PAI).
-	 */
-	if (pc302_read_from_register(USE_EBI_GPIO_REG) != ebi_mux) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	/*
-	 * If we can be SD or ARM and we want to be gpio, pick the correct
-	 * one now.
-	 */
-	if (MUX_PERIPHERAL != setting && can_be_sd)
-		pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
-
-out:
-	return err;
-}
-
-/*
- * ebi_addr[25:18] pads - these pads can be either the EBI or arm gpio or
- * sdgpio. Note: the gpio pins can also be routed to the pai_tx/rx_data pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the pai tx/rx data pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin ebi_addr_18_25[] = {
-PIN(ebi_addr18, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr19, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr20, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr21, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr22, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr23, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr24, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr25, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
-    pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
-};
-
-static struct pin_group ebi_addr_18_25_group = {
-	.nr_pins    = ARRAY_SIZE(ebi_addr_18_25),
-	.name	    = "ebi_addr[25:18]",
-	.pins	    = ebi_addr_18_25,
-};
-
-static int
-pc3x3_shd_pai_get_mux(struct muxed_pin *pin)
-{
-	int bit, err = 0, can_be_sd = 1;
-	unsigned long pai_mux;
-
-	pai_mux = pc302_read_from_register(USE_PAI_GPIO_REG);
-
-	/*
-	 * Find out what pai pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		/* pai_tx_data[3:0] */
-		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		/* pai_rx_data[3:0] */
-		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
-		/* pai_tx_data[7:4] */
-		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
-		can_be_sd = 0;
-	} else {
-		/* pai_rx_data[7:4] */
-		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
-		can_be_sd = 0;
-	}
-
-	if (!(pai_mux & (1 << bit))) {
-		err = MUX_PERIPHERAL;
-		goto out;
-	}
-
-	if (can_be_sd)
-		err = pc3xx_get_shd_mux(pin);
-	else
-		err = MUX_ARM;
-
-out:
-	return err;
-}
-
-static int
-pc3x3_shd_pai_set_mux(struct muxed_pin *pin,
-		      enum mux_setting setting)
-{
-	int bit, err = 0, can_be_sd = 1;
-	unsigned long pai_mux;
-
-	pai_mux = pc302_read_from_register(USE_PAI_GPIO_REG);
-
-	/*
-	 * Find out what pai pin our GPIO maps to.
-	 */
-	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
-	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
-		/* pai_tx_data[3:0] */
-		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
-		/* pai_rx_data[3:0] */
-		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
-	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
-		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
-		/* pai_tx_data[7:4] */
-		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
-		can_be_sd = 0;
-	} else {
-		/* pai_rx_data[7:4] */
-		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
-		can_be_sd = 0;
-	}
-
-	if (MUX_SD == setting && !can_be_sd) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	/* Use the pin as pai. */
-	if (MUX_PERIPHERAL == setting)
-		pai_mux &= ~(1 << bit);
-	else
-		pai_mux |= (1 << bit);
-
-	pc302_write_to_register(USE_PAI_GPIO_REG, pai_mux);
-
-	/*
-	 * Make sure that the configuration is valid (the GPIO isn't going to
-	 * the EBI).
-	 */
-	if (pc302_read_from_register(USE_PAI_GPIO_REG) != pai_mux) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	/*
-	 * If we can be SD or ARM and we want to be gpio, pick the correct
-	 * one now.
-	 */
-	if (MUX_PERIPHERAL != setting && can_be_sd)
-		pc3xx_shd_gpio_set_mux(pin->arm_pin, setting);
-
-out:
-	return err;
-}
-
-/*
- * pai_rx_data[3:0] pads - these pads can be either the pai_rx_data or arm
- * gpio or sdgpio. Note: the gpio pins can also be routed to the
- * ebi_addr pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the ebi address pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin pai_rx_data_0_3[] = {
-PIN(pai_rx_data0, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data1, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data2, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data3, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_rx_data_0_3_group = {
-	.nr_pins    = ARRAY_SIZE(pai_rx_data_0_3),
-	.name	    = "pai_rx_data[3:0]",
-	.pins	    = pai_rx_data_0_3,
-};
-
-/*
- * pai_tx_data[3:0] pads - these pads can be either the pai_tx_data or arm
- * gpio or sdgpio. Note: the gpio pins can also be routed to the
- * ebi_addr pads.
- *
- * A pad may only be used for GPIO if the corresponding GPIO pin is not
- * already routed to the ebi address pad. The same applies in the reverse
- * direction. Hardware interlocks exist to prevent this from happening.
- */
-static struct muxed_pin pai_tx_data_0_3[] = {
-PIN(pai_tx_data0, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data1, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data2, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data3, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
-    pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_tx_data_0_3_group = {
-	.nr_pins    = ARRAY_SIZE(pai_tx_data_0_3),
-	.name	    = "pai_tx_data[3:0]",
-	.pins	    = pai_tx_data_0_3,
-};
-
-/*
- * pai_tx_data[7:4] pads - these pads can either be pai_tx_data or arm gpio.
- */
-static struct muxed_pin pai_tx_data_4_7[] = {
-PIN(pai_tx_data4, -1, PC3X3_GPIO_PIN_ARM_24, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data5, -1, PC3X3_GPIO_PIN_ARM_25, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data6, -1, PC3X3_GPIO_PIN_ARM_26, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_tx_data7, -1, PC3X3_GPIO_PIN_ARM_27, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_tx_data_4_7_group = {
-	.nr_pins    = ARRAY_SIZE(pai_tx_data_4_7),
-	.name	    = "pai_tx_data[7:4]",
-	.pins	    = pai_tx_data_4_7,
-};
-
-/*
- * pai_rx_data[7:4] pads - these pads can either be pai_rx_data or arm gpio.
- */
-static struct muxed_pin pai_rx_data_4_7[] = {
-PIN(pai_rx_data4, -1, PC3X3_GPIO_PIN_ARM_28, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data5, -1, PC3X3_GPIO_PIN_ARM_29, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data6, -1, PC3X3_GPIO_PIN_ARM_30, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-PIN(pai_rx_data7, -1, PC3X3_GPIO_PIN_ARM_31, pc3x3_shd_pai_set_mux,
-    pc3x3_shd_pai_get_mux),
-};
-
-static struct pin_group pai_rx_data_4_7_group = {
-	.nr_pins    = ARRAY_SIZE(pai_rx_data_4_7),
-	.name	    = "pai_rx_data[7:4]",
-	.pins	    = pai_rx_data_4_7,
-};
-
-/*
- * ebi_addr[17:14] pads - these pads can either be ebi_addr or arm gpio.
- */
-static struct muxed_pin ebi_addr_14_17[] = {
-PIN(ebi_addr14, -1, PC3X3_GPIO_PIN_ARM_32, pc3x3_shd_ebi_set_mux,
-    pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr15, -1, PC3X3_GPIO_PIN_ARM_33, pc3x3_shd_ebi_set_mux,
-    pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr16, -1, PC3X3_GPIO_PIN_ARM_34, pc3x3_shd_ebi_set_mux,
-    pc3x3_shd_ebi_get_mux),
-PIN(ebi_addr17, -1, PC3X3_GPIO_PIN_ARM_35, pc3x3_shd_ebi_set_mux,
-    pc3x3_shd_ebi_get_mux),
-};
-
-static struct pin_group ebi_addr_14_17_group = {
-	.nr_pins    = ARRAY_SIZE(ebi_addr_14_17),
-	.name	    = "ebi_addr[17:14]",
-	.pins	    = ebi_addr_14_17,
-};
-
-static int
-decode_get_mux(struct muxed_pin *pin)
-{
-	unsigned bit = 1 << (pin->arm_pin - PC3X3_GPIO_PIN_ARM_36);
-	unsigned long use_decode_gpio =
-            pc302_read_from_register(USE_DECODE_GPIO_REG);
-
-	return use_decode_gpio & (1 << bit) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int
-decode_set_mux(struct muxed_pin *pin,
-	       enum mux_setting setting)
-{
-	unsigned long use_decode_gpio;
-	unsigned bit = pin->arm_pin == PC3X3_GPIO_PIN_ARM_36 ? 0 : 1;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_decode_gpio = pc302_read_from_register(USE_DECODE_GPIO_REG);
-	if (MUX_ARM == setting)
-		use_decode_gpio |= (1 << bit);
-	else
-		use_decode_gpio &= ~(1 << bit);
-	pc302_write_to_register(USE_DECODE_GPIO_REG, use_decode_gpio);
-
-	return 0;
-}
-
-/*
- * decode[3:0] pads - these pads can either be decode pins or arm gpio.
- */
-static struct muxed_pin decode_0_3[] = {
-PIN(decode0, -1, PC3X3_GPIO_PIN_ARM_36, decode_set_mux, decode_get_mux),
-PIN(decode1, -1, PC3X3_GPIO_PIN_ARM_37, decode_set_mux, decode_get_mux),
-PIN(decode2, -1, PC3X3_GPIO_PIN_ARM_38, decode_set_mux, decode_get_mux),
-PIN(decode3, -1, PC3X3_GPIO_PIN_ARM_39, decode_set_mux, decode_get_mux),
-};
-
-static struct pin_group decode_0_3_group = {
-	.nr_pins    = ARRAY_SIZE(decode_0_3),
-	.name	    = "decode[3:0]",
-	.pins	    = decode_0_3,
-};
-
-static int
-ssi_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting);
-
-static int
-ssi_get_mux(struct muxed_pin *pin);
-
-/*
- * ssi pads - these pads can either be ssi block pins or arm gpio.
- */
-static struct muxed_pin ssi[] = {
-PIN(ssi_clk, -1, PC3X3_GPIO_PIN_ARM_40, ssi_set_mux, ssi_get_mux),
-PIN(ssi_data_in, -1, PC3X3_GPIO_PIN_ARM_41, ssi_set_mux, ssi_get_mux),
-PIN(ssi_data_out, -1, PC3X3_GPIO_PIN_ARM_42, ssi_set_mux, ssi_get_mux),
-};
-
-static int
-ssi_get_mux(struct muxed_pin *pin)
-{
-	unsigned long use_misc_int_gpio =
-            pc302_read_from_register(USE_MISC_INT_GPIO_REG);
-
-	return use_misc_int_gpio & (1 << 0) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int
-ssi_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting)
-{
-	unsigned long use_misc_int_gpio;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_misc_int_gpio = pc302_read_from_register(USE_MISC_INT_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		use_misc_int_gpio &= ~(1 << 0);
-	else
-		use_misc_int_gpio |= (1 << 0);
-	pc302_write_to_register(USE_MISC_INT_GPIO_REG, use_misc_int_gpio);
-
-	return 0;
-}
-
-static struct pin_group ssi_group = {
-	.nr_pins    = ARRAY_SIZE(ssi),
-	.name	    = "ssi",
-	.pins	    = ssi,
-};
-
-static int
-mii_get_mux(struct muxed_pin *pin)
-{
-	unsigned long syscfg = syscfg_read();
-
-	return syscfg & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int
-mii_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting)
-{
-	/*
-	 * These are automatically configured by hardware if we are in
-	 * reduced MII mode.
-	 */
-	return -EOPNOTSUPP;
-}
-
-/*
- * mii pads - these pads can either be mii pins or arm gpio.
- */
-static struct muxed_pin mii[] = {
-PIN(mii_tx_data2, -1, PC3X3_GPIO_PIN_ARM_43, mii_set_mux, mii_get_mux),
-PIN(mii_tx_data3, -1, PC3X3_GPIO_PIN_ARM_44, mii_set_mux, mii_get_mux),
-PIN(mii_rx_data2, -1, PC3X3_GPIO_PIN_ARM_45, mii_set_mux, mii_get_mux),
-PIN(mii_rx_data3, -1, PC3X3_GPIO_PIN_ARM_46, mii_set_mux, mii_get_mux),
-PIN(mii_col, -1, PC3X3_GPIO_PIN_ARM_47, mii_set_mux, mii_get_mux),
-PIN(mii_crs, -1, PC3X3_GPIO_PIN_ARM_48, mii_set_mux, mii_get_mux),
-PIN(mii_tx_clk, -1, PC3X3_GPIO_PIN_ARM_49, mii_set_mux, mii_get_mux),
-};
-
-static struct pin_group mii_group = {
-	.nr_pins    = ARRAY_SIZE(mii),
-	.name	    = "mii",
-	.pins	    = mii,
-};
-
-static int
-max_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting);
-
-static int
-max_get_mux(struct muxed_pin *pin);
-
-/*
- * maxim pads - these pads can either be maxim pins or arm gpio.
- */
-static struct muxed_pin max[] = {
-PIN(max_tx_ctrl, -1, PC3X3_GPIO_PIN_ARM_50, max_set_mux, max_get_mux),
-PIN(max_ref_clk, -1, PC3X3_GPIO_PIN_ARM_51, max_set_mux, max_get_mux),
-PIN(max_trig_clk, -1, PC3X3_GPIO_PIN_ARM_52, max_set_mux, max_get_mux),
-};
-
-static int
-max_get_mux(struct muxed_pin *pin)
-{
-	unsigned long use_misc_int_gpio =
-            pc302_read_from_register(USE_MISC_INT_GPIO_REG);
-
-	return use_misc_int_gpio & (1 << 1) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int
-max_set_mux(struct muxed_pin *pin,
-	    enum mux_setting setting)
-{
-	unsigned long use_misc_int_gpio;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	use_misc_int_gpio = pc302_read_from_register(USE_MISC_INT_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		use_misc_int_gpio &= ~(1 << 1);
-	else
-		use_misc_int_gpio |= (1 << 1);
-	pc302_write_to_register(USE_MISC_INT_GPIO_REG, use_misc_int_gpio);
-
-	return 0;
-}
-
-
-static struct pin_group max_group = {
-	.nr_pins    = ARRAY_SIZE(max),
-	.name	    = "mii",
-	.pins	    = max,
-};
-
-static int
-ebi_clk_get_mux(struct muxed_pin *pin)
-{
-	unsigned long ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
-
-	return ebi_mux & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
-}
-
-static int
-ebi_clk_set_mux(struct muxed_pin *pin,
-	        enum mux_setting setting)
-{
-	unsigned long ebi_mux;
-
-	if (MUX_SD == setting)
-		return -EINVAL;
-
-	ebi_mux = pc302_read_from_register(USE_EBI_GPIO_REG);
-	if (MUX_PERIPHERAL == setting)
-		ebi_mux &= ~(1 << 13);
-	else
-		ebi_mux |= (1 << 13);
-	pc302_write_to_register(USE_EBI_GPIO_REG, ebi_mux);
-
-	return 0;
-}
-
-/*
- * ebi clock pads - this pad can either be the ebi clock or an arm gpio.
- */
-static struct muxed_pin ebi_clk[] = {
-PIN(ebi_clk, -1, PC3X3_GPIO_PIN_ARM_53, ebi_clk_set_mux, ebi_clk_get_mux),
-};
-
-static struct pin_group ebi_clk_group = {
-	.nr_pins    = ARRAY_SIZE(ebi_clk),
-	.name	    = "ebi_clk",
-	.pins	    = ebi_clk,
-};
-
-static struct muxed_pin pc3x3_fracn_pins[] = {
-PIN(sdgpio0, PC3X3_GPIO_PIN_SDGPIO_0, -1, pc3xx_shd_mux, pc3xx_get_shd_mux),
-};
-
-static struct pin_group pc3x3_fracn_group = {
-	.nr_pins    = ARRAY_SIZE(pc3x3_fracn_pins),
-	.name	    = "fracn/sdgpio0",
-	.pins	    = pc3x3_fracn_pins,
-};
-
-static struct pin_group *pc3x3_groups[] = {
-	&armgpio_0_4_group,
-	&pc3x3_shd_group,
-	&boot_mode_group,
-	&sdram_speed_sel_group,
-	&mii_rev_en_group,
-	&mii_rmii_en_group,
-	&mii_speed_sel_group,
-	&ebi_addr_18_25_group,
-	&pai_tx_data_0_3_group,
-	&pai_rx_data_0_3_group,
-	&pai_tx_data_4_7_group,
-	&pai_rx_data_4_7_group,
-	&ebi_addr_14_17_group,
-	&decode_0_3_group,
-	&ssi_group,
-	&mii_group,
-	&max_group,
-	&ebi_clk_group,
-	&pc3x3_fracn_group,
-};
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-
-/* Public API -------------------------------------------------------------- */
-/*****************************************************************************
- * Generic level pin multiplexing.
- ****************************************************************************/
-
-static struct {
-	unsigned	    num_groups;
-	struct pin_group    **groups;
-} all_groups;
-
-int
-pc3xx_pin_set_mux(int pin_nr,
-		  enum mux_setting setting)
-{
-	unsigned i, j;
-	int ret = 0;
-
-	/*
-	 * Don't let users try and trick us - they can't change the hardware
-	 * that much!
-	 */
-	if (MUX_UNMUXED == setting)
-		return -EINVAL;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			/*
-			 * Dedicated GPIO pins aren't shared with a
-			 * peripheral. This is illegal!
-			 */
-			if (pin->is_dedicated_gpio &&
-			    MUX_PERIPHERAL == setting)
-				return -EINVAL;
-			if (pin_nr == pin->arm_pin ||
-			    pin_nr == pin->sd_pin) {
-				ret = pin->set_mux(pin, setting);
-				if (!ret)
-					goto out;
-				/*
-				 * If we failed to set the muxing of this pin,
-				 * carry on looping as we have some
-				 * many-to-many pins so we might pick it up
-				 * again on another output.
-				 */
-			}
-		}
-	}
-
-	/*
-	 * If we don't have a multiplexed pin entry for the requested pin then
-	 * we assume that the pin isn't multiplexed so we don't need to do
-	 * anything.
-	 */
-out:
-	return ret;
-}
-
-int
-pc3xx_group_set_mux(const char *group_name,
-		    enum mux_setting setting)
-{
-	unsigned i, j;
-	int err = -ENXIO;
-
-	/*
-	 * Don't let users try and trick us - they can't change the hardware
-	 * that much!
-	 */
-	if (MUX_UNMUXED == setting)
-		return -EINVAL;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		if (strcmp(group->name, group_name))
-			continue;
-
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			/*
-			 * Dedicated GPIO pins aren't shared with a
-			 * peripheral. This is illegal!
-			 */
-			if (pin->is_dedicated_gpio &&
-			    MUX_PERIPHERAL == setting)
-				return -EINVAL;
-			err = pin->set_mux(pin, setting);
-			if (err)
-				goto out;
-		}
-
-		break;
-	}
-
-out:
-	return err;
-}
-
-int
-pc3xx_get_pin_mux(int pin_nr)
-{
-	unsigned i, j;
-	int ret = 0;
-
-	for (i = 0; i < all_groups.num_groups; ++i) {
-		struct pin_group *group = all_groups.groups[i];
-		for (j = 0; j < group->nr_pins; ++j) {
-			struct muxed_pin *pin = &group->pins[j];
-			if (pin_nr == pin->arm_pin ||
-			    pin_nr == pin->sd_pin) {
-				int tmp = pin->get_mux(pin);
-				if (tmp < 0)
-					return tmp;
-				ret |= tmp;
-			}
-		}
-	}
-
-	/*
-	 * If we don't have a multiplexed pin entry for the requested pin then
-	 * we assume that the pin isn't multiplexed.
-	 */
-	return ret ? ret : MUX_UNMUXED;
-}
-
-void
-pc3xx_muxing_init(void)
-{
-	if (!is_pc3x3()) {
-#ifdef CONFIG_PICOCHIP_PC3X2
-		all_groups.num_groups = ARRAY_SIZE(pc3x2_groups);
-		all_groups.groups = pc3x2_groups;
-#endif /* CONFIG_PICOCHIP_PC3X2 */
-	} else {
-#ifdef CONFIG_PICOCHIP_PC3X3
-		all_groups.num_groups = ARRAY_SIZE(pc3x3_groups);
-		all_groups.groups = pc3x3_groups;
-#endif /* CONFIG_PICOCHIP_PC3X3 */
-	}
-}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/reset.S b/arch/arm/cpu/arm926ejs/pc3xx/reset.S
deleted file mode 100644
index 4c8c883..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/reset.S
+++ /dev/null
@@ -1,63 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file reset.S
-* \brief Function used to reset the PC302 device.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-/* Includes ---------------------------------------------------------------- */
-#include <config.h>
-#include <asm/arch/pc302.h>
-#include <asm/arch/wdog.h>
-
-/* Macros ------------------------------------------------------------------ */
-
-/* Functions --------------------------------------------------------------- */
-
-	.align	5
-
-/*!
- *
- * Perform a software reset of the PC302 device.
- *
- */
-.globl reset_cpu
-
-reset_cpu:
-
-        /* Use the 'fallback' watchdog method for reseting */
-
-        ldr     r0, =PC302_WDOG_BASE
-
-        /* Read the control register */
-        ldr     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
-
-        /* Clear the 'Response mode' bit */
-        bic     r1, #WDOGCONTROLREGRMODMASK
-
-        /* Set the 'Watchdog Enable' bit */
-        orr     r1, #WDOGCONTROLREGWDT_ENMASK
-
-        /* Write to the control register */
-        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
-
-        /* The Watchdog is hardwired for a 1 second timeout */
-
-        /* 'Kick' the Watchdog into life */
-        mov     r1, #WDOG_COUNTER_RESTART_KICK_VALUE
-        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
-
-reset_loop_forever:
-
-        /* We will never return from this function */
-        b       reset_loop_forever
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/spi.c b/arch/arm/cpu/arm926ejs/pc3xx/spi.c
deleted file mode 100644
index 2f73198..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/spi.c
+++ /dev/null
@@ -1,704 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file spi.c
-* \brief SPI driver for the PC302.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-
-#ifdef CONFIG_DW_SPI
-
-/* Define this to use a GPIO as the spi flash chip select.
-   Note: On the PC7302 platform we only have a single spi flash device.
-   Note: If this is not defined then we use the chip select generated by the
-         SPI block.
-   Note: Using this option on a PC7302 platform will require a board
-         modification.
-*/
-#undef USE_GPIO_AS_CHIP_SELECT
-
-#include <spi.h>
-#include <malloc.h>
-#include <asm/io.h>
-#include <asm/arch/pc302.h>
-#include <asm/arch/spi.h>
-#include <asm/arch/axi2cfg.h>
-#include <asm/arch/gpio.h>
-
-/* Macros ------------------------------------------------------------------ */
-/*!
- * \brief Debug macro
- */
-#ifdef	SPI_DEBUG
-#define spi_debug(fmt,args...)	printf (fmt ,##args)
-#else
-#define spi_debug(fmt,args...)
-#endif	/* SPI_DEBUG */
-
-/* !
- *  \brief Macros used to read from, and write to, the spi registers.
- *         Note: These macros provide 16 bit access.
- */
-#define SPI_READ(__offset) \
-                  *((volatile u16*)(PC302_SSI_BASE + __offset))
-
-#define SPI_WRITE(__value, __offset) \
-                   *((volatile u16*)(PC302_SSI_BASE + __offset)) = __value
-
-/* !
- *  \brief Macros used to read from, and write to, the axi2cfg registers.
- *         Note: These macros provide 32 bit access.
- */
-#define AXI2CFG_READ(__offset) \
-                  *((volatile u32*)(PC302_AXI2CFG_BASE + __offset))
-
-#define AXI2CFG_WRITE(__value, __offset) \
-                   *((volatile u32*)(PC302_AXI2CFG_BASE + __offset)) = __value
-
-/* Constants --------------------------------------------------------------- */
-/* !
- *  \brief This structure is used for generic and device specific
- *         spi driver data.
- */
-struct pc302_spi_slave
-{
-    /* Generic spi slave description */
-    struct spi_slave slave;
-
-    /* Additional driver data for the pc302 implementation */
-
-    /* Serial clock polarity */
-    unsigned int scpol;
-
-    /* Serial clock phase */
-    unsigned int scph;
-
-    /* Serial bus speed (Hz) */
-    unsigned int max_hz;
-
-    /* Pointer to hold location of the Tx data 'copy' */
-    u8 * dout_copy;
-
-    /* Keep a count of the data to tx */
-    unsigned int byte_count_tx;
-};
-
-/*!
- * \brief Function return codes
- */
-enum return_codes
-{
-    SUCCESS = 0,    /* Successful outcome */
-    FAILURE = 1     /* Error response */
-};
-
-/* Types ------------------------------------------------------------------- */
-
-/* Prototypes--------------------------------------------------------------- */
-
-void spi_init()
-{
-    /* Nothing specific required in here */
-}
-
-struct spi_slave *spi_setup_slave(unsigned int bus,
-                                  unsigned int cs,
-                                  unsigned int max_hz,
-                                  unsigned int mode)
-{
-    struct pc302_spi_slave  *spi_slave;
-
-    unsigned int    spi_max_clock = 0;
-    unsigned int    spi_min_clock = 0;
-
-    /* Have we been passed a valid combination of bus and cs ?
-       Note: PC302 device has a single SPI controller (bus) and
-             4 possible SPI chip selects */
-
-    if (bus > (PC302_MAX_NUMBER_SPI_BUSSES - 1))
-    {
-        /* Oops, request bus is out of range. */
-        printf ("Oops, SPI 'bus' out of range. "
-                "(We only have %d SPI bus(ses) available).\n",
-                (unsigned int)PC302_MAX_NUMBER_SPI_BUSSES);
-        return NULL;
-    }
-
-    if (cs > (PC302_MAX_NUMBER_SPI_CS - 1))
-    {
-        /* Oops, requested chip select is out of range */
-        printf ("Oops, SPI 'cs' out of range. "
-                "(We only have %d 'cs' available).\n",
-                (unsigned int)PC302_MAX_NUMBER_SPI_CS);
-        return NULL;
-    }
-
-    /* Have we been passed a valid SPI bus clock rate ? */
-    spi_max_clock = (PC302_AHB_CLOCK_FREQ / PC302_MIN_SPI_CLK_DIVIDER);
-    spi_min_clock = (PC302_AHB_CLOCK_FREQ / PC302_MAX_SPI_CLK_DIVIDER);
-
-    if ((max_hz < spi_min_clock) || (max_hz > spi_max_clock))
-    {
-    	/* Oops, we do not support this requested SPI bus clock rate */
-        printf ("Oops, SPI bus 'hz' out of range. "
-                "(Min = %d Hz, Max = %d Hz).\n", spi_min_clock, spi_max_clock);
-	return NULL;
-    }
-
-#ifdef USE_GPIO_AS_CHIP_SELECT
-    /* Have we been passed a valid SPI mode ? */
-    if ((mode < SPI_MODE_0) || (mode > SPI_MODE_3))
-    {
-        /* Oops, we only support spi mode 0 - 3 */
-        printf ("Oops, SPI 'mode' out of range. "
-                "(We only support SPI 'mode' %d to %d).\n",
-                (unsigned int)SPI_MODE_0, (unsigned int)SPI_MODE_3);
-        return NULL;
-    }
-#else
-    /* Have we been passed a valid SPI mode ? */
-    if (mode != SPI_MODE_3)
-    {
-        /* Oops, we only support spi mode 3 */
-        printf ("Oops, SPI 'mode' out of range. "
-                "(We only support SPI 'mode' %d).\n",
-                (unsigned int)SPI_MODE_3);
-        return NULL;
-    }
-#endif
-
-    /* Grab some memory for the SPI data structure */
-    spi_slave = malloc(sizeof(struct pc302_spi_slave));
-    if (!spi_slave)
-    {
-        /* Oops, we have a memory management problem */
-	printf ("Oops, memory allocation error, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-        return NULL;
-    }
-
-    /* Populate our structure */
-    spi_slave->slave.bus = bus;
-    spi_slave->slave.cs = cs;
-    spi_slave->max_hz = max_hz;
-
-    switch (mode)
-    {
-        case SPI_MODE_0:
-            spi_slave->scpol = 0;
-            spi_slave->scph = 0;
-            break;
-        case SPI_MODE_1:
-            spi_slave->scpol = 0;
-            spi_slave->scph = 1;
-            break;
-        case SPI_MODE_2:
-            spi_slave->scpol = 1;
-            spi_slave->scph = 0;
-            break;
-        case SPI_MODE_3:
-            spi_slave->scpol = 1;
-            spi_slave->scph = 1;
-            break;
-        default:
-            spi_slave->scpol = 0;
-            spi_slave->scph = 0;
-            break;
-    }
-
-#ifdef USE_GPIO_AS_CHIP_SELECT
-    /* Set up ARM gpio #2 for cs driving */
-    /* Negate the 'cs' in the data register */
-    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
-                      GPIO_BIT_2;
-
-    /* Set up the gpio as an o/p */
-    *(unsigned int *)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DDR_REG_OFFSET) |=
-                      GPIO_BIT_2;
-#endif
-
-    return &spi_slave->slave;
-}
-
-void spi_free_slave(struct spi_slave *slave)
-{
-    struct pc302_spi_slave  *spi_slave =
-           container_of(slave, struct pc302_spi_slave, slave);
-
-    /* Free memory acquired to hold the SPI data structure */
-    free (spi_slave);
-}
-
-int spi_claim_bus(struct spi_slave *slave)
-{
-    struct pc302_spi_slave  *spi_slave;
-
-    u16 ctrlr0 = 0;
-    u16 sckdv = 0;
-
-     /* Have we been passed a valid data structure handle ? */
-    if (slave == NULL)
-    {
-        /* Oops, bad handle passed in */
-        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-        return -FAILURE;
-    }
-
-    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
-
-    /* Disable SPI operations
-       Note: We can't program up the block registers unless
-             the block is disabled  */
-    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
-
-    /* Program up some bits Control Register 0.
-       Note: As TMOD bits set to 00 (Transmit & Receive),
-             we do not need to worry about the ctrlr1 register */
-    ctrlr0 = PC302_SPI_DATA_FRM_8_BIT;
-
-    if (spi_slave->scph)
-    {
-        /* Set the clock phase */
-        ctrlr0 |= PC302_SPI_SCPH;
-    }
-    if (spi_slave->scpol)
-    {
-        /* Set the clock polarity */
-        ctrlr0 |= PC302_SPI_SCPOL;
-    }
-    SPI_WRITE(ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
-
-    /* Setup the SPI bus clock rate */
-    sckdv = (PC302_AHB_CLOCK_FREQ / spi_slave->max_hz);
-    SPI_WRITE(sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
-
-    /* Mask all interrupts from the SPI block */
-    SPI_WRITE(PC302_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
-
-    return SUCCESS;
-}
-
-void spi_release_bus(struct spi_slave *slave)
-{
-    /* Have we been passed a valid data structure handle ? */
-    if (slave == NULL)
-    {
-        /* Oops, bad handle passed in */
-        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-    }
-
-    /* Disable SPI operations */
-    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
-}
-
-int spi_xfer(struct spi_slave *slave,
-             unsigned int bitlen,
-             const void *dout,
-             void *din,
-             unsigned long flags)
-{
-    struct pc302_spi_slave  *spi_slave;
-
-    unsigned int    len_tx;
-    unsigned int    len_rx;
-    unsigned int    byte_count;
-
-    u16		    status;
-
-    const u8	    *txp = dout;
-    u8		    *rxp = din;
-    u8		    value;
-
-
-    spi_debug ("spi_xfer: bitlen = %d, dout = %p, din = %p, flags = %d\n",
-                bitlen, dout, din, flags);
-
-     /* Have we been passed a valid data structure handle ? */
-    if (slave == NULL)
-    {
-        /* Oops, bad handle passed in */
-        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-        return -FAILURE;
-    }
-
-    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
-
-    if (bitlen == 0)
-    {
-        /* Finish any previously submitted transfers */
-	goto out;
-    }
-
-    /*
-     * The SPI controller can do non-multiple-of-8 bit
-     * transfers, but this driver currently doesn't support it.
-     */
-    if (bitlen % 8)
-    {
-        /* Errors always terminate an ongoing transfer */
-	flags |= SPI_XFER_END;
-        goto out;
-    }
-
-    /* Number of bytes to transfer */
-    byte_count = bitlen / 8;
-
-#ifdef USE_GPIO_AS_CHIP_SELECT
-    /* Ok, we are using a chip select generated by a gpio signal */
-
-    if (flags & SPI_XFER_BEGIN)
-    {
-        /* Assert the required chip SPI slave chip select */
-        spi_cs_activate(slave);
-
-        /* Enable SPI operations */
-        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
-    }
-
-    /* Start the data transfer */
-    for (len_tx = 0, len_rx = 0; len_rx < byte_count; )
-    {
-        status = SPI_READ(SSI_STATUS_REG_OFFSET);
-
-	if (len_tx < byte_count && (status & PC302_SPI_STATUS_TFNF))
-        {
-	    /* We have room in the Tx fifo */
-            if (txp)
-		value = *txp++;
-	    else
-		value = 0;
-
-            SPI_WRITE(value, SSI_DATA_REG_OFFSET);
-            len_tx++;
-	}
-
-        if (status & PC302_SPI_STATUS_RFNE)
-        {
-	    /* We have some data in the receive fifo */
-            value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
-	    if (rxp)
-	        *rxp++ = value;
-	    len_rx++;
-	}
-    }
-
-out:
-    if (flags & SPI_XFER_END)
-    {
-        /*
-	 * Wait until the transfer is completely done before
-	 * we deactivate CS.
-	 */
-        do
-        {
-	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
-            status &= PC302_SPI_STATUS_BUSY;
-
-	} while (status);
-
-	spi_cs_deactivate(slave);
-    }
-
-    return SUCCESS;
-}
-#else   /* USE_GPIO_AS_CHIP_SELECT */
-
-    /* Using the SPI block to control the chip selects,
-       therefore we need all transactions before we start anything.
-
-       Note: It is imperative that the Tx fifo never empties during operation,
-             if this happens the cs will be negated by the SPI block,
-             the spi flash will 'forget' what it is doing and it will
-             all end in tears ! */
-
-    u8 *dout_copy = NULL;
-    unsigned int byte_count_tx = 0;
-    unsigned int byte_count_rx = 0;
-    unsigned int byte_count_tx_more = 0;
-    unsigned int total_loop_count = 0;
-    unsigned int total_tx_count = 0;
-
-    if (flags & SPI_XFER_BEGIN)
-    {
-        /* If necessary take a copy of the data to transmit */
-        if (txp)
-        {
-            /* Ok, we have some data to Tx */
-
-            /* Grab some memory */
-            dout_copy = malloc(byte_count);
-            if (!dout_copy)
-            {
-                /* Oops, we have a memory management problem */
-	        printf ("Oops, memory allocation error, File: %s,"
-                        " Function: %s, Line: %d\n",
-                        __FILE__, __FUNCTION__, __LINE__);
-                return -FAILURE;
-            }
-
-            /* Lets take a copy of the data */
-            memcpy (dout_copy, dout, byte_count);
-
-            /* Save some useful info for later use */
-            spi_slave->dout_copy = dout_copy;
-            spi_slave->byte_count_tx = byte_count;
-
-            /* We have a copy of the data so can null the
-               tx data pointer */
-            txp = NULL;
-        }
-    }
-
-    if (flags & SPI_XFER_END)
-    {
-        /* Go retrieve the saved data */
-        dout_copy = spi_slave->dout_copy;
-        byte_count_tx = spi_slave->byte_count_tx ;
-
-        if (!dout_copy)
-        {
-            /* Oops, we have a memory management problem */
-	    printf ("Oops, memory allocation error, File: %s,"
-                    " Function: %s, Line: %d\n",
-                    __FILE__, __FUNCTION__, __LINE__);
-            return -FAILURE;
-        }
-
-        /* Have we any more Tx data (spi flash writing) ? */
-        if (txp)
-        {
-            byte_count_tx_more = byte_count;
-        }
-        else
-        {
-            byte_count_tx_more = 0;
-        }
-
-        /* Have we any data to Rx ? */
-        if (rxp)
-        {
-            byte_count_rx = byte_count;
-        }
-        else
-        {
-            byte_count_rx = 0;
-        }
-
-        /* Assert the required chip SPI slave chip select */
-        spi_cs_activate(slave);
-
-        /* Enable SPI block operations */
-        SPI_WRITE(PC302_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
-
-        /* Set up some variables to avoid calculating them during the loop */
-        total_loop_count = byte_count_rx + byte_count_tx + byte_count_tx_more;
-        total_tx_count = byte_count_tx + byte_count_tx_more;
-
-        spi_debug ("spi_xfer: byte_count_rx = %d\n", byte_count_rx);
-        spi_debug ("spi_xfer: byte_count_tx = %d\n", byte_count_tx);
-        spi_debug ("spi_xfer: byte_count_tx_more = %d\n", byte_count_tx_more);
-        spi_debug ("spi_xfer: total_tx_count = %d\n", total_tx_count);
-        spi_debug ("spi_xfer: total_loop_count = %d\n", total_loop_count);
-
-        for (len_tx = 0, len_rx = 0; len_rx < total_loop_count; )
-        {
-	    status = SPI_READ(SSI_STATUS_REG_OFFSET);
-
-            while (len_tx < byte_count_tx)
-            {
-	        /* The Tx fifo is 16 entries deep, we should never fill
-                   this up sending a 'command' to the flash.  Therefore
-                   we do not check the tx fifo status */
-                SPI_WRITE(*dout_copy++, SSI_DATA_REG_OFFSET);
-                len_tx++;
-            }
-
-            while ((len_tx < total_tx_count) &&
-                   (status & PC302_SPI_STATUS_TFNF))
-            {
-                /* We have more data to Tx, so just keep going */
-                SPI_WRITE(*txp++, SSI_DATA_REG_OFFSET);
-                len_tx++;
-
-                /* We may fill the tx fifo now, so a re-read of
-                   the status register is a good idea */
-                status = SPI_READ(SSI_STATUS_REG_OFFSET);
-            }
-
-            if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
-            {
-                /* We have finished Tx and we are not interested in Rx,
-                  lets get out of here */
-                break;
-            }
-
-            if ((len_tx >= total_tx_count) && (byte_count_rx != 0))
-            {
-                /* Still trying to read some data, so keep the Tx fifo
-                   tickling along, we don't care if the Tx fifo is
-                   full or overflows */
-                SPI_WRITE(0, SSI_DATA_REG_OFFSET);
-            }
-
-            if (status & PC302_SPI_STATUS_RFNE)
-            {
-	        /* We have some data available in the receive fifo */
-                value = (u8)SPI_READ(SSI_DATA_REG_OFFSET);
-
-                /* We do not want this data until it is 'valid',
-                   i.e. we have finished transmitting all the Tx data */
-                if (len_rx < total_tx_count)
-                {
-                    /* Just chuck the read data away */
-                }
-                else
-                {
-	            *rxp++ = value;
-                }
-
-                len_rx++;
-	    }
-        }
-    }
-out:
-    if (flags & SPI_XFER_END)
-    {
-        /*
-	 * If we have finished transmitting and we have no data to receive
-         * wait until the transfer is completely done before we deactivate CS.
-	 */
-        if ((len_tx >= total_tx_count) && (byte_count_rx == 0))
-        {
-            /* Make sure the SPI block has actually started
-               doing something... */
-            udelay (500);
-
-            do
-            {
-	        status = SPI_READ(SSI_STATUS_REG_OFFSET);
-                status &= PC302_SPI_STATUS_BUSY;
-
-	    } while (status);
-        }
-
-	spi_cs_deactivate(slave);
-
-        if (spi_slave->dout_copy)
-        {
-            free(spi_slave->dout_copy);
-            spi_slave->dout_copy = NULL;
-        }
-
-        spi_slave->byte_count_tx = 0;
-    }
-
-    return SUCCESS;
-
-}
-#endif  /* USE_GPIO_AS_CHIP_SELECT */
-
-void spi_cs_activate(struct spi_slave *slave)
-{
-    struct pc302_spi_slave  *spi_slave;
-    u16 chip_select = 0;
-    u32 system_config = 0;
-
-    /* Have we been passed a valid data structure handle ? */
-    if (slave == NULL)
-    {
-        /* Oops, bad handle passed in */
-        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-        return;
-    }
-
-    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
-
-    /* Make sure the SPI is disabled */
-    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
-
-    /* Obtain the chip select are we using */
-    chip_select =  (u16)spi_slave->slave.cs;
-
-    /* Write to the Slave Enable Register */
-    SPI_WRITE((1 << chip_select), SSI_SLAVE_ENABLE_REG_OFFSET);
-
-    /* Sort out the SPI/EBI chip select muxing.
-       Note: Set all chip select muxing to be SPI */
-    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
-    system_config &= ~(AXI2CFG_DECODE_MUX_0 |
-                       AXI2CFG_DECODE_MUX_1 |
-                       AXI2CFG_DECODE_MUX_2 |
-                       AXI2CFG_DECODE_MUX_3);
-
-    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
-
-#ifdef USE_GPIO_AS_CHIP_SELECT
-    /* Assert the 'cs' */
-    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) &=
-                     ~(GPIO_BIT_2);
-#endif
-
-}
-
-void spi_cs_deactivate(struct spi_slave *slave)
-{
-    struct pc302_spi_slave  *spi_slave;
-    u16 chip_select = 0;
-    u32 system_config = 0;
-
-    /* Have we been passed a valid data structure handle ? */
-    if (slave == NULL)
-    {
-        /* Oops, bad handle passed in */
-        printf ("Oops, bad handle passed in, File: %s, Function: %s,"
-                " Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-        return;
-    }
-
-    spi_slave = container_of(slave, struct pc302_spi_slave, slave);
-
-    /* Make sure the SPI is disabled */
-    SPI_WRITE(PC302_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
-
-    /* Obtain the chip select are we using */
-    chip_select =  (u16)spi_slave->slave.cs;
-
-    /* Write to the Slave Enable Register,
-       Note: Just disable all chip selects for now */
-    SPI_WRITE(PC302_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
-
-    /* Sort out the SPI/EBI chip select muxing.
-       Note: Set all chip select muxing to be EBI */
-    system_config = AXI2CFG_READ(AXI2CFG_SYS_CONFIG_REG_OFFSET);
-    system_config |= (AXI2CFG_DECODE_MUX_0 |
-                      AXI2CFG_DECODE_MUX_1 |
-                      AXI2CFG_DECODE_MUX_2 |
-                      AXI2CFG_DECODE_MUX_3);
-
-    AXI2CFG_WRITE(system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
-
-#ifdef USE_GPIO_AS_CHIP_SELECT
-    /* Negate the 'cs' */
-    *(unsigned int*)(PC302_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
-                     GPIO_BIT_2;
-#endif
-
-}
-
-#endif /* CONFIG_DW_SPI */
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/timer.c b/arch/arm/cpu/arm926ejs/pc3xx/timer.c
deleted file mode 100644
index 2a6f905..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/timer.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file timer.c
-* \brief Useful functions for timer implementation.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-/*
- * (C) Copyright 2003
- * Texas Instruments <www.ti.com>
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Marius Groeger <mgroeger@sysgo.de>
- *
- * (C) Copyright 2002
- * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
- * Alex Zuepke <azu@sysgo.de>
- *
- * (C) Copyright 2002-2004
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * (C) Copyright 2004
- * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/arch/timer.h>
-#include <div64.h>
-
-/*
- * The timer is a decrementer, it runs at a frequency of PC302_AHB_CLOCK_FREQ
- */
-
-#define READ_TIMER() (*(volatile unsigned int *)\
-		     (CONFIG_SYS_TIMERBASE + TIMERNCURRENTVALUEREGOFFSET(0)))
-
-#define TIMER_LOAD_VAL 0xFFFFFFFF
-
-static unsigned long long timestamp;
-static unsigned long lastdec;
-
-void reset_timer_masked(void)
-{
-	lastdec = READ_TIMER();
-	timestamp = 0;
-}
-
-/* Timer init function */
-int timer_init(void)
-{
-        reset_timer_masked();
-        return 0;
-}
-
-/* Restart counting from 0 */
-void reset_timer (void)
-{
-         reset_timer_masked();
-}
-
-static inline unsigned long long tick_to_time(unsigned long long tick)
-{
-	tick *= CONFIG_SYS_HZ;
-	do_div(tick, PC302_AHB_CLOCK_FREQ);
-	return tick;
-}
-
-static inline unsigned long long time_to_tick(unsigned long long time)
-{
-	time *= PC302_AHB_CLOCK_FREQ;
-	do_div(time, CONFIG_SYS_HZ);
-	return time;
-}
-
-static inline unsigned long long us_to_tick(unsigned long long us)
-{
-	us = us * PC302_AHB_CLOCK_FREQ + 999999;
-	do_div(us, 1000000);
-	return us;
-}
-
-unsigned long long get_ticks(void)
-{
-	ulong now = READ_TIMER();
-
-	if (lastdec >= now)
-		timestamp += (lastdec - now);
-	else
-		timestamp += (lastdec + TIMER_LOAD_VAL - now);
-
-	lastdec = now;
-
-	return timestamp;
-}
-
-ulong get_timer_masked(void)
-{
-	return tick_to_time(get_ticks());
-}
-
-/* Return how many HZ passed since "base" */
-ulong get_timer (ulong base)
-{
-        return get_timer_masked() - base;
-}
-
-/* Delay 'usec' micro seconds */
-void __udelay (unsigned long usec)
-{
-        unsigned long long tmp;
-	unsigned long long tmo;
-
-	tmo = us_to_tick(usec);
-	tmp = get_ticks() + tmo;
-
-	while (get_ticks() < tmp);
-}
diff --git a/arch/arm/cpu/arm926ejs/pc3xx/utilities.c b/arch/arm/cpu/arm926ejs/pc3xx/utilities.c
deleted file mode 100644
index 2774c79..0000000
--- a/arch/arm/cpu/arm926ejs/pc3xx/utilities.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file utilities.c
-* \brief Various useful functions for PC3xx devices.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-#include <asm/errno.h>
-#include <asm/arch/pc302.h>
-#include <asm/arch/axi2cfg.h>
-#include <asm/arch/fuse.h>
-#include <asm/arch/utilities.h>
-
-/* Macros ------------------------------------------------------------------ */
-/*!
- * Bit mask used to obtain the least significant 16 bits
- */
-#define SIXTEEN_BIT_MASK        ( 0xFFFF )
-
-/*!
- * Bit mask used to obtain the device ID
- */
-#define DEVICE_ID_MASK          ( 0xFF )
-
-/* Configuration port write bit positions. */
-#define CAEID_BIT_MASK     ( 1 << 19 )    /*!< Bit 19 - AE ID signal. */
-#define CADDR_BIT_MASK     ( 1 << 18 )    /*!< Bit 18 - AE ADDR signal. */
-#define CREAD_BIT_MASK     ( 1 << 17 )    /*!< Bit 17 - READ data signal. */
-#define CWRITE_BIT_MASK    ( 1 << 16 )    /*!< Bit 16 - WRITE data signal. */
-
-#define RB_FAIL_MASK       ( 1 << 17 )    /*!< Bit 17 - readback failed. */
-#define RB_VALID_MASK      ( 1 << 16 )    /*!< Bit 16 - readback valid. */
-
-#define RETRIES ( 10 )                  /*!< The number of retries for an \
-                                         *   AXI2Cfg config read. */
-
-/*! Register offset for the config bus write port (from the axi2cfg2 base
- *  address). */
-#define AXI2CFG_REG_CFG_WR ( 0x0100 )
-
-/*! Register offset for the config bus read port (from the axi2cfg2 base
- *  address). */
-#define AXI2CFG_REG_CFG_RD ( 0x0200 )
-
-/* Constants --------------------------------------------------------------- */
-
-/* Types ------------------------------------------------------------------- */
-
-/* Prototypes--------------------------------------------------------------- */
-
-/* Functions --------------------------------------------------------------- */
-__inline unsigned int
-pc302_read_from_register (const unsigned int address)
-{
-    /* Read an integer (32 bit) value from a register */
-
-    return(*(volatile unsigned int *)address);
-}
-
-__inline void
-pc302_write_to_register (const unsigned int address,
-                         const unsigned int value)
-{
-    /* Write an integer (32 bit) value to a register */
-
-    *(volatile unsigned int *)address = value;
-}
-
-unsigned int
-pc302_read_device_id (void)
-{
-    unsigned int device_id;
-
-    device_id = pc302_read_from_register (PC302_AXI2CFG_BASE +
-                                          AXI2CFG_DEVICE_ID_REG_OFFSET);
-    device_id &= DEVICE_ID_MASK;
-
-    return device_id;
-}
-
-unsigned int
-pc302_read_device_revision (void)
-{
-    unsigned int revision_code;
-
-    revision_code = pc302_read_from_register (PC302_AXI2CFG_BASE +
-                                              AXI2CFG_REVISION_ID_REG_OFFSET);
-    revision_code &= SIXTEEN_BIT_MASK;
-
-    return revision_code;
-}
-
-void pc302_read_die_id_number (unsigned int * die_number)
-{
-    /* Read the 128 bit manufacturing id from the fuses and store
-       in the provided array */
-
-    unsigned int i;
-
-    for (i = 0; i < 4; i++)
-    {
-        *die_number++ = pc302_read_from_register(PC302_FUSE_BASE +
-                                                 FUSE_MAP_24_REG_OFFSET +
-                                                 (i * sizeof (unsigned int)));
-    }
-}
-
-unsigned int
-pc302_get_rmii_enabled (void)
-{
-    unsigned int rmii_enabled;
-
-    rmii_enabled = pc302_read_from_register (PC302_AXI2CFG_BASE +
-                                             AXI2CFG_SYS_CONFIG_REG_OFFSET);
-    rmii_enabled &= AXI2CFG_RMII_EN;
-
-    return !!rmii_enabled;
-}
-
-int
-axi2cfg_config_read( u16 caeid,
-                     u16 address,
-                     u16 *data,
-                     u16 count )
-{
-    u32 val;
-    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
-    unsigned int read_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
-    u16 to_read = count;
-    u16 rc;
-    unsigned i;
-    unsigned retries;
-
-    val = caeid | CAEID_BIT_MASK;
-    pc302_write_to_register( write_p, val );
-
-    while ( to_read )
-    {
-        /* Output the address to read from. */
-        val = ( address + ( count - to_read ) ) | CADDR_BIT_MASK;
-        pc302_write_to_register( write_p, val );
-
-        /* Dispatch the read requests. */
-        rc = ( to_read > 64 ) ? 64 : to_read;
-        val = CREAD_BIT_MASK | rc;
-        pc302_write_to_register( write_p, val );
-
-        /* Now read the values. */
-        for ( i = 0; i < rc; ++i )
-        {
-            retries = RETRIES;
-            while ( retries )
-            {
-                val = pc302_read_from_register( read_p );
-                if ( val & ( RB_VALID_MASK | RB_FAIL_MASK ) )
-                    break;
-                --retries;
-            }
-
-            if ( !retries || ( val & RB_FAIL_MASK ) )
-            {
-                break;
-            }
-            else
-                data[ ( count - to_read ) + i ] = val & 0xFFFF;
-        }
-
-        if ( val & RB_FAIL_MASK )
-            break;
-
-        to_read -= rc;
-    }
-
-    return !( val & RB_FAIL_MASK ) ? count : -EIO;
-}
-
-int
-axi2cfg_config_write( u16 caeid,
-                      u16 address,
-                      u16 *data,
-                      u16 count )
-{
-    u32 val;
-    unsigned int write_p = PC302_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
-    unsigned i;
-
-    val = caeid | CAEID_BIT_MASK;
-    pc302_write_to_register( write_p, val );
-
-    /* Output the address to write to */
-    val = address | CADDR_BIT_MASK;
-    pc302_write_to_register( write_p, val );
-
-    /* Now write the values. */
-    for ( i = 0; i < count; ++i )
-    {
-        val = data[ i ] | CWRITE_BIT_MASK;
-        pc302_write_to_register( write_p, val );
-    }
-
-    return i;
-}
-
-u32
-syscfg_read(void)
-{
-    return pc302_read_from_register(PC302_AXI2CFG_BASE +
-                                    AXI2CFG_SYS_CONFIG_REG_OFFSET);
-}
-
-void
-syscfg_update(u32 mask,
-	      u32 val)
-{
-    u32 tmp = syscfg_read();
-    tmp &= ~mask;
-    tmp |= (val & mask);
-    pc302_write_to_register((PC302_AXI2CFG_BASE +
-                             AXI2CFG_SYS_CONFIG_REG_OFFSET),tmp);
-}
-
-__inline int
-is_pc3x3(void)
-{
-    u32 dev_id = pc302_read_from_register(PC302_AXI2CFG_BASE +
-                                          AXI2CFG_DEVICE_ID_REG_OFFSET);
-
-    return (dev_id == PC313_DEVICE_ID ||
-            dev_id == PC323_DEVICE_ID ||
-            dev_id == PC333_DEVICE_ID);
-}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/Makefile b/arch/arm/cpu/arm926ejs/picoxcell/Makefile
new file mode 100644
index 0000000..91d9792
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/Makefile
@@ -0,0 +1,69 @@
+#/*****************************************************************************
+# * $picoChipHeaderSubst$
+# *****************************************************************************/
+
+#/*!
+#* \file Makefile
+#* \brief
+#*
+#* Copyright (c) 2006-2011 Picochip Ltd
+#*
+#* This program is free software; you can redistribute it and/or modify
+#* it under the terms of the GNU General Public License version 2 as
+#* published by the Free Software Foundation.
+#*
+#* All enquiries to support@picochip.com
+#*/
+
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).o
+
+SOBJS-y := reset.o
+
+COBJS-y += emac.o
+COBJS-y += timer.o
+COBJS-y += spi.o
+COBJS-y += utilities.o
+COBJS-y += mux.o
+COBJS-y += gpio.o
+
+SRCS    := $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS    := $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/emac.c b/arch/arm/cpu/arm926ejs/picoxcell/emac.c
new file mode 100644
index 0000000..7b38b52
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/emac.c
@@ -0,0 +1,821 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file emac.c
+ * \brief Ethernet driver.
+ *
+ * Copyright (c) 2006-2011 Picochip Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_DW_EMAC
+
+#include <malloc.h>
+#include <asm/errno.h>
+#include <net.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/emac.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/*!
+ * \brief Timeout value (in uS) for various EMAC operations
+ */
+#define EMAC_TX_TIMEOUT             (1000)
+
+/*!
+ * \brief Timeout value (in mS) for various PHY operations
+ */
+#define EMAC_PHY_TIMEOUT            (2000)
+
+/*!
+ * \brief Length (in bytes) of a MAC address
+ */
+#define EMAC_LENGTH_OF_MAC_ADDRESS  (6)
+
+/*!
+ * \brief Default receive and transmit ring lengths
+ */
+#define EMAC_RX_NUM_DESCRIPTOR      (8)
+#define EMAC_TX_NUM_DESCRIPTOR      (2)
+#define EMAC_DESCRIPTOR_BUF_SIZE    (2048)
+
+/*!
+ * \brief Values used in the emac_priv structure
+ */
+#define EMAC_PHY_SPEED_10           (0)
+#define EMAC_PHY_SPEED_100          (1)
+#define EMAC_PHY_DUPLEX_HALF        (0)
+#define EMAC_PHY_DUPLEX_FULL        (1)
+#define EMAC_PHY_LINK_DOWN          (0)
+#define EMAC_PHY_LINK_UP            (1)
+#define EMAC_PHY_AUTO_NEG_COMPLETE  (1)
+
+/*!
+ * \brief Macros used to read from, and write to, emac registers
+ */
+#define EMAC_READ(__offset) \
+                 (*((volatile u32*)(PICOXCELL_EMAC_BASE + __offset)))
+
+#define EMAC_WRITE(__value, __offset) \
+                  (*((volatile u32*)(PICOXCELL_EMAC_BASE + __offset)) = __value)
+
+/*!
+ * \brief Define the auto-negotiation advertisement register
+ *        value.
+ *
+ * Note: This advertises 100 mpbs capability only.
+ */
+#define PHY_AUTO_NEG_ADVERT_VALUE   (0x0181)
+
+/*!
+ * \brief Align an item to a 64-bit boundary.
+ */
+#define __align64b  __attribute__((aligned(8)))
+
+/* Constants --------------------------------------------------------------- */
+
+/*!
+ * \brief This structure defines the format of the Ethernet MAC
+ *        Tx and Rx descriptors.
+ */
+struct emac_dma_descriptor {
+	/*! Used to define the Rx/Tx buffer address */
+	unsigned int buffer;
+
+	/*! Used to contain the status of the Rx/Tx operation */
+	unsigned int status;
+};
+
+/*!
+ * \brief This structure is used to hold private data for the network code
+ */
+struct emac_priv {
+	/* Useful phy state */
+	unsigned int auto_negotiation;
+	unsigned int speed;
+	unsigned int duplex;
+	unsigned int link;
+
+	/* Rx descriptor count */
+	unsigned int rx_desc;
+
+	/* Tx descriptor count */
+	unsigned int tx_desc;
+};
+
+/*!
+ * \brief Assign some memory for the Rx descriptors
+ */
+static volatile struct
+emac_dma_descriptor __align64b rx_descriptor[EMAC_RX_NUM_DESCRIPTOR];
+
+/*!
+ * \brief Assign some memory for the Tx descriptors
+ */
+static volatile struct
+emac_dma_descriptor __align64b tx_descriptor[EMAC_TX_NUM_DESCRIPTOR];
+
+/*!
+ * \brief Assign some memory for the Rx buffers
+ * \n Note: The Rx buffers have to be 64 bit aligned otherwise
+ *          very bad things happen.
+ */
+static unsigned char __align64b
+    rx_buffer[EMAC_RX_NUM_DESCRIPTOR][EMAC_DESCRIPTOR_BUF_SIZE];
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/*!
+ *
+ * \brief Read a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to read from
+ * \return The value read
+ *
+ */
+static unsigned short emac_mii_read (unsigned int phy_id,
+				     unsigned int register_number);
+
+/*!
+ *
+ * \brief Write to a register in a phy connected to the emac management port.
+ *
+ * \param phy_id The phy id of the phy to access
+ * \param register_number The register to write to
+ * \param data The data to write
+ *
+ */
+static void emac_mii_write (unsigned int phy_id,
+			    unsigned int register_number, unsigned short data);
+
+#if defined (CONFIG_CMD_MII)
+static int emac_miiphy_read (char *devname,
+			     uchar addr, uchar reg, ushort * val);
+
+static int emac_miiphy_write (char *devname, uchar addr, uchar reg, ushort val);
+#endif /*CONFIG_CMD_MII */
+
+/*!
+ *
+ * \brief Initialise the emac mdio interface
+ *
+ */
+static void emac_init_mdio (void);
+
+/*!
+ *
+ * \brief Initialise the phy connected to the emac management port.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static int emac_init_phy (struct eth_device *dev);
+
+/*!
+ *
+ * \brief Obtain the link status from the phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_phy_get_link_status (struct eth_device *dev);
+
+/*!
+ *
+ * \brief Set up the MAC address in the emac.
+ *
+ * \param dev Pointer to the eth_device structure
+ * \return Zero on success, non zero on error.
+ *
+ */
+static int emac_set_mac_addr (struct eth_device *dev);
+
+/*!
+ *
+ * \brief Initialise the emac registers.
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_startup (struct eth_device *dev);
+
+/*!
+ *
+ * \brief Initialise the emac buffer descriptors and phy.
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param bis Pointer to the board init structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_open (struct eth_device *dev, bd_t * bis);
+
+/*!
+ *
+ * \brief Receive a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_rx_packet (struct eth_device *dev);
+
+/*!
+ *
+ * \brief Transmit a packet
+ *
+ * \param dev Pointer to the eth_device structure
+ * \param packet Pointer to the packet data to transmit
+ * \param length  Length (in bytes) of the packet to send
+ * \return Zero on success, non zero on error
+ *
+ */
+static int emac_tx_packet (struct eth_device *dev,
+			   volatile void *packet, int length);
+
+/*!
+ *
+ * \brief Stop the emac
+ *
+ * \param dev Pointer to the eth_device structure
+ *
+ */
+static void emac_halt (struct eth_device *dev);
+
+/* Functions --------------------------------------------------------------- */
+
+static unsigned short emac_mii_read (unsigned int phy_id,
+				     unsigned int register_number)
+{
+	unsigned int write_data = 0x60020000;
+	unsigned int phy_management_idle = 0;
+	unsigned short value_read = 0;
+
+	/* Mask input parameters */
+	phy_id &= EMAC_PHY_ID_MASK;
+	register_number &= EMAC_PHY_REG_MASK;
+
+	write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+		       (register_number << EMAC_PHY_REG_SHIFT));
+
+	EMAC_WRITE (write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+	/* Wait for the phy access to complete */
+	do {
+		phy_management_idle =
+		    EMAC_READ (EMAC_NETWORK_STATUS_REG_OFFSET);
+		phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+	}
+	while (!phy_management_idle);
+
+	/* Read back the data obtained from the phy */
+	value_read = (unsigned short)EMAC_READ (EMAC_PHY_MAINTAIN_REG_OFFSET);
+	return (value_read);
+}
+
+static void emac_mii_write (unsigned int phy_id,
+			    unsigned int register_number, unsigned short data)
+{
+	unsigned int write_data = 0x50020000;
+	unsigned int phy_management_idle = 0;
+
+	/* Mask input parameters */
+	phy_id &= EMAC_PHY_ID_MASK;
+	register_number &= EMAC_PHY_REG_MASK;
+
+	write_data |= ((phy_id << EMAC_PHY_ID_SHIFT) |
+		       (register_number << EMAC_PHY_REG_SHIFT) | data);
+	EMAC_WRITE (write_data, EMAC_PHY_MAINTAIN_REG_OFFSET);
+
+	/* Wait for the phy access to complete */
+	do {
+		phy_management_idle =
+		    EMAC_READ (EMAC_NETWORK_STATUS_REG_OFFSET);
+		phy_management_idle &= EMAC_PHY_MANAGEMENT_IDLE;
+	}
+	while (!phy_management_idle);
+}
+
+#if defined (CONFIG_CMD_MII)
+static int emac_miiphy_read (char *devname, uchar addr, uchar reg, ushort * val)
+{
+	/* Make sure the mdio bus is initialised */
+	emac_init_mdio ();
+
+	/* Perform the mii bus read */
+	*val = emac_mii_read ((unsigned int)addr, (unsigned int)reg);
+	return 0;
+}
+
+static int emac_miiphy_write (char *devname, uchar addr, uchar reg, ushort val)
+{
+	/* Make sure the mdio bus is initialised */
+	emac_init_mdio ();
+
+	/* Perform the mdio bis write */
+	emac_mii_write ((unsigned int)addr, (unsigned int)reg,
+			(unsigned short)val);
+	return 0;
+}
+#endif /*CONFIG_CMD_MII */
+
+static void emac_init_mdio (void)
+{
+	unsigned int network_control_register = 0;
+	unsigned int network_config_register = 0;
+
+	/* Set phy management MDC Clock to 200 MHz (pclk) / 96 */
+	network_config_register = EMAC_READ (EMAC_NETWORK_CFG_REG_OFFSET);
+	network_config_register &= ~(EMAC_MDC_CLOCK_DIV_MASK);
+	network_config_register |= EMAC_MDC_CLOCK_DIV_96;
+	EMAC_WRITE (network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+	/* Enable phy management */
+	network_control_register = EMAC_READ (EMAC_NETWORK_CTRL_REG_OFFSET);
+	network_control_register |= EMAC_MDIO_ENABLE;
+	EMAC_WRITE (network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+}
+
+static int emac_init_phy (struct eth_device *dev)
+{
+	struct emac_priv *priv = dev->priv;
+
+	unsigned int device_id = picoxcell_get_device_id ();
+	unsigned int device_rev = picoxcell_get_revision ();
+
+	/* Setup the MDIO bus for Phy communications */
+	emac_init_mdio ();
+
+	/* If we are running on PC3x2 Rev D silicon and we are using a
+	 * Reduced MII (RMII) connected Ethernet Phy then we need the
+	 * link speed to be 100 mbps.
+	 */
+	if (((device_id == PC302_DEVICE_ID)
+	     || (device_id == PC312_DEVICE_ID))
+	    && (device_rev == PC3X2_REV_D) && picoxcell_get_rmii_enabled ()) {
+		/* Are we already set for 100 mpbs ? */
+		emac_phy_get_link_status (dev);
+		if (priv->speed == EMAC_PHY_SPEED_100) {
+			/* No need to do anything */
+		} else {
+			/* Setup the phy auto-negotiation advertisement register */
+			emac_mii_write (CONFIG_PHY_ADDR, MII_ADVERTISE,
+					PHY_AUTO_NEG_ADVERT_VALUE);
+
+			/* Re-start auto-negotiation */
+			emac_mii_write (CONFIG_PHY_ADDR, MII_BMCR,
+					(BMCR_ANENABLE | BMCR_ANRESTART));
+
+			/* Allow some time for the auto-negotiation process to start */
+			udelay (100);
+		}
+	}
+
+	/* Get the phy status */
+	emac_phy_get_link_status (dev);
+
+	if (priv->link == EMAC_PHY_LINK_DOWN) {
+		/* Oops, no valid link established, time to bail out */
+		printf ("%s: Link down !\n", dev->name);
+		return (-1);
+	} else {
+		/* We have a valid link established
+		 * so we can report the phy setup
+		 */
+		printf ("%s: Link up\n", dev->name);
+
+		if (priv->auto_negotiation == EMAC_PHY_AUTO_NEG_COMPLETE) {
+			printf ("%s: Auto-Negotiation complete\n", dev->name);
+		}
+
+		if (priv->speed == EMAC_PHY_SPEED_100) {
+			printf ("%s: 100Mbps\n", dev->name);
+		} else {
+			printf ("%s: 10Mbps\n", dev->name);
+		}
+
+		if (priv->duplex == EMAC_PHY_DUPLEX_FULL) {
+			printf ("%s: Full-duplex\n", dev->name);
+		} else {
+			printf ("%s: Half-duplex\n", dev->name);
+		}
+	}
+	return (0);
+}
+
+static void emac_phy_get_link_status (struct eth_device *dev)
+{
+	struct emac_priv *priv = dev->priv;
+	unsigned short phy_control = 0;
+	unsigned short phy_status = 0;
+	unsigned short ana = 0;
+	unsigned short anlpa = 0;
+	unsigned int timebase = 0;
+
+	/* Initialise the phy status parameters in the private data structure */
+	priv->auto_negotiation = ~(EMAC_PHY_AUTO_NEG_COMPLETE);
+	priv->link = EMAC_PHY_LINK_DOWN;
+	priv->speed = EMAC_PHY_SPEED_10;
+	priv->duplex = EMAC_PHY_DUPLEX_HALF;
+
+	/* Check to make sure the phy has auto-negotiation enabled */
+	phy_control = emac_mii_read (CONFIG_PHY_ADDR, MII_BMCR);
+	if (phy_control & BMCR_ANENABLE) {
+		/* Auto-negotiation is enabled
+		 * now need to check on auto-negotiation progress
+		 */
+		phy_status = emac_mii_read (CONFIG_PHY_ADDR, MII_BMSR);
+		if (phy_status & BMSR_ANEGCAPABLE) {
+			/* The phy is auto-negotiation capable */
+			timebase = get_timer (0);
+			do {
+				phy_status =
+				    emac_mii_read (CONFIG_PHY_ADDR, MII_BMSR);
+				if (phy_status & BMSR_ANEGCOMPLETE) {
+					/* Auto-negotiation has completed */
+					priv->auto_negotiation =
+					    EMAC_PHY_AUTO_NEG_COMPLETE;
+					break;
+				}
+			}
+			while (get_timer (timebase) < EMAC_PHY_TIMEOUT);
+
+			if (phy_status & BMSR_LSTATUS) {
+				/* We have a valid link established */
+				priv->link = EMAC_PHY_LINK_UP;
+			} else {
+				/* We do not have a valid link established */
+				priv->link = EMAC_PHY_LINK_DOWN;
+			}
+
+			/* Read the auto-negotiation advertisement register */
+			ana = emac_mii_read (CONFIG_PHY_ADDR, MII_ADVERTISE);
+
+			/* Read the auto-negotiation link partner ability register */
+			anlpa = emac_mii_read (CONFIG_PHY_ADDR, MII_LPA);
+
+			anlpa &= ana;
+
+			if (anlpa & (LPA_100FULL | LPA_100HALF)) {
+				priv->speed = EMAC_PHY_SPEED_100;
+
+				if (anlpa & LPA_100FULL) {
+					priv->duplex = EMAC_PHY_DUPLEX_FULL;
+				}
+			} else {
+				if (anlpa & LPA_10FULL) {
+					priv->duplex = EMAC_PHY_DUPLEX_FULL;
+				}
+			}
+		}
+	}
+
+	if (priv->auto_negotiation != EMAC_PHY_AUTO_NEG_COMPLETE) {
+		/* Auto-negotiation is not enabled or failed for some reason
+		 * so we just get phy setup from the status and control registers
+		 */
+		phy_control = emac_mii_read (CONFIG_PHY_ADDR, MII_BMCR);
+		phy_status = emac_mii_read (CONFIG_PHY_ADDR, MII_BMSR);
+		if (phy_status & BMSR_LSTATUS) {
+			priv->link = EMAC_PHY_LINK_UP;
+		} else {
+			priv->link = EMAC_PHY_LINK_DOWN;
+		}
+
+		if (phy_control & BMCR_SPEED100) {
+			priv->speed = EMAC_PHY_SPEED_100;
+		} else {
+			priv->speed = EMAC_PHY_SPEED_10;
+		}
+
+		if (phy_control & BMCR_FULLDPLX) {
+			priv->duplex = EMAC_PHY_DUPLEX_FULL;
+		} else {
+			priv->duplex = EMAC_PHY_DUPLEX_HALF;
+		}
+	}
+}
+
+static int emac_set_mac_addr (struct eth_device *dev)
+{
+	unsigned int mac_addr_bottom = 0;
+	unsigned int mac_addr_top = 0;
+
+	mac_addr_bottom = dev->enetaddr[0] |
+	    dev->enetaddr[1] << 8 |
+	    dev->enetaddr[2] << 16 | dev->enetaddr[3] << 24;
+
+	mac_addr_top = dev->enetaddr[4] | dev->enetaddr[5] << 8;
+
+	EMAC_WRITE (mac_addr_bottom, EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET);
+	EMAC_WRITE (mac_addr_top, EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET);
+
+	return 0;
+}
+
+static void emac_startup (struct eth_device *dev)
+{
+	struct emac_priv *priv = dev->priv;
+	unsigned int network_config_register = 0;
+	unsigned int network_control_register = 0;
+	unsigned int dma_config_register = 0;
+
+	/* Make sure the Tx & Rx are halted */
+	network_control_register = EMAC_READ (EMAC_NETWORK_CTRL_REG_OFFSET);
+	network_control_register &= ~(EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+	EMAC_WRITE (network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+	/* Get the MAC address from environment variables
+	 *
+	 * Note: We do this again here just incase the MAC
+	 * address has been changed since U-Boot has started up
+	 */
+	eth_getenv_enetaddr ("ethaddr", dev->enetaddr);
+
+	/* Set the hardware MAC address
+	 *
+	 * Note: We do this again here just incase the MAC
+	 * address has been changed since U-Boot has started up
+	 */
+	(void)emac_set_mac_addr (dev);
+
+	/* Setup the Rx Buffer Queue Base Address */
+	EMAC_WRITE ((unsigned int)&rx_descriptor,
+		    EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+	/* Setup the Tx Buffer Queue Base Address */
+	EMAC_WRITE ((unsigned int)&tx_descriptor,
+		    EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET);
+
+	/* Setup the size of the DMA Receive Buffer */
+	dma_config_register = EMAC_READ (EMAC_DMA_CFG_REG_OFFSET);
+	dma_config_register &= ~(EMAC_DMA_RX_BUFFER_SIZE_MASK);
+	dma_config_register |= EMAC_DMA_RX_BUFFER_SIZE;
+	EMAC_WRITE (dma_config_register, EMAC_DMA_CFG_REG_OFFSET);
+
+	/* Setup the Network Configuration Register */
+	network_config_register = EMAC_READ (EMAC_NETWORK_CFG_REG_OFFSET);
+	network_config_register |= EMAC_64_BIT_AMBA_DATA_BUS_WITDH;
+	network_config_register |= EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD;
+	network_config_register |= EMAC_FCS_REMOVE;
+
+	if (priv->duplex == EMAC_PHY_DUPLEX_FULL) {
+		network_config_register |= EMAC_FULL_DUPLEX;
+	} else {
+		network_config_register &= ~(EMAC_FULL_DUPLEX);
+	}
+
+	if (priv->speed == EMAC_PHY_SPEED_100) {
+		network_config_register |= EMAC_SPEED_100_MBPS;
+	} else {
+		network_config_register &= ~(EMAC_SPEED_100_MBPS);
+	}
+
+	EMAC_WRITE (network_config_register, EMAC_NETWORK_CFG_REG_OFFSET);
+
+	/* Setup the Network Control Register */
+	network_control_register = EMAC_READ (EMAC_NETWORK_CTRL_REG_OFFSET);
+	network_control_register |= (EMAC_RX_ENABLE | EMAC_TX_ENABLE);
+	EMAC_WRITE (network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+}
+
+static int emac_open (struct eth_device *dev, bd_t * bis)
+{
+	struct emac_priv *priv = dev->priv;
+	unsigned int i = 0;;
+	unsigned int buffer_address = 0;
+	unsigned int ret = 0;
+
+	/* Initialise the Rx descriptor count */
+	priv->rx_desc = 0;
+
+	/* Initialise the Tx descriptor count */
+	priv->tx_desc = 0;
+
+	/* Initialise the Rx descriptors */
+	for (i = 0; i < EMAC_RX_NUM_DESCRIPTOR; i++) {
+		buffer_address = (unsigned int)&rx_buffer[i][0];
+		if (i == (EMAC_RX_NUM_DESCRIPTOR - 1)) {
+			/* we are on the last descriptor entry */
+			buffer_address |= EMAC_RX_DESC_WRAP;
+		}
+		rx_descriptor[i].buffer = buffer_address;
+		rx_descriptor[i].status = 0;
+	}
+
+	/* Initialise the Tx descriptors */
+	for (i = 0; i < EMAC_TX_NUM_DESCRIPTOR; i++) {
+		tx_descriptor[i].buffer = 0;
+		tx_descriptor[i].status = EMAC_TX_DESC_HOST_OWN;
+
+		if (i == (EMAC_TX_NUM_DESCRIPTOR - 1)) {
+			/* we are on the last descriptor entry */
+			tx_descriptor[i].status |= EMAC_TX_DESC_WRAP;
+		}
+	}
+
+	/* Check out the phy status */
+	ret = emac_init_phy (dev);
+	if (ret != 0) {
+		/* Oops, we've had an error */
+		return (ret);
+	}
+
+	/* Initialise the emac registers */
+	emac_startup (dev);
+
+	return (0);
+}
+
+static int emac_rx_packet (struct eth_device *dev)
+{
+	struct emac_priv *priv = dev->priv;
+	unsigned int start_of_frame = 0;
+	unsigned int end_of_frame = 0;
+	unsigned int frame_error = 0;
+	unsigned int length = 0;
+	void *buffer_start;
+
+	if (rx_descriptor[priv->rx_desc].buffer & EMAC_RX_DESC_HOST_OWN) {
+		/* We have some received data */
+
+		/* Make sure we have a whole frame */
+		start_of_frame = rx_descriptor[priv->rx_desc].status &
+		    EMAC_RX_DESC_START_OF_FRAME;
+		end_of_frame = rx_descriptor[priv->rx_desc].status &
+		    EMAC_RX_DESC_END_OF_FRAME;
+		if (start_of_frame && end_of_frame) {
+			/* We have a complete frame */
+			length = rx_descriptor[priv->rx_desc].status &
+			    EMAC_RX_DESC_LENGTH_MASK;
+
+			/* Noodle the buffer start address for the higher level
+			 * network stack. The start address should be 8 byte aligned,
+			 * also bits 0 & 1 can be set by the emac, so these need to
+			 * be masked out as well
+			 */
+
+			buffer_start = (void *)
+			    (rx_descriptor[priv->rx_desc].buffer & 0xFFFFFFF8);
+
+			/* Send received packet to the higher network layers */
+			NetReceive (buffer_start, length);
+		} else {
+			/* Oops, not a complete frame */
+			frame_error++;
+		}
+
+		/* Reclaim the buffer just used */
+		rx_descriptor[priv->rx_desc].buffer &= ~(EMAC_RX_DESC_HOST_OWN);
+
+		/* Increment the Rx descriptor counter */
+		priv->rx_desc++;
+		if (priv->rx_desc == EMAC_RX_NUM_DESCRIPTOR) {
+			/* We have exhausted the supply of Rx descriptors */
+			priv->rx_desc = 0;
+		}
+	}
+
+	if (frame_error) {
+		printf ("frame error\n");
+		return (1);
+	}
+
+	return (0);
+}
+
+static int emac_tx_packet (struct eth_device *dev,
+			   volatile void *packet, int length)
+{
+	struct emac_priv *priv = dev->priv;
+	unsigned int i = 0;
+	unsigned int network_control_register = 0;
+
+	/* Set up the Tx descriptor */
+
+	/* Make sure the wrap bit is set for the last descriptor */
+	if (priv->tx_desc == (EMAC_TX_NUM_DESCRIPTOR - 1)) {
+		/* we are on the last descriptor entry */
+		tx_descriptor[priv->tx_desc].status = EMAC_TX_DESC_WRAP;
+	}
+
+	tx_descriptor[priv->tx_desc].status |=
+	    length & EMAC_TX_BUFFER_LENGTH_MASK;
+	tx_descriptor[priv->tx_desc].status |= EMAC_TX_LAST_BUFFER;
+	tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_NO_CRC_APPEND);
+	tx_descriptor[priv->tx_desc].status &= ~(EMAC_TX_DESC_HOST_OWN);
+
+	/* Setup the Tx descriptor buffer */
+	tx_descriptor[priv->tx_desc].buffer = (unsigned int)packet;
+
+	/* Start the packet transmission */
+	network_control_register = EMAC_READ (EMAC_NETWORK_CTRL_REG_OFFSET);
+	network_control_register |= EMAC_START_TX;
+	EMAC_WRITE (network_control_register, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+	/* Wait for transmission to complete */
+	for (i = 0; i <= EMAC_TX_TIMEOUT; i++) {
+		if (tx_descriptor[priv->tx_desc].status & EMAC_TX_DESC_HOST_OWN) {
+			/* The emac has completed transmission */
+			break;
+		}
+		udelay (1);
+	}
+
+	/* Increment the Tx descriptor counter */
+	priv->tx_desc++;
+	if (priv->tx_desc == EMAC_TX_NUM_DESCRIPTOR) {
+		/* We have exhausted the supply of Tx descriptors */
+		priv->tx_desc = 0;
+	}
+
+	/* We could add some error reporting in here, but no one cares anyway */
+	return (0);
+}
+
+static void emac_halt (struct eth_device *dev)
+{
+	unsigned int status_register = 0;
+
+	/* Halt the Tx & Rx */
+	EMAC_WRITE (0, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+	/* Clear the statistics counters */
+	EMAC_WRITE (EMAC_CLEAR_STATS_REGISTERS, EMAC_NETWORK_CTRL_REG_OFFSET);
+
+	/* Clear the Tx status registers */
+	status_register = EMAC_READ (EMAC_TX_STATUS_REG_OFFSET);
+	EMAC_WRITE (status_register, EMAC_TX_STATUS_REG_OFFSET);
+
+	/* Clear the Rx status registers */
+	status_register = EMAC_READ (EMAC_RX_STATUS_REG_OFFSET);
+	EMAC_WRITE (status_register, EMAC_RX_STATUS_REG_OFFSET);
+}
+
+int picoxcell_eth_register (bd_t * bis)
+{
+	struct eth_device *dev = NULL;
+	struct emac_priv *priv = NULL;
+
+	/* Create some storage for useful structures */
+	dev = (struct eth_device *)malloc (sizeof (*dev));
+	if (dev == NULL) {
+		/* Oops, no memory available */
+		return -ENOMEM;
+	}
+
+	priv = (struct emac_priv *)malloc (sizeof (*priv));
+	if (priv == NULL) {
+		/* Oops, no memory available */
+		free (dev);
+		return -ENOMEM;
+	}
+
+	dev->priv = priv;
+
+	/* Reset the private data */
+	memset (priv, 0, sizeof (struct emac_priv));
+
+	/* Define our name */
+	sprintf (dev->name, "emac");
+
+	dev->init = emac_open;
+	dev->recv = emac_rx_packet;
+	dev->send = emac_tx_packet;
+	dev->halt = emac_halt;
+	dev->write_hwaddr = emac_set_mac_addr;
+
+	/* Register our emac driver with the networking environment */
+	(void)eth_register (dev);
+
+	/* Get the MAC address from environment variables */
+	eth_getenv_enetaddr ("ethaddr", dev->enetaddr);
+
+	/* Set the hardware MAC address */
+	(void)emac_set_mac_addr (dev);
+
+#if defined (CONFIG_CMD_MII)
+	miiphy_register (dev->name, emac_miiphy_read, emac_miiphy_write);
+#endif
+
+	return 0;
+}
+
+#endif /* CONFIG_DW_EMAC */
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/gpio.c b/arch/arm/cpu/arm926ejs/picoxcell/gpio.c
new file mode 100644
index 0000000..e4817f6
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/gpio.c
@@ -0,0 +1,1041 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file gpio.c
+ * \brief GPIO driver.
+ *
+ * Copyright (c) 2009-2011 Picochip Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/picoxcell_gpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+#define __iomem
+#define _ioa (void __iomem *)
+#define readl(addr) (picoxcell_read_register((unsigned int)addr))
+#define writel(val, addr) (picoxcell_write_register(val, (unsigned int)addr))
+
+/* The number of gpio pins that this drover can handle */
+#define ARCH_NR_GPIOS 128
+
+#define BITS_PER_BYTE 8
+#define BITS_TO_LONGS(nr) \
+        DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
+#define DECLARE_BITMAP(name,bits) \
+        unsigned long name[BITS_TO_LONGS(bits)]
+
+/* Constants --------------------------------------------------------------- */
+/**
+ * struct gpio_chip - abstract a GPIO controller
+ * @label: for diagnostics
+ * @request: optional hook for chip-specific activation, such as
+ *	enabling module power and clock; may sleep
+ * @free: optional hook for chip-specific deactivation, such as
+ *	disabling module power and clock; may sleep
+ * @direction_input: configures signal "offset" as input, or returns error
+ * @get: returns value for signal "offset"; for output signals this
+ *	returns either the value actually sensed, or zero
+ * @direction_output: configures signal "offset" as output, or returns error
+ * @set: assigns output value for signal "offset"
+ * @base: identifies the first GPIO number handled by this chip; or, if
+ *	negative during registration, requests dynamic ID allocation.
+ * @ngpio: the number of GPIOs handled by this controller; the last GPIO
+ *	handled is (base + ngpio - 1).
+ * @names: if set, must be an array of strings to use as alternative
+ *      names for the GPIOs in this chip. Any entry in the array
+ *      may be NULL if there is no alias for the GPIO, however the
+ *      array must be @ngpio entries long.
+ *
+ * A gpio_chip can help platforms abstract various sources of GPIOs so
+ * they can all be accessed through a common programing interface.
+ * Example sources would be SOC controllers, FPGAs, multifunction
+ * chips, dedicated GPIO expanders, and so on.
+ *
+ * Each chip controls a number of signals, identified in method calls
+ * by "offset" values in the range 0..(@ngpio - 1).  When those signals
+ * are referenced through calls like gpio_get_value(gpio), the offset
+ * is calculated by subtracting @base from the gpio number.
+ */
+struct gpio_chip {
+	const char *label;
+
+	int (*request) (struct gpio_chip * chip, unsigned offset);
+	void (*free) (struct gpio_chip * chip, unsigned offset);
+
+	int (*direction_input) (struct gpio_chip * chip, unsigned offset);
+	int (*get) (struct gpio_chip * chip, unsigned offset);
+	int (*direction_output) (struct gpio_chip * chip,
+				 unsigned offset, int value);
+	void (*set) (struct gpio_chip * chip, unsigned offset, int value);
+
+	int base;
+	u16 ngpio;
+	char **names;
+};
+
+DECLARE_BITMAP (pin_status, ARCH_NR_GPIOS);
+
+struct gpio_desc {
+	struct gpio_chip *chip;
+};
+
+static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
+
+/* Functions --------------------------------------------------------------- */
+static int armgpio_request (struct gpio_chip *chip, unsigned offset)
+{
+	enum mux_setting mux;
+
+	if (test_and_set_bit (offset + chip->base, pin_status))
+		return -EBUSY;
+
+	/* Check the pin has been correctly multiplexed. */
+	mux = picoxcell_get_pin_mux (offset + chip->base);
+	if (!(mux & (MUX_ARM | MUX_UNMUXED))) {
+		/* The pin has an inconsistent mux setting. */
+		printf
+		    ("attempt to request armgpio%u which is not correctly multiplexed\n",
+		     chip->base + offset);
+		test_and_clear_bit (offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void armgpio_free (struct gpio_chip *chip, unsigned offset)
+{
+	test_and_clear_bit (offset + chip->base, pin_status);
+}
+
+#define GPIO_SW_PORT_A_EXT_REG_OFFSET	GPIO_EXT_PORT_A_REG_OFFSET
+#define GPIO_SW_PORT_B_EXT_REG_OFFSET	GPIO_EXT_PORT_B_REG_OFFSET
+#define GPIO_SW_PORT_D_EXT_REG_OFFSET	GPIO_EXT_PORT_D_REG_OFFSET
+
+static inline int armgpio_block_nr (unsigned gpio_nr)
+{
+	if (!is_pc3x3 ()) {
+		/*
+		 * PC3X2 has GPIOs numbered in non contiguous blocks.
+		 */
+		if (gpio_nr < PC302_GPIO_PIN_ARM_8)
+			return gpio_nr - PC302_GPIO_PIN_ARM_0;
+		else
+			return gpio_nr - PC302_GPIO_PIN_ARM_8 + 8;
+	} else {
+		/*
+		 * For PC3X3, ARM GPIO's are numbered from 0->MAX.
+		 */
+		return gpio_nr;
+	}
+
+	return -ENXIO;
+}
+
+#define __ARMGPIO_REG(_gpio_base, _reg)					    \
+	({								    \
+		void __iomem *ret = NULL;				    \
+		int __gpio_nr = armgpio_block_nr(_gpio_base);		    \
+		if (__gpio_nr < 8)					    \
+			ret = _ioa(PICOXCELL_GPIO_BASE +			    \
+				GPIO_SW_PORT_A_##_reg##_REG_OFFSET);	    \
+		else if (__gpio_nr < 24)				    \
+			ret = _ioa(PICOXCELL_GPIO_BASE +			    \
+				GPIO_SW_PORT_B_##_reg##_REG_OFFSET);	    \
+		else							    \
+			ret = _ioa(PICOXCELL_GPIO_BASE +			    \
+				GPIO_SW_PORT_D_##_reg##_REG_OFFSET);	    \
+		ret;							    \
+	})
+
+#define ARMGPIO_DR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DR)
+#define ARMGPIO_DDR(_gpio_base)	    __ARMGPIO_REG(_gpio_base, DDR)
+#define ARMGPIO_CTL(_gpio_base)	    __ARMGPIO_REG(_gpio_base, CTL)
+#define ARMGPIO_EXT(_gpio_base)	    __ARMGPIO_REG(_gpio_base, EXT)
+
+static inline unsigned armgpio_offset (unsigned offset)
+{
+	if (is_pc3x3 ()) {
+		/*
+		 * The arm gpios in PC3x3 are controlled via three sets of
+		 * registers. The register addressing is already taken care
+		 * of by the __ARMGPIO_REG macro, this takes care of the bit
+		 * offsets within each register.
+		 */
+		if (offset < 8)	/* GPIO Port A */
+			return offset;
+		else if (offset < 24)	/* GPIO Port B */
+			return offset - 8;
+		else		/* GPIO Port D */
+			return offset - 24;
+	}
+
+	return offset;
+}
+
+static int armgpio_direction_input (struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *ddr = ARMGPIO_DDR (chip->base + offset);
+	void __iomem *cr = ARMGPIO_CTL (chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset (offset);
+
+	/* Mark the pin as an output. */
+	val = readl (ddr);
+	val &= ~(1 << bit_offset);
+	writel (val, ddr);
+
+	/* Set the pin as software controlled. */
+	val = readl (cr);
+	val &= ~(1 << bit_offset);
+	writel (val, cr);
+
+	return 0;
+}
+
+static void armgpio_set (struct gpio_chip *chip, unsigned offset, int value);
+
+static int
+armgpio_direction_output (struct gpio_chip *chip, unsigned offset, int value)
+{
+	void __iomem *ddr = ARMGPIO_DDR (chip->base + offset);
+	void __iomem *cr = ARMGPIO_CTL (chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset (offset);
+
+	/* Set the value first so we don't glitch. */
+	armgpio_set (chip, offset, value);
+
+	/* Mark the pin as an output. */
+	val = readl (ddr);
+	val |= (1 << bit_offset);
+	writel (val, ddr);
+
+	/* Set the pin as software controlled. */
+	val = readl (cr);
+	val &= ~(1 << bit_offset);
+	writel (val, cr);
+
+	return 0;
+}
+
+static int armgpio_get (struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *ext = ARMGPIO_EXT (chip->base + offset);
+	unsigned long bit_offset = armgpio_offset (offset);
+
+	return ! !(readl (ext) & (1 << bit_offset));
+}
+
+static void armgpio_set (struct gpio_chip *chip, unsigned offset, int value)
+{
+	void __iomem *dr = ARMGPIO_DR (chip->base + offset);
+	unsigned long val, bit_offset = armgpio_offset (offset);
+
+	val = readl (dr);
+	val &= ~(1 << bit_offset);
+	val |= (! !value << bit_offset);
+	writel (val, dr);
+}
+
+/*
+ * PC3X2 ARM GPIO chips. One chip per port.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X2
+char *pc3x2_armgpio_lo_pins[] = {
+	"arm0",
+	"arm1",
+	"arm2",
+	"arm3",
+	"arm4",
+	"arm5",
+	"arm6",
+	"arm7",
+};
+
+static struct gpio_chip pc3x2_arm_gpio_lo = {
+	.label = "armgpio_lo",
+	.request = armgpio_request,
+	.free = armgpio_free,
+	.direction_input = armgpio_direction_input,
+	.direction_output = armgpio_direction_output,
+	.get = armgpio_get,
+	.set = armgpio_set,
+	.base = PC302_GPIO_PIN_ARM_0,
+	.ngpio = ARRAY_SIZE (pc3x2_armgpio_lo_pins),
+	.names = pc3x2_armgpio_lo_pins,
+};
+
+char *pc3x2_armgpio_shared_pins[] = {
+	"arm8",
+	"arm9",
+	"arm10",
+	"arm11",
+	"arm12",
+	"arm13",
+	"arm14",
+	"arm15",
+};
+
+static struct gpio_chip pc3x2_arm_gpio_shared = {
+	.label = "armgpio_shared",
+	.request = armgpio_request,
+	.free = armgpio_free,
+	.direction_input = armgpio_direction_input,
+	.direction_output = armgpio_direction_output,
+	.get = armgpio_get,
+	.set = armgpio_set,
+	.ngpio = ARRAY_SIZE (pc3x2_armgpio_shared_pins),
+	.base = PC302_GPIO_PIN_ARM_8,
+	.names = pc3x2_armgpio_shared_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+#ifdef CONFIG_PICOCHIP_PC3X3
+/*
+ * PC3X3 ARM GPIO chip.
+ */
+char *pc3x3_armgpio_pins[] = {
+	"arm0",
+	"arm1",
+	"arm2",
+	"arm3",
+	"arm4",
+	"arm5",
+	"arm6",
+	"arm7",
+	"arm8",
+	"arm9",
+	"arm10",
+	"arm11",
+	"arm12",
+	"arm13",
+	"arm14",
+	"arm15",
+	"arm16",
+	"arm17",
+	"arm18",
+	"arm19",
+	"arm20",
+	"arm21",
+	"arm22",
+	"arm23",
+	"arm24",
+	"arm25",
+	"arm26",
+	"arm27",
+	"arm28",
+	"arm29",
+	"arm30",
+	"arm31",
+	"arm32",
+	"arm33",
+	"arm34",
+	"arm35",
+	"arm36",
+	"arm37",
+	"arm38",
+	"arm39",
+	"arm40",
+	"arm41",
+	"arm42",
+	"arm43",
+	"arm44",
+	"arm45",
+	"arm46",
+	"arm47",
+	"arm48",
+	"arm49",
+	"arm50",
+	"arm51",
+	"arm52",
+	"arm53",
+};
+
+static struct gpio_chip pc3x3_arm_gpio = {
+	.label = "armgpio",
+	.request = armgpio_request,
+	.free = armgpio_free,
+	.direction_input = armgpio_direction_input,
+	.direction_output = armgpio_direction_output,
+	.get = armgpio_get,
+	.set = armgpio_set,
+	.base = PC3X3_GPIO_PIN_ARM_0,
+	.ngpio = ARRAY_SIZE (pc3x3_armgpio_pins),
+	.names = pc3x3_armgpio_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+/* The base address of SD-GPIO config registers in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_PIN_CONFIG_BASE           0x9800
+/* The base address of SD-GPIO analogue value registers in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_PIN_ANALOGUE_VALUE_BASE   0x9801
+/* The base address of SD-GPIO analogue rate registers in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_PIN_ANALOGUE_RATE_BASE    0x9802
+/* The address of the control value register in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_CONTROL_VAL_REG	    0x9882
+/* The address of the control value high register in the AXI2Pico (pc3x3). */
+#define PICOXCELL_GPIO_SD_CONTROL_VAL_HI_REG	    0x9883
+/* The address of the output value register in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_OUTPUT_VAL_REG	    0x9884
+/* The address of the output value high register in the AXI2Pico (pc3x3). */
+#define PICOXCELL_GPIO_SD_OUTPUT_HI_VAL_REG	    0x9885
+/* The address of the input value register in the AXI2Pico. */
+#define PICOXCELL_GPIO_SD_INPUT_VAL_REG		    0x9880
+/* The address of the input value high register in the AXI2Pico (pc3x3). */
+#define PICOXCELL_GPIO_SD_INPUT_VAL_HI_REG	    0x9880
+/* The address of the sleep register in the AXI2Pico. */
+#define PICOXCELL_AXI2PICO_SLEEP_REG		    0xA060
+/* The spacing between SD-GPIO config registers. */
+#define PICOXCELL_GPIO_SD_PIN_CONFIG_SPACING	    4
+/* Control source bit. */
+#define PICOXCELL_GPIO_SD_CONFIG_CS_MASK            ~(1 << 15)
+/* Analogue not digital bit. */
+#define PICOXCELL_GPIO_SD_CONFIG_AND		    (1 << 14)
+/* The mask for analogue converter size in the config register. */
+#define PICOXCELL_GPIO_SD_CONV_SZ_MASK		    0xF
+/* Soft reset lock bit. */
+#define PICOXCELL_GPIO_SD_CONFIG_SR_LOCK	    (1 << 13)
+/* PC302 AXI2Pico CAEID. */
+#define PICOXCELL_AXI2PICO_CAEID                    (0x9000)
+
+/*
+ * Get the address of a config register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PICOXCELL_GPIO_SD_PIN_CONFIG(_n) \
+    PICOXCELL_GPIO_SD_PIN_CONFIG_BASE + ((_n) * PICOXCELL_GPIO_SD_PIN_CONFIG_SPACING)
+
+/*
+ * Get the address of a analogue rate register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PICOXCELL_GPIO_SD_PIN_ANALOGUE_RATE(_n) \
+    PICOXCELL_GPIO_SD_PIN_ANALOGUE_RATE_BASE + \
+        ((_n) * PICOXCELL_GPIO_SD_PIN_CONFIG_SPACING)
+
+/*
+ * Get the address of a analogue value register for a SD-GPIO pin.
+ *
+ * @_n The SD-GPIO pin number.
+ *
+ * Returns the base address of the register.
+ */
+#define PICOXCELL_GPIO_SD_PIN_ANALOGUE_VAL(_n) \
+    PICOXCELL_GPIO_SD_PIN_ANALOGUE_VALUE_BASE + \
+        ((_n) * PICOXCELL_GPIO_SD_PIN_CONFIG_SPACING)
+
+static int sdgpio_reset_config (unsigned block_pin, int value)
+{
+	int ret;
+	u16 data;
+
+	ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				   PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				   &data, 1);
+	if (1 != ret) {
+		printf ("failed to read config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	if (value)
+		data |= PICOXCELL_GPIO_SD_CONFIG_SR_LOCK;
+	else
+		data &= ~PICOXCELL_GPIO_SD_CONFIG_SR_LOCK;
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				    &data, 1);
+	if (1 != ret) {
+		printf ("failed to write config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static inline int sdgpio_block_nr (unsigned gpio_nr)
+{
+	if (is_pc3x3 ()) {
+		return gpio_nr - PC3X3_GPIO_PIN_SDGPIO_0;
+	} else {
+		if (gpio_nr >= PC302_GPIO_PIN_SDGPIO_0 &&
+		    gpio_nr < PC302_GPIO_PIN_SDGPIO_7)
+			return gpio_nr - PC302_GPIO_PIN_SDGPIO_0;
+		else
+			return (gpio_nr - PC302_GPIO_PIN_SDGPIO_8) + 8;
+	}
+}
+
+static int sdgpio_request (struct gpio_chip *chip, unsigned offset)
+{
+	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
+	enum mux_setting mux;
+
+	if (test_and_set_bit (offset + chip->base, pin_status))
+		return -EBUSY;
+
+	if (sdgpio_reset_config (block_pin, 1)) {
+		test_and_clear_bit (offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	/* Check the pin has been correctly multiplexed. */
+	mux = picoxcell_get_pin_mux (offset + chip->base);
+	if (!(mux & (MUX_SD | MUX_UNMUXED))) {
+		/* The pin has an inconsistent mux setting. */
+		printf
+		    ("attempt to request sdgpio%u which is not correctly multiplexed\n",
+		     block_pin);
+		test_and_clear_bit (offset + chip->base, pin_status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void sdgpio_free (struct gpio_chip *chip, unsigned offset)
+{
+	test_and_clear_bit (offset + chip->base, pin_status);
+	picoxcell_gpio_configure_dac (chip->base + offset, 0, 0);
+}
+
+/*
+ * Create a map of which pins are analogue and not digital. We have a separate
+ * function for configuring pins as analogue. When we set analogue pins, we
+ * don't treat the int parameter as a boolean anymore.
+ */
+DECLARE_BITMAP (a_not_d_map, ARCH_NR_GPIOS);
+
+static int sdgpio_get_digital_out_status (u32 * v)
+{
+	u16 data[2] = { 0, 0 };
+
+	if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				      PICOXCELL_GPIO_SD_OUTPUT_VAL_REG,
+				      &data[0], 1))
+		return -EIO;
+
+	if (is_pc3x3 ()) {
+		if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+					      PICOXCELL_GPIO_SD_OUTPUT_HI_VAL_REG,
+					      &data[1], 1))
+			return -EIO;
+	}
+
+	*v = data[0] | (data[1] << 16);
+
+	return 0;
+}
+
+static int sdgpio_set_digital_out_status (u32 v)
+{
+	u16 data[2] = { (u16) (v & 0xFFFF), (u16) ((v >> 16) & 0xFFFF) };
+
+	if (1 != axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				       PICOXCELL_GPIO_SD_OUTPUT_VAL_REG,
+				       &data[0], 1))
+		return -EIO;
+
+	if (is_pc3x3 ()) {
+		if (1 != axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+					       PICOXCELL_GPIO_SD_OUTPUT_HI_VAL_REG,
+					       &data[1], 1))
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static void sdgpio_set (struct gpio_chip *chip, unsigned offset, int value)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
+
+	if (!test_bit (chip->base + offset, a_not_d_map)) {
+		u32 status;
+
+		if (sdgpio_get_digital_out_status (&status)) {
+			printf ("failed to read SDGPIO output value reg\n");
+			return;
+		}
+
+		status &= ~(1 << block_pin);
+		status |= (! !value) << block_pin;
+
+		if (sdgpio_set_digital_out_status (status)) {
+			printf
+			    ("failed to output control register for SDGPIO pin %u\n",
+			     block_pin);
+			return;
+		}
+	} else {
+		/* Analogue mode */
+		data = (u16) value;
+		ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+					    PICOXCELL_GPIO_SD_PIN_ANALOGUE_VAL
+					    (block_pin), &data, 1);
+		if (1 != ret) {
+			printf
+			    ("failed to write analogue value register for SDGPIO pin %u\n",
+			     block_pin);
+			return;
+		}
+	}
+}
+
+static int sdgpio_get_digital_in_status (u32 * v)
+{
+	u16 data[2] = { 0, 0 };
+
+	if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				      PICOXCELL_GPIO_SD_INPUT_VAL_REG, &data[0],
+				      1))
+		return -EIO;
+
+	if (is_pc3x3 ()) {
+		if (1 != axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+					      PICOXCELL_GPIO_SD_INPUT_VAL_HI_REG,
+					      &data[1], 1))
+			return -EIO;
+	}
+
+	*v = data[0] | (data[1] << 16);
+
+	return 0;
+}
+
+static int sdgpio_get (struct gpio_chip *chip, unsigned offset)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
+
+	if (!test_bit (chip->base + offset, a_not_d_map)) {
+		u32 status;
+
+		if (sdgpio_get_digital_in_status (&status))
+			return -EIO;
+
+		return ! !(status & (1 << block_pin));
+	} else {
+		/* Analogue mode */
+		ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+					   PICOXCELL_GPIO_SD_PIN_ANALOGUE_VAL
+					   (block_pin), &data, 1);
+		if (1 != ret) {
+			printf
+			    ("failed to read the analogue value register for SDGPIO pin %u\n",
+			     block_pin);
+			return -EIO;
+		}
+
+		return (int)data;
+	}
+}
+
+static int sdgpio_set_direction (unsigned block_pin, int input)
+{
+	int ret;
+	u16 data;
+
+	ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				   PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				   &data, 1);
+	if (1 != ret) {
+		printf ("failed to read config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	data &= PICOXCELL_GPIO_SD_CONFIG_CS_MASK;
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				    &data, 1);
+	if (1 != ret) {
+		printf ("failed to write config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	/* Configure the pin to drive or not drive the output as appropriate. */
+	ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				   PICOXCELL_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf ("failed to read SDGPIO control value register\n");
+		return -EIO;
+	}
+
+	if (input)
+		data &= ~(1 << block_pin);
+	else
+		data |= (1 << block_pin);
+
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_CONTROL_VAL_REG, &data,
+				    1);
+	if (1 != ret) {
+		printf
+		    ("failed to write control value register for SDGPIO pin %u\n",
+		     block_pin);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int
+sdgpio_direction_output (struct gpio_chip *chip, unsigned offset, int value)
+{
+	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
+	int ret = sdgpio_set_direction (block_pin, 0);
+
+	if (ret)
+		return ret;
+
+	sdgpio_set (chip, offset, value);
+
+	return 0;
+}
+
+static int sdgpio_direction_input (struct gpio_chip *chip, unsigned offset)
+{
+	unsigned block_pin = sdgpio_block_nr (chip->base + offset);
+
+	return sdgpio_set_direction (block_pin, 1);
+}
+
+int
+picoxcell_gpio_configure_dac (unsigned gpio, u8 converter_size,
+			      u16 analogue_rate)
+{
+	int ret;
+	u16 data;
+	unsigned block_pin = sdgpio_block_nr (gpio);
+
+	ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				   PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				   &data, 1);
+	if (1 != ret) {
+		printf ("failed to read config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	data &= PICOXCELL_GPIO_SD_CONFIG_CS_MASK;
+	data &= ~PICOXCELL_GPIO_SD_CONV_SZ_MASK;
+	if (!analogue_rate && !converter_size)
+		data &= ~PICOXCELL_GPIO_SD_CONFIG_AND;
+	else
+		data |= PICOXCELL_GPIO_SD_CONFIG_AND;
+	data |= (converter_size & PICOXCELL_GPIO_SD_CONV_SZ_MASK);
+
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_PIN_CONFIG (block_pin),
+				    &data, 1);
+	if (1 != ret) {
+		printf ("failed to write config register for SDGPIO pin %u\n",
+			block_pin);
+		return -EIO;
+	}
+
+	/* Configure the pin to drive the output. */
+	ret = axi2cfg_config_read (PICOXCELL_AXI2PICO_CAEID,
+				   PICOXCELL_GPIO_SD_CONTROL_VAL_REG, &data, 1);
+	if (1 != ret) {
+		printf ("failed to read SDGPIO control value register\n");
+		return -EIO;
+	}
+
+	data |= (1 << block_pin);
+
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_CONTROL_VAL_REG, &data,
+				    1);
+	if (1 != ret) {
+		printf
+		    ("failed to write control value register for SDGPIO pin %u\n",
+		     block_pin);
+		return -EIO;
+	}
+
+	/* Write the analogue rate register */
+	data = analogue_rate;
+	ret = axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				    PICOXCELL_GPIO_SD_PIN_ANALOGUE_RATE
+				    (block_pin), &data, 1);
+	if (1 != ret) {
+		printf
+		    ("failed to write analogue rate register for SDGPIO pin %u\n",
+		     block_pin);
+		return -EIO;
+	}
+
+	if (analogue_rate || converter_size)
+		test_and_set_bit (gpio, a_not_d_map);
+	else
+		test_and_clear_bit (gpio, a_not_d_map);
+
+	return 0;
+}
+
+/*
+ * PC3X2 SD-GPIO.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X2
+char *sdgpio_lo_pins[] = {
+	"sdgpio0",
+	"sdgpio1",
+	"sdgpio2",
+	"sdgpio3",
+	"sdgpio4",
+	"sdgpio5",
+	"sdgpio6",
+	"sdgpio7",
+};
+
+static struct gpio_chip pc3x2_sd_gpio_lo = {
+	.label = "sdpio_lo",
+	.request = sdgpio_request,
+	.free = sdgpio_free,
+	.direction_input = sdgpio_direction_input,
+	.direction_output = sdgpio_direction_output,
+	.get = sdgpio_get,
+	.set = sdgpio_set,
+	.ngpio = ARRAY_SIZE (sdgpio_lo_pins),
+	.base = PC302_GPIO_PIN_SDGPIO_0,
+	.names = sdgpio_lo_pins,
+};
+
+char *sdgpio_shared_pins[] = {
+	"sdgpio8",
+	"sdgpio9",
+	"sdgpio10",
+	"sdgpio11",
+	"sdgpio12",
+	"sdgpio13",
+	"sdgpio14",
+	"sdgpio15",
+};
+
+static struct gpio_chip pc3x2_sd_gpio_shared = {
+	.label = "sdgpio_shared",
+	.request = sdgpio_request,
+	.free = sdgpio_free,
+	.direction_input = sdgpio_direction_input,
+	.direction_output = sdgpio_direction_output,
+	.get = sdgpio_get,
+	.set = sdgpio_set,
+	.ngpio = ARRAY_SIZE (sdgpio_shared_pins),
+	.base = PC302_GPIO_PIN_SDGPIO_8,
+	.names = sdgpio_shared_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+/*
+ * PC3X3 SD-GPIO.
+ */
+#ifdef CONFIG_PICOCHIP_PC3X3
+char *pc3x3_sdgpio_pins[] = {
+	"sdgpio0",
+	"sdgpio1",
+	"sdgpio2",
+	"sdgpio3",
+	"sdgpio4",
+	"sdgpio5",
+	"sdgpio6",
+	"sdgpio7",
+	"sdgpio8",
+	"sdgpio9",
+	"sdgpio10",
+	"sdgpio11",
+	"sdgpio12",
+	"sdgpio13",
+	"sdgpio14",
+	"sdgpio15",
+	"sdgpio16",
+	"sdgpio17",
+	"sdgpio18",
+	"sdgpio19",
+	"sdgpio20",
+	"sdgpio21",
+	"sdgpio22",
+	"sdgpio23",
+};
+
+static struct gpio_chip pc3x3_sd_gpio = {
+	.label = "sdgpio",
+	.request = sdgpio_request,
+	.free = sdgpio_free,
+	.direction_input = sdgpio_direction_input,
+	.direction_output = sdgpio_direction_output,
+	.get = sdgpio_get,
+	.set = sdgpio_set,
+	.ngpio = ARRAY_SIZE (pc3x3_sdgpio_pins),
+	.base = PC3X3_GPIO_PIN_SDGPIO_0,
+	.names = pc3x3_sdgpio_pins,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+static struct gpio_chip *pc3x2_chips[] = {
+#ifdef CONFIG_PICOCHIP_PC3X2
+	&pc3x2_arm_gpio_lo,
+	&pc3x2_arm_gpio_shared,
+	&pc3x2_sd_gpio_lo,
+	&pc3x2_sd_gpio_shared,
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+};
+
+static struct gpio_chip *pc3x3_chips[] = {
+#ifdef CONFIG_PICOCHIP_PC3X3
+	&pc3x3_arm_gpio,
+	&pc3x3_sd_gpio,
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+};
+
+/* Public API -------------------------------------------------------------- */
+
+int picoxcell_gpio_init (void)
+{
+	int num_chips, i, ret = 0, id;
+	u16 data = 0;
+	struct gpio_chip **all_chips, *chip;
+
+	/*
+	 * Make sure that the AXI2Pico is awake for the SDGPIO transactions.
+	 */
+	if (1 != axi2cfg_config_write (PICOXCELL_AXI2PICO_CAEID,
+				       PICOXCELL_AXI2PICO_SLEEP_REG, &data,
+				       1)) {
+		printf ("unable to wake axi2pico\n");
+		return -EIO;
+	}
+
+	if (is_pc3x3 ()) {
+		num_chips = ARRAY_SIZE (pc3x3_chips);
+		all_chips = pc3x3_chips;
+	} else {
+		num_chips = ARRAY_SIZE (pc3x2_chips);
+		all_chips = pc3x2_chips;
+	}
+
+	/* Populate the gpio_desc[] array */
+	for (chip = all_chips[0], i = 0; i < num_chips; ++i, ++chip) {
+		int base = chip->base;
+		for (id = base; id < base + chip->ngpio; id++) {
+			gpio_desc[id].chip = chip;
+		}
+	}
+
+	return ret;
+}
+
+int picoxcell_gpio_request (unsigned gpio)
+{
+	struct gpio_desc *desc;
+	struct gpio_chip *chip;
+	int status = -EINVAL;
+
+	desc = &gpio_desc[gpio];
+	chip = desc->chip;
+
+	if (chip == NULL)
+		goto done;
+
+	if (chip->request) {
+		status = chip->request (chip, gpio - chip->base);
+	}
+done:
+	return status;
+}
+
+void picoxcell_gpio_free (unsigned gpio)
+{
+	struct gpio_desc *desc;
+	struct gpio_chip *chip;
+
+	desc = &gpio_desc[gpio];
+	chip = desc->chip;
+
+	if (chip->free) {
+		chip->free (chip, gpio - chip->base);
+	}
+}
+
+int picoxcell_gpio_direction_input (unsigned gpio)
+{
+	struct gpio_chip *chip;
+	struct gpio_desc *desc = &gpio_desc[gpio];
+	int status = -EINVAL;
+	chip = desc->chip;
+	if (!chip || !chip->get || !chip->direction_input)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+
+	status = chip->direction_input (chip, gpio);
+
+fail:
+	return status;
+}
+
+int picoxcell_gpio_direction_output (unsigned gpio, int value)
+{
+	struct gpio_chip *chip;
+	struct gpio_desc *desc = &gpio_desc[gpio];
+	int status = -EINVAL;
+
+	chip = desc->chip;
+	if (!chip || !chip->set || !chip->direction_output)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+
+	status = chip->direction_output (chip, gpio, value);
+
+fail:
+	return status;
+}
+
+void picoxcell_gpio_set_value (unsigned gpio, int value)
+{
+	struct gpio_chip *chip;
+	struct gpio_desc *desc = &gpio_desc[gpio];
+
+	chip = desc->chip;
+
+	chip->set (chip, gpio - chip->base, value);
+}
+
+int picoxcell_gpio_get_value (unsigned gpio)
+{
+	struct gpio_chip *chip;
+	struct gpio_desc *desc = &gpio_desc[gpio];
+
+	chip = desc->chip;
+
+	return chip->get ? chip->get (chip, gpio - chip->base) : 0;
+}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/mux.c b/arch/arm/cpu/arm926ejs/picoxcell/mux.c
new file mode 100644
index 0000000..990420b
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/mux.c
@@ -0,0 +1,1254 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file mux.c
+ * \brief Muxing control for the gpio pins.
+ *
+ * Copyright (c) 2009-2011 Picochip Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/picoxcell_gpio.h>
+
+/* Constants --------------------------------------------------------------- */
+/*
+ * A multiplexed pin. This defines the SD and ARM pins that are on the pad. If
+ * the pin does not have an SD or ARM pin then set the appropriate field to
+ * -1.
+ */
+struct muxed_pin {
+	const char *name;
+	int is_dedicated_gpio;
+	int sd_pin;
+	int arm_pin;
+	int (*set_mux) (struct muxed_pin * pin, enum mux_setting setting);
+	int (*get_mux) (struct muxed_pin * pin);
+};
+
+/*
+ * A logical group of multiplexed pins. Typically this is grouped by what the
+ * pins are multiplexed with e.g. system peripheral.
+ */
+struct pin_group {
+	int nr_pins;
+	const char *name;
+	struct muxed_pin *pins;
+};
+
+/* Macros ------------------------------------------------------------------ */
+#define __PIN(_name, _sd, _arm, _set, _get)		        \
+	.name		    = __stringify(_name),		\
+	.is_dedicated_gpio  = 0,				\
+	.sd_pin		    = (_sd),				\
+	.arm_pin    	    = (_arm),				\
+	.set_mux    	    = _set,				\
+	.get_mux    	    = _get
+/*
+ * Declare a function pin that is also multiplexed with GPIO pins.
+ */
+#define PIN(_name, _sd, _arm, _set, _get) {			\
+	__PIN(_name, _sd, _arm, _set, _get),			\
+	.is_dedicated_gpio  = 0,				\
+}
+
+/*
+ * Declare a pure GPIO pin.
+ */
+#define GPIO(_name, _sd, _arm, _set, _get) {			\
+	__PIN(_name, _sd, _arm, _set, _get),			\
+	.is_dedicated_gpio  = 1,				\
+}
+
+/* Functions --------------------------------------------------------------- */
+/*****************************************************************************
+ * PC302 pin multiplexing.
+ ****************************************************************************/
+#ifdef CONFIG_PICOCHIP_PC3X2
+
+static int pai_get_mux (struct muxed_pin *pin)
+{
+#define PAI_GPIO_PIN_ARM_4	0xB
+#define PAI_GPIO_PIN_ARM_5	0xA
+#define PAI_GPIO_PIN_ARM_6	0x9
+#define PAI_GPIO_PIN_ARM_7	0x8
+#define PAI_GPIO_PIN_SDGPIO_4	0x7
+#define PAI_GPIO_PIN_SDGPIO_5	0x6
+#define PAI_GPIO_PIN_SDGPIO_6	0x5
+#define PAI_GPIO_PIN_SDGPIO_7	0x4
+#define PICOXCELL_PAI_CAEID	0x8080
+#define PAI_SLEEP_REG		0xA060
+#define PAI_IO_CTRL_REG		0x0009
+
+	/* Make sure that the PAI block is awake. */
+	u16 data = 0, sd_mask = 0, arm_mask = 0;
+	int ret = axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_SLEEP_REG,
+					&data, 1);
+	if (1 != ret) {
+		printf ("unable to wake up PAI\n");
+		return -EIO;
+	}
+
+	/* Get the current PAI muxing configuration. */
+	ret =
+	    axi2cfg_config_read (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
+				 1);
+	if (1 != ret) {
+		printf ("unable to read PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_4;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_5;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_6;
+	} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
+		sd_mask |= PAI_GPIO_PIN_SDGPIO_7;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
+		arm_mask |= PAI_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
+		arm_mask |= PAI_GPIO_PIN_ARM_5;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
+		arm_mask |= PAI_GPIO_PIN_ARM_6;
+	} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
+		arm_mask |= PAI_GPIO_PIN_ARM_7;
+	} else {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (data & sd_mask)
+		ret = MUX_SD;
+	else if (data & arm_mask)
+		ret = MUX_ARM;
+	else
+		ret = MUX_PERIPHERAL;
+
+out:
+	return ret;
+}
+
+static int pai_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	/* Make sure that the PAI block is awake. */
+	u16 data = 0;
+	int err = axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_SLEEP_REG,
+					&data, 1);
+	if (1 != err) {
+		printf ("unable to wake up PAI\n");
+		return -EIO;
+	}
+
+	/* Get the current PAI muxing configuration. */
+	err =
+	    axi2cfg_config_read (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
+				 1);
+	if (1 != err) {
+		printf ("unable to read PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	if (MUX_SD == setting) {
+		if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_4) {
+			data |= PAI_GPIO_PIN_SDGPIO_4;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_5) {
+			data |= PAI_GPIO_PIN_SDGPIO_5;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_6) {
+			data |= PAI_GPIO_PIN_SDGPIO_6;
+		} else if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_7) {
+			data |= PAI_GPIO_PIN_SDGPIO_7;
+		} else {
+			err = -EINVAL;
+			goto out;
+		}
+	} else if (MUX_ARM == setting) {
+		if (pin->arm_pin == PC302_GPIO_PIN_ARM_4) {
+			data |= PAI_GPIO_PIN_ARM_4;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_5) {
+			data |= PAI_GPIO_PIN_ARM_5;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_6) {
+			data |= PAI_GPIO_PIN_ARM_6;
+		} else if (pin->arm_pin == PC302_GPIO_PIN_ARM_7) {
+			data |= PAI_GPIO_PIN_ARM_7;
+		} else {
+			err = -EINVAL;
+			goto out;
+		}
+	} else if (MUX_PERIPHERAL == setting) {
+		/*
+		 * We don't do anything here. The PAI is only driven by the
+		 * picoArray so this will be automatically set in the loadfile
+		 * when the design is next loaded.
+		 */
+		err = 0;
+	} else if (MUX_UNMUXED == setting) {
+		/* This can't be changed at run-time! */
+		return -EPERM;
+	}
+
+	err =
+	    axi2cfg_config_write (PICOXCELL_PAI_CAEID, PAI_IO_CTRL_REG, &data,
+				  1);
+	if (1 != err) {
+		printf ("unable to write PAI I/O control reg\n");
+		return -EIO;
+	}
+
+	err = 0;
+
+out:
+	return err;
+}
+
+static struct muxed_pin pai_pins[] = {
+	PIN (sdgpio4, PC302_GPIO_PIN_SDGPIO_4, -1, pai_set_mux,
+	     pai_get_mux),
+	PIN (sdgpio5, PC302_GPIO_PIN_SDGPIO_5, -1, pai_set_mux,
+	     pai_get_mux),
+	PIN (sdgpio6, PC302_GPIO_PIN_SDGPIO_6, -1, pai_set_mux,
+	     pai_get_mux),
+	PIN (sdgpio7, PC302_GPIO_PIN_SDGPIO_7, -1, pai_set_mux,
+	     pai_get_mux),
+	PIN (arm4, -1, PC302_GPIO_PIN_ARM_4, pai_set_mux, pai_get_mux),
+	PIN (arm5, -1, PC302_GPIO_PIN_ARM_5, pai_set_mux, pai_get_mux),
+	PIN (arm6, -1, PC302_GPIO_PIN_ARM_6, pai_set_mux, pai_get_mux),
+	PIN (arm7, -1, PC302_GPIO_PIN_ARM_7, pai_set_mux, pai_get_mux),
+};
+
+static struct pin_group pai_group = {
+	.nr_pins = ARRAY_SIZE (pai_pins),
+	.name = "pai/ebi",
+	.pins = pai_pins,
+};
+
+static int shd_get_mux (struct muxed_pin *pin)
+{
+	unsigned bit;
+	unsigned long syscfg = syscfg_read ();
+
+	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
+		return MUX_PERIPHERAL;
+
+	if (pin->sd_pin == PC302_GPIO_PIN_SDGPIO_0) {
+		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
+			return MUX_PERIPHERAL;
+		else
+			return MUX_SD;
+	}
+
+	bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+		    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
+
+	return syscfg & bit ? MUX_ARM : MUX_SD;
+}
+
+static int shd_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	unsigned bit;
+	unsigned long syscfg = syscfg_read ();
+
+	/*
+	 * In parallel boot mode, shared pin 7 can't be used as it is always
+	 * on the EBI.
+	 */
+	if (0 == (syscfg & 0x3) && pin->sd_pin == PC302_GPIO_PIN_SDGPIO_15)
+		return -EBUSY;
+
+	switch (setting) {
+	case MUX_PERIPHERAL:
+		/*
+		 * SDGPIO pin 0 is shared with the Frac-N.
+		 */
+		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
+			syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
+				       AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
+			break;
+		}
+		return -EIO;
+
+	case MUX_SD:
+		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+			    pin->sd_pin - PC302_GPIO_PIN_SDGPIO_8);
+		syscfg_update (bit, 0);
+		break;
+
+	case MUX_ARM:
+		if (PC302_GPIO_PIN_SDGPIO_0 == pin->sd_pin)
+			return -EINVAL;
+		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+		bit = 1 << (AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO +
+			    pin->arm_pin - PC302_GPIO_PIN_ARM_8);
+		syscfg_update (bit, bit);
+		break;
+
+	case MUX_UNMUXED:
+		/* This can't be changed at run-time! */
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static struct muxed_pin shared_pins[] = {
+	GPIO (shared0, PC302_GPIO_PIN_SDGPIO_8, PC302_GPIO_PIN_ARM_8,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared1, PC302_GPIO_PIN_SDGPIO_9, PC302_GPIO_PIN_ARM_9,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared2, PC302_GPIO_PIN_SDGPIO_10, PC302_GPIO_PIN_ARM_10,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared3, PC302_GPIO_PIN_SDGPIO_11, PC302_GPIO_PIN_ARM_11,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared4, PC302_GPIO_PIN_SDGPIO_12, PC302_GPIO_PIN_ARM_12,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared5, PC302_GPIO_PIN_SDGPIO_13, PC302_GPIO_PIN_ARM_13,
+	      shd_set_mux,
+	      shd_get_mux),
+	GPIO (shared6, PC302_GPIO_PIN_SDGPIO_14, PC302_GPIO_PIN_ARM_14,
+	      shd_set_mux,
+	      shd_get_mux),
+	PIN (shared7, PC302_GPIO_PIN_SDGPIO_15, PC302_GPIO_PIN_ARM_15,
+	     shd_set_mux,
+	     shd_get_mux),
+};
+
+static struct pin_group shd_group = {
+	.nr_pins = ARRAY_SIZE (shared_pins),
+	.name = "shared/ebi",
+	.pins = shared_pins,
+};
+
+static struct muxed_pin fracn_pins[] = {
+	PIN (sdgpio0, PC302_GPIO_PIN_SDGPIO_0, -1, shd_set_mux,
+	     shd_get_mux),
+};
+
+static struct pin_group fracn_group = {
+	.nr_pins = ARRAY_SIZE (fracn_pins),
+	.name = "fracn/sdgpio0",
+	.pins = fracn_pins,
+};
+
+static struct pin_group *pc3x2_groups[] = {
+	&shd_group,
+	&pai_group,
+	&fracn_group,
+};
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+
+/*****************************************************************************
+ * PC3X3 pin multiplexing.
+ ****************************************************************************/
+#ifdef CONFIG_PICOCHIP_PC3X3
+
+#define SHD_GPIO_MUX_REG        (PICOXCELL_AXI2CFG_BASE + \
+				 AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET)
+#define USE_EBI_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
+				 AXI2CFG_USE_EBI_GPIO_REG_OFFSET)
+#define USE_PAI_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
+				 AXI2CFG_USE_PAI_GPIO_REG_OFFSET)
+#define USE_DECODE_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
+				 AXI2CFG_USE_DECODE_GPIO_REG_OFFSET)
+#define USE_MISC_INT_GPIO_REG	(PICOXCELL_AXI2CFG_BASE + \
+				 AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET)
+
+/*
+ * Set the muxing of one of the shared pins.
+ */
+static void pc3xx_shd_gpio_set_mux (int arm_pin_nr, enum mux_setting setting)
+{
+	unsigned long shd_mux = picoxcell_read_register (SHD_GPIO_MUX_REG);
+
+	if (MUX_ARM == setting)
+		shd_mux |= (1 << arm_pin_nr);
+	else
+		shd_mux &= ~(1 << arm_pin_nr);
+
+	picoxcell_write_register (shd_mux, SHD_GPIO_MUX_REG);
+}
+
+static int pc3xx_get_shd_mux (struct muxed_pin *pin)
+{
+	unsigned long shd_mux = picoxcell_read_register (SHD_GPIO_MUX_REG);
+	unsigned long syscfg = syscfg_read ();
+
+	if (pin->sd_pin == PC3X3_GPIO_PIN_SDGPIO_0) {
+		if (syscfg & AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK)
+			return MUX_PERIPHERAL;
+		else
+			return MUX_SD;
+	}
+
+	return shd_mux & (1 << pin->arm_pin) ? MUX_ARM : MUX_SD;
+}
+
+/*
+ * Shared ARM/SD gpio pins. These pins go to the arm_gpio[3:0] pads but can
+ * be arm or sdgpio.
+ */
+static int pc3xx_shd_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	if (MUX_PERIPHERAL == setting) {
+		if (pin->sd_pin != PC3X3_GPIO_PIN_SDGPIO_0)
+			return -EINVAL;
+
+		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK,
+			       AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK);
+	} else if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin) {
+		syscfg_update (AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK, 0);
+	}
+
+	if (PC3X3_GPIO_PIN_SDGPIO_0 == pin->sd_pin && MUX_ARM == setting)
+		return -EINVAL;
+
+	pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
+
+	return 0;
+}
+
+static struct muxed_pin armgpio_0_4[] = {
+	GPIO (arm_gpio0, PC3X3_GPIO_PIN_SDGPIO_16, PC3X3_GPIO_PIN_ARM_0,
+	      pc3xx_shd_mux,
+	      pc3xx_get_shd_mux),
+	GPIO (arm_gpio1, PC3X3_GPIO_PIN_SDGPIO_17, PC3X3_GPIO_PIN_ARM_1,
+	      pc3xx_shd_mux,
+	      pc3xx_get_shd_mux),
+	GPIO (arm_gpio2, PC3X3_GPIO_PIN_SDGPIO_18, PC3X3_GPIO_PIN_ARM_2,
+	      pc3xx_shd_mux,
+	      pc3xx_get_shd_mux),
+	GPIO (arm_gpio3, PC3X3_GPIO_PIN_SDGPIO_19, PC3X3_GPIO_PIN_ARM_3,
+	      pc3xx_shd_mux,
+	      pc3xx_get_shd_mux),
+};
+
+static struct pin_group armgpio_0_4_group = {
+	.nr_pins = ARRAY_SIZE (armgpio_0_4),
+	.name = "arm_gpio[3:0]",
+	.pins = armgpio_0_4,
+};
+
+static struct muxed_pin shd_gpio[] = {
+	GPIO (shd_gpio, PC3X3_GPIO_PIN_SDGPIO_8, PC3X3_GPIO_PIN_ARM_8,
+	      pc3xx_shd_mux,
+	      pc3xx_get_shd_mux),
+};
+
+static struct pin_group pc3x3_shd_group = {
+	.nr_pins = ARRAY_SIZE (shd_gpio),
+	.name = "shd_gpio",
+	.pins = shd_gpio,
+};
+
+/*
+ * boot_mode[1:0] pads - the pins switch to gpio automatically after boot and
+ * can be either arm or sdgpio.
+ */
+static struct muxed_pin boot_mode_0_1[] = {
+	GPIO (boot_mode0, PC3X3_GPIO_PIN_SDGPIO_9, PC3X3_GPIO_PIN_ARM_9,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+	GPIO (boot_mode1, PC3X3_GPIO_PIN_SDGPIO_10, PC3X3_GPIO_PIN_ARM_10,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group boot_mode_group = {
+	.nr_pins = ARRAY_SIZE (boot_mode_0_1),
+	.name = "boot_mode[1:0]",
+	.pins = boot_mode_0_1,
+};
+
+/*
+ * sdram_speed_sel pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin sdram_speed_sel[] = {
+	GPIO (sdram_speed_sel, PC3X3_GPIO_PIN_SDGPIO_11, PC3X3_GPIO_PIN_ARM_11,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group sdram_speed_sel_group = {
+	.nr_pins = ARRAY_SIZE (sdram_speed_sel),
+	.name = "sdram_speed_sel",
+	.pins = sdram_speed_sel,
+};
+
+/*
+ * mii_rev_en pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_rev_en[] = {
+	GPIO (mii_rev_en, PC3X3_GPIO_PIN_SDGPIO_12, PC3X3_GPIO_PIN_ARM_12,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_rev_en_group = {
+	.nr_pins = ARRAY_SIZE (mii_rev_en),
+	.name = "mii_rev_en",
+	.pins = mii_rev_en,
+};
+
+/*
+ * mii_rmii_en pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_rmii_en[] = {
+	GPIO (mii_rmii_en, PC3X3_GPIO_PIN_SDGPIO_13, PC3X3_GPIO_PIN_ARM_13,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_rmii_en_group = {
+	.nr_pins = ARRAY_SIZE (mii_rmii_en),
+	.name = "mii_rmii_en",
+	.pins = mii_rmii_en,
+};
+
+/*
+ * mii_speed_sel pad - automatically switches to gpio after boot and can be
+ * arm or sdgpio.
+ */
+static struct muxed_pin mii_speed_sel[] = {
+	GPIO (mii_speed_sel, PC3X3_GPIO_PIN_SDGPIO_14, PC3X3_GPIO_PIN_ARM_14,
+	      pc3xx_shd_mux, pc3xx_get_shd_mux),
+};
+
+static struct pin_group mii_speed_sel_group = {
+	.nr_pins = ARRAY_SIZE (mii_speed_sel),
+	.name = "mii_speed_sel",
+	.pins = mii_speed_sel,
+};
+
+static int pc3x3_shd_ebi_get_mux (struct muxed_pin *pin)
+{
+	int ebi_pin, err = 0, can_be_sd = 1;
+	unsigned long ebi_mux;
+
+	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
+
+	/*
+	 * Find out what EBI pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else {
+		/* These aren't shared gpio pins. */
+		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
+		can_be_sd = 0;
+	}
+
+	if (!(ebi_mux & (1 << (ebi_pin - 14)))) {
+		err = MUX_PERIPHERAL;
+		goto out;
+	}
+
+	if (can_be_sd)
+		err = pc3xx_get_shd_mux (pin);
+	else
+		err = MUX_ARM;
+
+out:
+	return err;
+}
+
+static int
+pc3x3_shd_ebi_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	int ebi_pin, err = 0, can_be_sd = 1;
+	unsigned long ebi_mux;
+
+	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
+
+	/*
+	 * Find out what EBI pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		ebi_pin = 22 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_4);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		ebi_pin = 18 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else {
+		/* These aren't shared gpio pins. */
+		ebi_pin = 14 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_14);
+		can_be_sd = 0;
+	}
+
+	if (MUX_SD == setting && !can_be_sd) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Use the pin as EBI. */
+	if (MUX_PERIPHERAL == setting)
+		ebi_mux &= ~(1 << (ebi_pin - 14));
+	else
+		ebi_mux |= (1 << (ebi_pin - 14));
+
+	picoxcell_write_register (ebi_mux, USE_EBI_GPIO_REG);
+
+	/*
+	 * Make sure that the configuration is valid (the GPIO isn't going to
+	 * the PAI).
+	 */
+	if (picoxcell_read_register (USE_EBI_GPIO_REG) != ebi_mux) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * If we can be SD or ARM and we want to be gpio, pick the correct
+	 * one now.
+	 */
+	if (MUX_PERIPHERAL != setting && can_be_sd)
+		pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
+
+out:
+	return err;
+}
+
+/*
+ * ebi_addr[25:18] pads - these pads can be either the EBI or arm gpio or
+ * sdgpio. Note: the gpio pins can also be routed to the pai_tx/rx_data pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the pai tx/rx data pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin ebi_addr_18_25[] = {
+	PIN (ebi_addr18, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr19, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr20, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr21, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr22, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr23, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr24, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr25, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
+	     pc3x3_shd_ebi_set_mux, pc3x3_shd_ebi_get_mux),
+};
+
+static struct pin_group ebi_addr_18_25_group = {
+	.nr_pins = ARRAY_SIZE (ebi_addr_18_25),
+	.name = "ebi_addr[25:18]",
+	.pins = ebi_addr_18_25,
+};
+
+static int pc3x3_shd_pai_get_mux (struct muxed_pin *pin)
+{
+	int bit, err = 0, can_be_sd = 1;
+	unsigned long pai_mux;
+
+	pai_mux = picoxcell_read_register (USE_PAI_GPIO_REG);
+
+	/*
+	 * Find out what pai pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		/* pai_tx_data[3:0] */
+		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		/* pai_rx_data[3:0] */
+		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
+		/* pai_tx_data[7:4] */
+		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
+		can_be_sd = 0;
+	} else {
+		/* pai_rx_data[7:4] */
+		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
+		can_be_sd = 0;
+	}
+
+	if (!(pai_mux & (1 << bit))) {
+		err = MUX_PERIPHERAL;
+		goto out;
+	}
+
+	if (can_be_sd)
+		err = pc3xx_get_shd_mux (pin);
+	else
+		err = MUX_ARM;
+
+out:
+	return err;
+}
+
+static int
+pc3x3_shd_pai_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	int bit, err = 0, can_be_sd = 1;
+	unsigned long pai_mux;
+
+	pai_mux = picoxcell_read_register (USE_PAI_GPIO_REG);
+
+	/*
+	 * Find out what pai pin our GPIO maps to.
+	 */
+	if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_4 &&
+	    pin->arm_pin < PC3X3_GPIO_PIN_ARM_8) {
+		/* pai_tx_data[3:0] */
+		bit = pin->arm_pin - PC3X3_GPIO_PIN_ARM_4;
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_20 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_24) {
+		/* pai_rx_data[3:0] */
+		bit = 8 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_20);
+	} else if (pin->arm_pin >= PC3X3_GPIO_PIN_ARM_24 &&
+		   pin->arm_pin < PC3X3_GPIO_PIN_ARM_28) {
+		/* pai_tx_data[7:4] */
+		bit = 4 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_24);
+		can_be_sd = 0;
+	} else {
+		/* pai_rx_data[7:4] */
+		bit = 12 + (pin->arm_pin - PC3X3_GPIO_PIN_ARM_28);
+		can_be_sd = 0;
+	}
+
+	if (MUX_SD == setting && !can_be_sd) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Use the pin as pai. */
+	if (MUX_PERIPHERAL == setting)
+		pai_mux &= ~(1 << bit);
+	else
+		pai_mux |= (1 << bit);
+
+	picoxcell_write_register (pai_mux, USE_PAI_GPIO_REG);
+
+	/*
+	 * Make sure that the configuration is valid (the GPIO isn't going to
+	 * the EBI).
+	 */
+	if (picoxcell_read_register (USE_PAI_GPIO_REG) != pai_mux) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * If we can be SD or ARM and we want to be gpio, pick the correct
+	 * one now.
+	 */
+	if (MUX_PERIPHERAL != setting && can_be_sd)
+		pc3xx_shd_gpio_set_mux (pin->arm_pin, setting);
+
+out:
+	return err;
+}
+
+/*
+ * pai_rx_data[3:0] pads - these pads can be either the pai_rx_data or arm
+ * gpio or sdgpio. Note: the gpio pins can also be routed to the
+ * ebi_addr pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the ebi address pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin pai_rx_data_0_3[] = {
+	PIN (pai_rx_data0, PC3X3_GPIO_PIN_SDGPIO_4, PC3X3_GPIO_PIN_ARM_20,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data1, PC3X3_GPIO_PIN_SDGPIO_5, PC3X3_GPIO_PIN_ARM_21,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data2, PC3X3_GPIO_PIN_SDGPIO_6, PC3X3_GPIO_PIN_ARM_22,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data3, PC3X3_GPIO_PIN_SDGPIO_7, PC3X3_GPIO_PIN_ARM_23,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_rx_data_0_3_group = {
+	.nr_pins = ARRAY_SIZE (pai_rx_data_0_3),
+	.name = "pai_rx_data[3:0]",
+	.pins = pai_rx_data_0_3,
+};
+
+/*
+ * pai_tx_data[3:0] pads - these pads can be either the pai_tx_data or arm
+ * gpio or sdgpio. Note: the gpio pins can also be routed to the
+ * ebi_addr pads.
+ *
+ * A pad may only be used for GPIO if the corresponding GPIO pin is not
+ * already routed to the ebi address pad. The same applies in the reverse
+ * direction. Hardware interlocks exist to prevent this from happening.
+ */
+static struct muxed_pin pai_tx_data_0_3[] = {
+	PIN (pai_tx_data0, PC3X3_GPIO_PIN_SDGPIO_20, PC3X3_GPIO_PIN_ARM_4,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data1, PC3X3_GPIO_PIN_SDGPIO_21, PC3X3_GPIO_PIN_ARM_5,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data2, PC3X3_GPIO_PIN_SDGPIO_22, PC3X3_GPIO_PIN_ARM_6,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data3, PC3X3_GPIO_PIN_SDGPIO_23, PC3X3_GPIO_PIN_ARM_7,
+	     pc3x3_shd_pai_set_mux, pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_tx_data_0_3_group = {
+	.nr_pins = ARRAY_SIZE (pai_tx_data_0_3),
+	.name = "pai_tx_data[3:0]",
+	.pins = pai_tx_data_0_3,
+};
+
+/*
+ * pai_tx_data[7:4] pads - these pads can either be pai_tx_data or arm gpio.
+ */
+static struct muxed_pin pai_tx_data_4_7[] = {
+	PIN (pai_tx_data4, -1, PC3X3_GPIO_PIN_ARM_24, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data5, -1, PC3X3_GPIO_PIN_ARM_25, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data6, -1, PC3X3_GPIO_PIN_ARM_26, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_tx_data7, -1, PC3X3_GPIO_PIN_ARM_27, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_tx_data_4_7_group = {
+	.nr_pins = ARRAY_SIZE (pai_tx_data_4_7),
+	.name = "pai_tx_data[7:4]",
+	.pins = pai_tx_data_4_7,
+};
+
+/*
+ * pai_rx_data[7:4] pads - these pads can either be pai_rx_data or arm gpio.
+ */
+static struct muxed_pin pai_rx_data_4_7[] = {
+	PIN (pai_rx_data4, -1, PC3X3_GPIO_PIN_ARM_28, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data5, -1, PC3X3_GPIO_PIN_ARM_29, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data6, -1, PC3X3_GPIO_PIN_ARM_30, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+	PIN (pai_rx_data7, -1, PC3X3_GPIO_PIN_ARM_31, pc3x3_shd_pai_set_mux,
+	     pc3x3_shd_pai_get_mux),
+};
+
+static struct pin_group pai_rx_data_4_7_group = {
+	.nr_pins = ARRAY_SIZE (pai_rx_data_4_7),
+	.name = "pai_rx_data[7:4]",
+	.pins = pai_rx_data_4_7,
+};
+
+/*
+ * ebi_addr[17:14] pads - these pads can either be ebi_addr or arm gpio.
+ */
+static struct muxed_pin ebi_addr_14_17[] = {
+	PIN (ebi_addr14, -1, PC3X3_GPIO_PIN_ARM_32, pc3x3_shd_ebi_set_mux,
+	     pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr15, -1, PC3X3_GPIO_PIN_ARM_33, pc3x3_shd_ebi_set_mux,
+	     pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr16, -1, PC3X3_GPIO_PIN_ARM_34, pc3x3_shd_ebi_set_mux,
+	     pc3x3_shd_ebi_get_mux),
+	PIN (ebi_addr17, -1, PC3X3_GPIO_PIN_ARM_35, pc3x3_shd_ebi_set_mux,
+	     pc3x3_shd_ebi_get_mux),
+};
+
+static struct pin_group ebi_addr_14_17_group = {
+	.nr_pins = ARRAY_SIZE (ebi_addr_14_17),
+	.name = "ebi_addr[17:14]",
+	.pins = ebi_addr_14_17,
+};
+
+static int decode_get_mux (struct muxed_pin *pin)
+{
+	unsigned bit = 1 << (pin->arm_pin - PC3X3_GPIO_PIN_ARM_36);
+	unsigned long use_decode_gpio =
+	    picoxcell_read_register (USE_DECODE_GPIO_REG);
+
+	return use_decode_gpio & (1 << bit) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int decode_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	unsigned long use_decode_gpio;
+	unsigned bit = pin->arm_pin == PC3X3_GPIO_PIN_ARM_36 ? 0 : 1;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_decode_gpio = picoxcell_read_register (USE_DECODE_GPIO_REG);
+	if (MUX_ARM == setting)
+		use_decode_gpio |= (1 << bit);
+	else
+		use_decode_gpio &= ~(1 << bit);
+	picoxcell_write_register (use_decode_gpio, USE_DECODE_GPIO_REG);
+
+	return 0;
+}
+
+/*
+ * decode[3:0] pads - these pads can either be decode pins or arm gpio.
+ */
+static struct muxed_pin decode_0_3[] = {
+	PIN (decode0, -1, PC3X3_GPIO_PIN_ARM_36, decode_set_mux,
+	     decode_get_mux),
+	PIN (decode1, -1, PC3X3_GPIO_PIN_ARM_37, decode_set_mux,
+	     decode_get_mux),
+	PIN (decode2, -1, PC3X3_GPIO_PIN_ARM_38, decode_set_mux,
+	     decode_get_mux),
+	PIN (decode3, -1, PC3X3_GPIO_PIN_ARM_39, decode_set_mux,
+	     decode_get_mux),
+};
+
+static struct pin_group decode_0_3_group = {
+	.nr_pins = ARRAY_SIZE (decode_0_3),
+	.name = "decode[3:0]",
+	.pins = decode_0_3,
+};
+
+static int ssi_set_mux (struct muxed_pin *pin, enum mux_setting setting);
+
+static int ssi_get_mux (struct muxed_pin *pin);
+
+/*
+ * ssi pads - these pads can either be ssi block pins or arm gpio.
+ */
+static struct muxed_pin ssi[] = {
+	PIN (ssi_clk, -1, PC3X3_GPIO_PIN_ARM_40, ssi_set_mux, ssi_get_mux),
+	PIN (ssi_data_in, -1, PC3X3_GPIO_PIN_ARM_41, ssi_set_mux, ssi_get_mux),
+	PIN (ssi_data_out, -1, PC3X3_GPIO_PIN_ARM_42, ssi_set_mux, ssi_get_mux),
+};
+
+static int ssi_get_mux (struct muxed_pin *pin)
+{
+	unsigned long use_misc_int_gpio =
+	    picoxcell_read_register (USE_MISC_INT_GPIO_REG);
+
+	return use_misc_int_gpio & (1 << 0) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int ssi_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	unsigned long use_misc_int_gpio;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_misc_int_gpio = picoxcell_read_register (USE_MISC_INT_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		use_misc_int_gpio &= ~(1 << 0);
+	else
+		use_misc_int_gpio |= (1 << 0);
+	picoxcell_write_register (use_misc_int_gpio, USE_MISC_INT_GPIO_REG);
+
+	return 0;
+}
+
+static struct pin_group ssi_group = {
+	.nr_pins = ARRAY_SIZE (ssi),
+	.name = "ssi",
+	.pins = ssi,
+};
+
+static int mii_get_mux (struct muxed_pin *pin)
+{
+	unsigned long syscfg = syscfg_read ();
+
+	return syscfg & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int mii_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	/*
+	 * These are automatically configured by hardware if we are in
+	 * reduced MII mode.
+	 */
+	return -EOPNOTSUPP;
+}
+
+/*
+ * mii pads - these pads can either be mii pins or arm gpio.
+ */
+static struct muxed_pin mii[] = {
+	PIN (mii_tx_data2, -1, PC3X3_GPIO_PIN_ARM_43, mii_set_mux, mii_get_mux),
+	PIN (mii_tx_data3, -1, PC3X3_GPIO_PIN_ARM_44, mii_set_mux, mii_get_mux),
+	PIN (mii_rx_data2, -1, PC3X3_GPIO_PIN_ARM_45, mii_set_mux, mii_get_mux),
+	PIN (mii_rx_data3, -1, PC3X3_GPIO_PIN_ARM_46, mii_set_mux, mii_get_mux),
+	PIN (mii_col, -1, PC3X3_GPIO_PIN_ARM_47, mii_set_mux, mii_get_mux),
+	PIN (mii_crs, -1, PC3X3_GPIO_PIN_ARM_48, mii_set_mux, mii_get_mux),
+	PIN (mii_tx_clk, -1, PC3X3_GPIO_PIN_ARM_49, mii_set_mux, mii_get_mux),
+};
+
+static struct pin_group mii_group = {
+	.nr_pins = ARRAY_SIZE (mii),
+	.name = "mii",
+	.pins = mii,
+};
+
+static int max_set_mux (struct muxed_pin *pin, enum mux_setting setting);
+
+static int max_get_mux (struct muxed_pin *pin);
+
+/*
+ * maxim pads - these pads can either be maxim pins or arm gpio.
+ */
+static struct muxed_pin max[] = {
+	PIN (max_tx_ctrl, -1, PC3X3_GPIO_PIN_ARM_50, max_set_mux, max_get_mux),
+	PIN (max_ref_clk, -1, PC3X3_GPIO_PIN_ARM_51, max_set_mux, max_get_mux),
+	PIN (max_trig_clk, -1, PC3X3_GPIO_PIN_ARM_52, max_set_mux, max_get_mux),
+};
+
+static int max_get_mux (struct muxed_pin *pin)
+{
+	unsigned long use_misc_int_gpio =
+	    picoxcell_read_register (USE_MISC_INT_GPIO_REG);
+
+	return use_misc_int_gpio & (1 << 1) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int max_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	unsigned long use_misc_int_gpio;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	use_misc_int_gpio = picoxcell_read_register (USE_MISC_INT_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		use_misc_int_gpio &= ~(1 << 1);
+	else
+		use_misc_int_gpio |= (1 << 1);
+	picoxcell_write_register (use_misc_int_gpio, USE_MISC_INT_GPIO_REG);
+
+	return 0;
+}
+
+static struct pin_group max_group = {
+	.nr_pins = ARRAY_SIZE (max),
+	.name = "mii",
+	.pins = max,
+};
+
+static int ebi_clk_get_mux (struct muxed_pin *pin)
+{
+	unsigned long ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
+
+	return ebi_mux & (1 << 13) ? MUX_ARM : MUX_PERIPHERAL;
+}
+
+static int ebi_clk_set_mux (struct muxed_pin *pin, enum mux_setting setting)
+{
+	unsigned long ebi_mux;
+
+	if (MUX_SD == setting)
+		return -EINVAL;
+
+	ebi_mux = picoxcell_read_register (USE_EBI_GPIO_REG);
+	if (MUX_PERIPHERAL == setting)
+		ebi_mux &= ~(1 << 13);
+	else
+		ebi_mux |= (1 << 13);
+	picoxcell_write_register (ebi_mux, USE_EBI_GPIO_REG);
+
+	return 0;
+}
+
+/*
+ * ebi clock pads - this pad can either be the ebi clock or an arm gpio.
+ */
+static struct muxed_pin ebi_clk[] = {
+	PIN (ebi_clk, -1, PC3X3_GPIO_PIN_ARM_53, ebi_clk_set_mux,
+	     ebi_clk_get_mux),
+};
+
+static struct pin_group ebi_clk_group = {
+	.nr_pins = ARRAY_SIZE (ebi_clk),
+	.name = "ebi_clk",
+	.pins = ebi_clk,
+};
+
+static struct muxed_pin pc3x3_fracn_pins[] = {
+	PIN (sdgpio0, PC3X3_GPIO_PIN_SDGPIO_0, -1, pc3xx_shd_mux,
+	     pc3xx_get_shd_mux),
+};
+
+static struct pin_group pc3x3_fracn_group = {
+	.nr_pins = ARRAY_SIZE (pc3x3_fracn_pins),
+	.name = "fracn/sdgpio0",
+	.pins = pc3x3_fracn_pins,
+};
+
+static struct pin_group *pc3x3_groups[] = {
+	&armgpio_0_4_group,
+	&pc3x3_shd_group,
+	&boot_mode_group,
+	&sdram_speed_sel_group,
+	&mii_rev_en_group,
+	&mii_rmii_en_group,
+	&mii_speed_sel_group,
+	&ebi_addr_18_25_group,
+	&pai_tx_data_0_3_group,
+	&pai_rx_data_0_3_group,
+	&pai_tx_data_4_7_group,
+	&pai_rx_data_4_7_group,
+	&ebi_addr_14_17_group,
+	&decode_0_3_group,
+	&ssi_group,
+	&mii_group,
+	&max_group,
+	&ebi_clk_group,
+	&pc3x3_fracn_group,
+};
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+
+/* Public API -------------------------------------------------------------- */
+/*****************************************************************************
+ * Generic level pin multiplexing.
+ ****************************************************************************/
+
+static struct {
+	unsigned num_groups;
+	struct pin_group **groups;
+} all_groups;
+
+int picoxcell_pin_set_mux (int pin_nr, enum mux_setting setting)
+{
+	unsigned i, j;
+	int ret = 0;
+
+	/*
+	 * Don't let users try and trick us - they can't change the hardware
+	 * that much!
+	 */
+	if (MUX_UNMUXED == setting)
+		return -EINVAL;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			/*
+			 * Dedicated GPIO pins aren't shared with a
+			 * peripheral. This is illegal!
+			 */
+			if (pin->is_dedicated_gpio && MUX_PERIPHERAL == setting)
+				return -EINVAL;
+			if (pin_nr == pin->arm_pin || pin_nr == pin->sd_pin) {
+				ret = pin->set_mux (pin, setting);
+				if (!ret)
+					goto out;
+				/*
+				 * If we failed to set the muxing of this pin,
+				 * carry on looping as we have some
+				 * many-to-many pins so we might pick it up
+				 * again on another output.
+				 */
+			}
+		}
+	}
+
+	/*
+	 * If we don't have a multiplexed pin entry for the requested pin then
+	 * we assume that the pin isn't multiplexed so we don't need to do
+	 * anything.
+	 */
+out:
+	return ret;
+}
+
+int picoxcell_group_set_mux (const char *group_name, enum mux_setting setting)
+{
+	unsigned i, j;
+	int err = -ENXIO;
+
+	/*
+	 * Don't let users try and trick us - they can't change the hardware
+	 * that much!
+	 */
+	if (MUX_UNMUXED == setting)
+		return -EINVAL;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		if (strcmp (group->name, group_name))
+			continue;
+
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			/*
+			 * Dedicated GPIO pins aren't shared with a
+			 * peripheral. This is illegal!
+			 */
+			if (pin->is_dedicated_gpio && MUX_PERIPHERAL == setting)
+				return -EINVAL;
+			err = pin->set_mux (pin, setting);
+			if (err)
+				goto out;
+		}
+
+		break;
+	}
+
+out:
+	return err;
+}
+
+int picoxcell_get_pin_mux (int pin_nr)
+{
+	unsigned i, j;
+	int ret = 0;
+
+	for (i = 0; i < all_groups.num_groups; ++i) {
+		struct pin_group *group = all_groups.groups[i];
+		for (j = 0; j < group->nr_pins; ++j) {
+			struct muxed_pin *pin = &group->pins[j];
+			if (pin_nr == pin->arm_pin || pin_nr == pin->sd_pin) {
+				int tmp = pin->get_mux (pin);
+				if (tmp < 0)
+					return tmp;
+				ret |= tmp;
+			}
+		}
+	}
+
+	/*
+	 * If we don't have a multiplexed pin entry for the requested pin then
+	 * we assume that the pin isn't multiplexed.
+	 */
+	return ret ? ret : MUX_UNMUXED;
+}
+
+void picoxcell_muxing_init (void)
+{
+	if (!is_pc3x3 ()) {
+#ifdef CONFIG_PICOCHIP_PC3X2
+		all_groups.num_groups = ARRAY_SIZE (pc3x2_groups);
+		all_groups.groups = pc3x2_groups;
+#endif /* CONFIG_PICOCHIP_PC3X2 */
+	} else {
+#ifdef CONFIG_PICOCHIP_PC3X3
+		all_groups.num_groups = ARRAY_SIZE (pc3x3_groups);
+		all_groups.groups = pc3x3_groups;
+#endif /* CONFIG_PICOCHIP_PC3X3 */
+	}
+}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/reset.S b/arch/arm/cpu/arm926ejs/picoxcell/reset.S
new file mode 100644
index 0000000..a763cc8
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/reset.S
@@ -0,0 +1,58 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file reset.S
+* \brief Function used to reset the picoxcell device.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+/* Includes ---------------------------------------------------------------- */
+#include <config.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/wdog.h>
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Functions --------------------------------------------------------------- */
+
+	.align	5
+
+.globl reset_cpu
+
+reset_cpu:
+
+        /* Use the 'fallback' watchdog method for reseting */
+
+        ldr     r0, =PICOXCELL_WDOG_BASE
+
+        /* Read the control register */
+        ldr     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* Clear the 'Response mode' bit */
+        bic     r1, #WDOGCONTROLREGRMODMASK
+
+        /* Set the 'Watchdog Enable' bit */
+        orr     r1, #WDOGCONTROLREGWDT_ENMASK
+
+        /* Write to the control register */
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+        /* The Watchdog is hardwired for a 1 second timeout */
+
+        /* 'Kick' the Watchdog into life */
+        mov     r1, #WDOG_COUNTER_RESTART_KICK_VALUE
+        str     r1, [r0, #WDOG_CONTROL_REG_OFFSET]
+
+reset_loop_forever:
+
+        /* We will never return from this function */
+        b       reset_loop_forever
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/spi.c b/arch/arm/cpu/arm926ejs/picoxcell/spi.c
new file mode 100644
index 0000000..b3c8ff2
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/spi.c
@@ -0,0 +1,656 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file spi.c
+ * \brief SPI driver.
+ *
+ * Copyright (c) 2006-2011 Picochip Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+#ifdef CONFIG_DW_SPI
+
+/* Define this to use a GPIO as the spi flash chip select.
+   Note: On the PC7302 platform we only have a single spi flash device.
+   Note: If this is not defined then we use the chip select generated by the
+         SPI block.
+   Note: Using this option on a PC7302 platform will require a board
+         modification.
+*/
+#undef USE_GPIO_AS_CHIP_SELECT
+
+#include <spi.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/spi.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/gpio.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * \brief Debug macro
+ */
+#ifdef	SPI_DEBUG
+#define spi_debug(fmt,args...)	printf (fmt ,##args)
+#else
+#define spi_debug(fmt,args...)
+#endif /* SPI_DEBUG */
+
+/* !
+ *  \brief Macros used to read from, and write to, the spi registers.
+ *         Note: These macros provide 16 bit access.
+ */
+#define SPI_READ(__offset) \
+                  *((volatile u16*)(PICOXCELL_SSI_BASE + __offset))
+
+#define SPI_WRITE(__value, __offset) \
+                   *((volatile u16*)(PICOXCELL_SSI_BASE + __offset)) = __value
+
+/* !
+ *  \brief Macros used to read from, and write to, the axi2cfg registers.
+ *         Note: These macros provide 32 bit access.
+ */
+#define AXI2CFG_READ(__offset) \
+                  *((volatile u32*)(PICOXCELL_AXI2CFG_BASE + __offset))
+
+#define AXI2CFG_WRITE(__value, __offset) \
+                   *((volatile u32*)(PICOXCELL_AXI2CFG_BASE + __offset)) = __value
+
+/* Constants --------------------------------------------------------------- */
+/* !
+ *  \brief This structure is used for generic and device specific
+ *         spi driver data.
+ */
+struct picoxcell_spi_slave {
+	/* Generic spi slave description */
+	struct spi_slave slave;
+
+	/* Additional driver data for the picoxcell implementation */
+
+	/* Serial clock polarity */
+	unsigned int scpol;
+
+	/* Serial clock phase */
+	unsigned int scph;
+
+	/* Serial bus speed (Hz) */
+	unsigned int max_hz;
+
+	/* Pointer to hold location of the Tx data 'copy' */
+	u8 *dout_copy;
+
+	/* Keep a count of the data to tx */
+	unsigned int byte_count_tx;
+};
+
+/*!
+ * \brief Function return codes
+ */
+enum return_codes {
+	SUCCESS = 0,		/* Successful outcome */
+	FAILURE = 1		/* Error response */
+};
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+void spi_init ()
+{
+	/* Nothing specific required in here */
+}
+
+struct spi_slave *spi_setup_slave (unsigned int bus,
+				   unsigned int cs,
+				   unsigned int max_hz, unsigned int mode)
+{
+	struct picoxcell_spi_slave *spi_slave;
+
+	unsigned int spi_max_clock = 0;
+	unsigned int spi_min_clock = 0;
+
+	/* Have we been passed a valid combination of bus and cs ?
+	 * Note: Picoxcell devices have a single SPI controller (bus) and
+	 *       up to 4 possible SPI chip selects.
+         */
+	if (bus > (PICOXCELL_MAX_NUMBER_SPI_BUSSES - 1)) {
+		/* Oops, request bus is out of range. */
+		printf ("Oops, SPI 'bus' out of range. "
+			"(We only have %d SPI bus(ses) available).\n",
+			(unsigned int)PICOXCELL_MAX_NUMBER_SPI_BUSSES);
+		return NULL;
+	}
+
+	if (cs > (PICOXCELL_MAX_NUMBER_SPI_CS - 1)) {
+		/* Oops, requested chip select is out of range */
+		printf ("Oops, SPI 'cs' out of range. "
+			"(We only have %d 'cs' available).\n",
+			(unsigned int)PICOXCELL_MAX_NUMBER_SPI_CS);
+		return NULL;
+	}
+
+	/* Have we been passed a valid SPI bus clock rate ? */
+	spi_max_clock =
+	    (PICOXCELL_AHB_CLOCK_FREQ / PICOXCELL_MIN_SPI_CLK_DIVIDER);
+	spi_min_clock =
+	    (PICOXCELL_AHB_CLOCK_FREQ / PICOXCELL_MAX_SPI_CLK_DIVIDER);
+
+	if ((max_hz < spi_min_clock) || (max_hz > spi_max_clock)) {
+		/* Oops, we do not support this requested SPI bus clock rate */
+		printf ("Oops, SPI bus 'hz' out of range. "
+			"(Min = %d Hz, Max = %d Hz).\n", spi_min_clock,
+			spi_max_clock);
+		return NULL;
+	}
+#ifdef USE_GPIO_AS_CHIP_SELECT
+	/* Have we been passed a valid SPI mode ? */
+	if ((mode < SPI_MODE_0) || (mode > SPI_MODE_3)) {
+		/* Oops, we only support spi mode 0 - 3 */
+		printf ("Oops, SPI 'mode' out of range. "
+			"(We only support SPI 'mode' %d to %d).\n",
+			(unsigned int)SPI_MODE_0, (unsigned int)SPI_MODE_3);
+		return NULL;
+	}
+#else
+	/* Have we been passed a valid SPI mode ? */
+	if (mode != SPI_MODE_3) {
+		/* Oops, we only support spi mode 3 */
+		printf ("Oops, SPI 'mode' out of range. "
+			"(We only support SPI 'mode' %d).\n",
+			(unsigned int)SPI_MODE_3);
+		return NULL;
+	}
+#endif
+
+	/* Grab some memory for the SPI data structure */
+	spi_slave = malloc (sizeof (struct picoxcell_spi_slave));
+	if (!spi_slave) {
+		/* Oops, we have a memory management problem */
+		printf ("Oops, memory allocation error, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+		return NULL;
+	}
+
+	/* Populate our structure */
+	spi_slave->slave.bus = bus;
+	spi_slave->slave.cs = cs;
+	spi_slave->max_hz = max_hz;
+
+	switch (mode) {
+	case SPI_MODE_0:
+		spi_slave->scpol = 0;
+		spi_slave->scph = 0;
+		break;
+	case SPI_MODE_1:
+		spi_slave->scpol = 0;
+		spi_slave->scph = 1;
+		break;
+	case SPI_MODE_2:
+		spi_slave->scpol = 1;
+		spi_slave->scph = 0;
+		break;
+	case SPI_MODE_3:
+		spi_slave->scpol = 1;
+		spi_slave->scph = 1;
+		break;
+	default:
+		spi_slave->scpol = 0;
+		spi_slave->scph = 0;
+		break;
+	}
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+	/* Set up ARM gpio #2 for cs driving */
+	/* Negate the 'cs' in the data register */
+	*(unsigned int *)(PICOXCELL_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+	    GPIO_BIT_2;
+
+	/* Set up the gpio as an o/p */
+	*(unsigned int *)(PICOXCELL_GPIO_BASE +
+			  GPIO_SW_PORT_A_DDR_REG_OFFSET) |= GPIO_BIT_2;
+#endif
+
+	return &spi_slave->slave;
+}
+
+void spi_free_slave (struct spi_slave *slave)
+{
+	struct picoxcell_spi_slave *spi_slave =
+	    container_of (slave, struct picoxcell_spi_slave, slave);
+
+	/* Free memory acquired to hold the SPI data structure */
+	free (spi_slave);
+}
+
+int spi_claim_bus (struct spi_slave *slave)
+{
+	struct picoxcell_spi_slave *spi_slave;
+
+	u16 ctrlr0 = 0;
+	u16 sckdv = 0;
+
+	/* Have we been passed a valid data structure handle ? */
+	if (slave == NULL) {
+		/* Oops, bad handle passed in */
+		printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+		return -FAILURE;
+	}
+
+	spi_slave = container_of (slave, struct picoxcell_spi_slave, slave);
+
+	/* Disable SPI operations
+	   Note: We can't program up the block registers unless
+	   the block is disabled  */
+	SPI_WRITE (PICOXCELL_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+	/* Program up some bits Control Register 0.
+	   Note: As TMOD bits set to 00 (Transmit & Receive),
+	   we do not need to worry about the ctrlr1 register */
+	ctrlr0 = PICOXCELL_SPI_DATA_FRM_8_BIT;
+
+	if (spi_slave->scph) {
+		/* Set the clock phase */
+		ctrlr0 |= PICOXCELL_SPI_SCPH;
+	}
+	if (spi_slave->scpol) {
+		/* Set the clock polarity */
+		ctrlr0 |= PICOXCELL_SPI_SCPOL;
+	}
+	SPI_WRITE (ctrlr0, SSI_CTRL_REG_0_REG_OFFSET);
+
+	/* Setup the SPI bus clock rate */
+	sckdv = (PICOXCELL_AHB_CLOCK_FREQ / spi_slave->max_hz);
+	SPI_WRITE (sckdv, SSI_BAUD_RATE_SEL_REG_OFFSET);
+
+	/* Mask all interrupts from the SPI block */
+	SPI_WRITE (PICOXCELL_SPI_MASK_ALL_INTS, SSI_IMR_REG_OFFSET);
+
+	return SUCCESS;
+}
+
+void spi_release_bus (struct spi_slave *slave)
+{
+	/* Have we been passed a valid data structure handle ? */
+	if (slave == NULL) {
+		/* Oops, bad handle passed in */
+		printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+	}
+
+	/* Disable SPI operations */
+	SPI_WRITE (PICOXCELL_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+}
+
+int spi_xfer (struct spi_slave *slave,
+	      unsigned int bitlen,
+	      const void *dout, void *din, unsigned long flags)
+{
+	struct picoxcell_spi_slave *spi_slave;
+
+	unsigned int len_tx = 0;
+	unsigned int len_rx = 0;
+	unsigned int byte_count = 0;
+
+	u16 status;
+
+	const u8 *txp = dout;
+	u8 *rxp = din;
+	u8 value;
+
+	spi_debug ("spi_xfer: bitlen = %d, dout = %p, din = %p, flags = %d\n",
+		   bitlen, dout, din, flags);
+
+	/* Have we been passed a valid data structure handle ? */
+	if (slave == NULL) {
+		/* Oops, bad handle passed in */
+		printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+		return -FAILURE;
+	}
+
+	spi_slave = container_of (slave, struct picoxcell_spi_slave, slave);
+
+	if (bitlen == 0) {
+		/* Finish any previously submitted transfers */
+		goto out;
+	}
+
+	/*
+	 * The SPI controller can do non-multiple-of-8 bit
+	 * transfers, but this driver currently doesn't support it.
+	 */
+	if (bitlen % 8) {
+		/* Errors always terminate an ongoing transfer */
+		flags |= SPI_XFER_END;
+		goto out;
+	}
+
+	/* Number of bytes to transfer */
+	byte_count = bitlen / 8;
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+	/* Ok, we are using a chip select generated by a gpio signal */
+
+	if (flags & SPI_XFER_BEGIN) {
+		/* Assert the required chip SPI slave chip select */
+		spi_cs_activate (slave);
+
+		/* Enable SPI operations */
+		SPI_WRITE (PICOXCELL_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+	}
+
+	/* Start the data transfer */
+	for (len_tx = 0, len_rx = 0; len_rx < byte_count;) {
+		status = SPI_READ (SSI_STATUS_REG_OFFSET);
+
+		if (len_tx < byte_count && (status & PICOXCELL_SPI_STATUS_TFNF)) {
+			/* We have room in the Tx fifo */
+			if (txp)
+				value = *txp++;
+			else
+				value = 0;
+
+			SPI_WRITE (value, SSI_DATA_REG_OFFSET);
+			len_tx++;
+		}
+
+		if (status & PICOXCELL_SPI_STATUS_RFNE) {
+			/* We have some data in the receive fifo */
+			value = (u8) SPI_READ (SSI_DATA_REG_OFFSET);
+			if (rxp)
+				*rxp++ = value;
+			len_rx++;
+		}
+	}
+
+out:
+	if (flags & SPI_XFER_END) {
+		/*
+		 * Wait until the transfer is completely done before
+		 * we deactivate CS.
+		 */
+		do {
+			status = SPI_READ (SSI_STATUS_REG_OFFSET);
+			status &= PICOXCELL_SPI_STATUS_BUSY;
+
+		} while (status);
+
+		spi_cs_deactivate (slave);
+	}
+
+	return SUCCESS;
+}
+#else /* USE_GPIO_AS_CHIP_SELECT */
+
+	/* Using the SPI block to control the chip selects,
+	   therefore we need all transactions before we start anything.
+
+	   Note: It is imperative that the Tx fifo never empties during operation,
+	   if this happens the cs will be negated by the SPI block,
+	   the spi flash will 'forget' what it is doing and it will
+	   all end in tears ! */
+
+	u8 *dout_copy = NULL;
+	unsigned int byte_count_tx = 0;
+	unsigned int byte_count_rx = 0;
+	unsigned int byte_count_tx_more = 0;
+	unsigned int total_loop_count = 0;
+	unsigned int total_tx_count = 0;
+
+	if (flags & SPI_XFER_BEGIN) {
+		/* If necessary take a copy of the data to transmit */
+		if (txp) {
+			/* Ok, we have some data to Tx */
+
+			/* Grab some memory */
+			dout_copy = malloc (byte_count);
+			if (!dout_copy) {
+				/* Oops, we have a memory management problem */
+				printf
+				    ("Oops, memory allocation error, File: %s,"
+				     " Function: %s, Line: %d\n", __FILE__,
+				     __FUNCTION__, __LINE__);
+				return -FAILURE;
+			}
+
+			/* Lets take a copy of the data */
+			memcpy (dout_copy, dout, byte_count);
+
+			/* Save some useful info for later use */
+			spi_slave->dout_copy = dout_copy;
+			spi_slave->byte_count_tx = byte_count;
+
+			/* We have a copy of the data so can null the
+			   tx data pointer */
+			txp = NULL;
+		}
+	}
+
+	if (flags & SPI_XFER_END) {
+		/* Go retrieve the saved data */
+		dout_copy = spi_slave->dout_copy;
+		byte_count_tx = spi_slave->byte_count_tx;
+
+		if (!dout_copy) {
+			/* Oops, we have a memory management problem */
+			printf ("Oops, memory allocation error, File: %s,"
+				" Function: %s, Line: %d\n",
+				__FILE__, __FUNCTION__, __LINE__);
+			return -FAILURE;
+		}
+
+		/* Have we any more Tx data (spi flash writing) ? */
+		if (txp) {
+			byte_count_tx_more = byte_count;
+		} else {
+			byte_count_tx_more = 0;
+		}
+
+		/* Have we any data to Rx ? */
+		if (rxp) {
+			byte_count_rx = byte_count;
+		} else {
+			byte_count_rx = 0;
+		}
+
+		/* Assert the required chip SPI slave chip select */
+		spi_cs_activate (slave);
+
+		/* Enable SPI block operations */
+		SPI_WRITE (PICOXCELL_SPI_ENABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+		/* Set up some variables to avoid calculating them during the loop */
+		total_loop_count =
+		    byte_count_rx + byte_count_tx + byte_count_tx_more;
+		total_tx_count = byte_count_tx + byte_count_tx_more;
+
+		spi_debug ("spi_xfer: byte_count_rx = %d\n", byte_count_rx);
+		spi_debug ("spi_xfer: byte_count_tx = %d\n", byte_count_tx);
+		spi_debug ("spi_xfer: byte_count_tx_more = %d\n",
+			   byte_count_tx_more);
+		spi_debug ("spi_xfer: total_tx_count = %d\n", total_tx_count);
+		spi_debug ("spi_xfer: total_loop_count = %d\n",
+			   total_loop_count);
+
+		for (len_tx = 0, len_rx = 0; len_rx < total_loop_count;) {
+			status = SPI_READ (SSI_STATUS_REG_OFFSET);
+
+			while (len_tx < byte_count_tx) {
+				/* The Tx fifo is 16 entries deep, we should never fill
+				   this up sending a 'command' to the flash.  Therefore
+				   we do not check the tx fifo status */
+				SPI_WRITE (*dout_copy++, SSI_DATA_REG_OFFSET);
+				len_tx++;
+			}
+
+			while ((len_tx < total_tx_count) &&
+			       (status & PICOXCELL_SPI_STATUS_TFNF)) {
+				/* We have more data to Tx, so just keep going */
+				SPI_WRITE (*txp++, SSI_DATA_REG_OFFSET);
+				len_tx++;
+
+				/* We may fill the tx fifo now, so a re-read of
+				   the status register is a good idea */
+				status = SPI_READ (SSI_STATUS_REG_OFFSET);
+			}
+
+			if ((len_tx >= total_tx_count) && (byte_count_rx == 0)) {
+				/* We have finished Tx and we are not interested in Rx,
+				   lets get out of here */
+				break;
+			}
+
+			if ((len_tx >= total_tx_count) && (byte_count_rx != 0)) {
+				/* Still trying to read some data, so keep the Tx fifo
+				   tickling along, we don't care if the Tx fifo is
+				   full or overflows */
+				SPI_WRITE (0, SSI_DATA_REG_OFFSET);
+			}
+
+			if (status & PICOXCELL_SPI_STATUS_RFNE) {
+				/* We have some data available in the receive fifo */
+				value = (u8) SPI_READ (SSI_DATA_REG_OFFSET);
+
+				/* We do not want this data until it is 'valid',
+				   i.e. we have finished transmitting all the Tx data */
+				if (len_rx < total_tx_count) {
+					/* Just chuck the read data away */
+				} else {
+					*rxp++ = value;
+				}
+
+				len_rx++;
+			}
+		}
+	}
+out:
+	if (flags & SPI_XFER_END) {
+		/*
+		 * If we have finished transmitting and we have no data to receive
+		 * wait until the transfer is completely done before we deactivate CS.
+		 */
+		if ((len_tx >= total_tx_count) && (byte_count_rx == 0)) {
+			/* Make sure the SPI block has actually started
+			   doing something... */
+			udelay (500);
+
+			do {
+				status = SPI_READ (SSI_STATUS_REG_OFFSET);
+				status &= PICOXCELL_SPI_STATUS_BUSY;
+
+			} while (status);
+		}
+
+		spi_cs_deactivate (slave);
+
+		if (spi_slave->dout_copy) {
+			free (spi_slave->dout_copy);
+			spi_slave->dout_copy = NULL;
+		}
+
+		spi_slave->byte_count_tx = 0;
+	}
+
+	return SUCCESS;
+
+}
+#endif /* USE_GPIO_AS_CHIP_SELECT */
+
+void spi_cs_activate (struct spi_slave *slave)
+{
+	struct picoxcell_spi_slave *spi_slave;
+	u16 chip_select = 0;
+	u32 system_config = 0;
+
+	/* Have we been passed a valid data structure handle ? */
+	if (slave == NULL) {
+		/* Oops, bad handle passed in */
+		printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+		return;
+	}
+
+	spi_slave = container_of (slave, struct picoxcell_spi_slave, slave);
+
+	/* Make sure the SPI is disabled */
+	SPI_WRITE (PICOXCELL_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+	/* Obtain the chip select are we using */
+	chip_select = (u16) spi_slave->slave.cs;
+
+	/* Write to the Slave Enable Register */
+	SPI_WRITE ((1 << chip_select), SSI_SLAVE_ENABLE_REG_OFFSET);
+
+	/* Sort out the SPI/EBI chip select muxing.
+	   Note: Set all chip select muxing to be SPI */
+	system_config = AXI2CFG_READ (AXI2CFG_SYS_CONFIG_REG_OFFSET);
+	system_config &= ~(AXI2CFG_DECODE_MUX_0 |
+			   AXI2CFG_DECODE_MUX_1 |
+			   AXI2CFG_DECODE_MUX_2 | AXI2CFG_DECODE_MUX_3);
+
+	AXI2CFG_WRITE (system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+	/* Assert the 'cs' */
+	*(unsigned int *)(PICOXCELL_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) &=
+	    ~(GPIO_BIT_2);
+#endif
+
+}
+
+void spi_cs_deactivate (struct spi_slave *slave)
+{
+	struct picoxcell_spi_slave *spi_slave;
+	u16 chip_select = 0;
+	u32 system_config = 0;
+
+	/* Have we been passed a valid data structure handle ? */
+	if (slave == NULL) {
+		/* Oops, bad handle passed in */
+		printf ("Oops, bad handle passed in, File: %s, Function: %s,"
+			" Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+		return;
+	}
+
+	spi_slave = container_of (slave, struct picoxcell_spi_slave, slave);
+
+	/* Make sure the SPI is disabled */
+	SPI_WRITE (PICOXCELL_SPI_DISABLE, SSI_ENABLE_REG_REG_OFFSET);
+
+	/* Obtain the chip select are we using */
+	chip_select = (u16) spi_slave->slave.cs;
+
+	/* Write to the Slave Enable Register,
+	   Note: Just disable all chip selects for now */
+	SPI_WRITE (PICOXCELL_SPI_SLAVES_DISABLE, SSI_SLAVE_ENABLE_REG_OFFSET);
+
+	/* Sort out the SPI/EBI chip select muxing.
+	   Note: Set all chip select muxing to be EBI */
+	system_config = AXI2CFG_READ (AXI2CFG_SYS_CONFIG_REG_OFFSET);
+	system_config |= (AXI2CFG_DECODE_MUX_0 |
+			  AXI2CFG_DECODE_MUX_1 |
+			  AXI2CFG_DECODE_MUX_2 | AXI2CFG_DECODE_MUX_3);
+
+	AXI2CFG_WRITE (system_config, AXI2CFG_SYS_CONFIG_REG_OFFSET);
+
+#ifdef USE_GPIO_AS_CHIP_SELECT
+	/* Negate the 'cs' */
+	*(unsigned int *)(PICOXCELL_GPIO_BASE + GPIO_SW_PORT_A_DR_REG_OFFSET) |=
+	    GPIO_BIT_2;
+#endif
+
+}
+
+#endif /* CONFIG_DW_SPI */
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/timer.c b/arch/arm/cpu/arm926ejs/picoxcell/timer.c
new file mode 100644
index 0000000..850d429
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/timer.c
@@ -0,0 +1,146 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file timer.c
+ * \brief Useful functions for timer implementation.
+ *
+ * Copyright (c) 2006-2011 Picochip Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*
+ * (C) Copyright 2003
+ * Texas Instruments <www.ti.com>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * (C) Copyright 2002-2004
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2004
+ * Philippe Robin, ARM Ltd. <philippe.robin@arm.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/utilities.h>
+#include <asm/arch/timer.h>
+#include <div64.h>
+
+/*
+ * The timer is a decrementer, it runs at a frequency of PICOXCELL_AHB_CLOCK_FREQ
+ */
+#define READ_TIMER() (picoxcell_read_register (CONFIG_SYS_TIMERBASE +\
+                                               TIMERNCURRENTVALUEREGOFFSET(0)))
+
+#define TIMER_LOAD_VAL 0xFFFFFFFF
+
+static unsigned long long timestamp;
+static unsigned long lastdec;
+
+void reset_timer_masked (void)
+{
+	lastdec = READ_TIMER ();
+	timestamp = 0;
+}
+
+/* Timer init function */
+int timer_init (void)
+{
+	reset_timer_masked ();
+	return 0;
+}
+
+/* Restart counting from 0 */
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+static inline unsigned long long tick_to_time (unsigned long long tick)
+{
+	tick *= CONFIG_SYS_HZ;
+	do_div (tick, PICOXCELL_AHB_CLOCK_FREQ);
+	return tick;
+}
+
+static inline unsigned long long time_to_tick (unsigned long long time)
+{
+	time *= PICOXCELL_AHB_CLOCK_FREQ;
+	do_div (time, CONFIG_SYS_HZ);
+	return time;
+}
+
+static inline unsigned long long us_to_tick (unsigned long long us)
+{
+	us = us * PICOXCELL_AHB_CLOCK_FREQ + 999999;
+	do_div (us, 1000000);
+	return us;
+}
+
+unsigned long long get_ticks (void)
+{
+	ulong now = READ_TIMER ();
+
+	if (lastdec >= now)
+		timestamp += (lastdec - now);
+	else
+		timestamp += (lastdec + TIMER_LOAD_VAL - now);
+
+	lastdec = now;
+
+	return timestamp;
+}
+
+ulong get_timer_masked (void)
+{
+	return tick_to_time (get_ticks ());
+}
+
+/* Return how many HZ passed since "base" */
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+/* Delay 'usec' micro seconds */
+void __udelay (unsigned long usec)
+{
+	unsigned long long tmp;
+	unsigned long long tmo;
+
+	tmo = us_to_tick (usec);
+	tmp = get_ticks () + tmo;
+
+	while (get_ticks () < tmp) ;
+}
diff --git a/arch/arm/cpu/arm926ejs/picoxcell/utilities.c b/arch/arm/cpu/arm926ejs/picoxcell/utilities.c
new file mode 100644
index 0000000..6c8dfb7
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/picoxcell/utilities.c
@@ -0,0 +1,202 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+ * \file utilities.c
+ * \brief Various useful functions.
+ *
+ * Copyright (c) 2006-2011 Picochip Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/arch/picoxcell.h>
+#include <asm/arch/axi2cfg.h>
+#include <asm/arch/fuse.h>
+#include <asm/arch/utilities.h>
+
+/* Macros ------------------------------------------------------------------ */
+/*!
+ * Bit mask used to obtain the least significant 16 bits
+ */
+#define SIXTEEN_BIT_MASK        ( 0xFFFF )
+
+/*!
+ * Bit mask used to obtain the device ID
+ */
+#define DEVICE_ID_MASK          ( 0xFF )
+
+/* Configuration port write bit positions. */
+#define CAEID_BIT_MASK     ( 1 << 19 )	/*!< Bit 19 - AE ID signal. */
+#define CADDR_BIT_MASK     ( 1 << 18 )	/*!< Bit 18 - AE ADDR signal. */
+#define CREAD_BIT_MASK     ( 1 << 17 )	/*!< Bit 17 - READ data signal. */
+#define CWRITE_BIT_MASK    ( 1 << 16 )	/*!< Bit 16 - WRITE data signal. */
+
+#define RB_FAIL_MASK       ( 1 << 17 )	/*!< Bit 17 - readback failed. */
+#define RB_VALID_MASK      ( 1 << 16 )	/*!< Bit 16 - readback valid. */
+
+#define RETRIES ( 10 )		/*!< The number of retries for an \
+				 *   AXI2Cfg config read. */
+
+/*! Register offset for the config bus write port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_WR ( 0x0100 )
+
+/*! Register offset for the config bus read port (from the axi2cfg2 base
+ *  address). */
+#define AXI2CFG_REG_CFG_RD ( 0x0200 )
+
+/* Constants --------------------------------------------------------------- */
+
+/* Types ------------------------------------------------------------------- */
+
+/* Prototypes--------------------------------------------------------------- */
+
+/* Functions --------------------------------------------------------------- */
+__inline unsigned int picoxcell_read_register (const unsigned int address)
+{
+	/* Read an integer (32 bit) value from a register */
+	return (*(volatile unsigned int *)address);
+}
+
+__inline void
+picoxcell_write_register (const unsigned int value, const unsigned int address)
+{
+	/* Write an integer (32 bit) value to a register */
+	*(volatile unsigned int *)address = value;
+}
+
+unsigned int picoxcell_get_device_id (void)
+{
+	unsigned int device_id;
+
+	device_id = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
+					     AXI2CFG_DEVICE_ID_REG_OFFSET);
+	device_id &= DEVICE_ID_MASK;
+
+	return device_id;
+}
+
+unsigned int picoxcell_get_revision (void)
+{
+	unsigned int revision_code;
+
+	revision_code = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
+						 AXI2CFG_REVISION_ID_REG_OFFSET);
+	revision_code &= SIXTEEN_BIT_MASK;
+
+	return revision_code;
+}
+
+unsigned int picoxcell_get_rmii_enabled (void)
+{
+	unsigned int rmii_enabled;
+
+	rmii_enabled = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
+						AXI2CFG_SYS_CONFIG_REG_OFFSET);
+	rmii_enabled &= AXI2CFG_RMII_EN;
+
+	return ! !rmii_enabled;
+}
+
+int axi2cfg_config_read (u16 caeid, u16 address, u16 * data, u16 count)
+{
+	u32 val;
+	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+	unsigned int read_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_RD;
+	u16 to_read = count;
+	u16 rc;
+	unsigned i;
+	unsigned retries;
+
+	val = caeid | CAEID_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	while (to_read) {
+		/* Output the address to read from. */
+		val = (address + (count - to_read)) | CADDR_BIT_MASK;
+		picoxcell_write_register (val, write_p);
+
+		/* Dispatch the read requests. */
+		rc = (to_read > 64) ? 64 : to_read;
+		val = CREAD_BIT_MASK | rc;
+		picoxcell_write_register (val, write_p);
+
+		/* Now read the values. */
+		for (i = 0; i < rc; ++i) {
+			retries = RETRIES;
+			while (retries) {
+				val = picoxcell_read_register (read_p);
+				if (val & (RB_VALID_MASK | RB_FAIL_MASK))
+					break;
+				--retries;
+			}
+
+			if (!retries || (val & RB_FAIL_MASK)) {
+				break;
+			} else
+				data[(count - to_read) + i] = val & 0xFFFF;
+		}
+
+		if (val & RB_FAIL_MASK)
+			break;
+
+		to_read -= rc;
+	}
+
+	return !(val & RB_FAIL_MASK) ? count : -EIO;
+}
+
+int axi2cfg_config_write (u16 caeid, u16 address, u16 * data, u16 count)
+{
+	u32 val;
+	unsigned int write_p = PICOXCELL_AXI2CFG_BASE + AXI2CFG_REG_CFG_WR;
+	unsigned i;
+
+	val = caeid | CAEID_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	/* Output the address to write to */
+	val = address | CADDR_BIT_MASK;
+	picoxcell_write_register (val, write_p);
+
+	/* Now write the values. */
+	for (i = 0; i < count; ++i) {
+		val = data[i] | CWRITE_BIT_MASK;
+		picoxcell_write_register (val, write_p);
+	}
+
+	return i;
+}
+
+u32 syscfg_read (void)
+{
+	return picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
+					AXI2CFG_SYS_CONFIG_REG_OFFSET);
+}
+
+void syscfg_update (u32 mask, u32 val)
+{
+	u32 tmp = syscfg_read ();
+	tmp &= ~mask;
+	tmp |= (val & mask);
+	picoxcell_write_register (tmp, (PICOXCELL_AXI2CFG_BASE +
+					AXI2CFG_SYS_CONFIG_REG_OFFSET));
+}
+
+__inline int is_pc3x3 (void)
+{
+	u32 dev_id = picoxcell_read_register (PICOXCELL_AXI2CFG_BASE +
+					      AXI2CFG_DEVICE_ID_REG_OFFSET);
+
+	return (dev_id == PC313_DEVICE_ID ||
+		dev_id == PC323_DEVICE_ID || dev_id == PC333_DEVICE_ID);
+}
diff --git a/arch/arm/include/asm/arch-pc3xx/axi2cfg.h b/arch/arm/include/asm/arch-pc3xx/axi2cfg.h
deleted file mode 100644
index 95d7898..0000000
--- a/arch/arm/include/asm/arch-pc3xx/axi2cfg.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file axi2cfg.h
-* \brief Definitions for the PC3xx AXI2CFG Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_AXI2CFG_H__
-#define __PC3XX_AXI2CFG_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-/* Functional Registers */
-
-#define AXI2CFG_SYS_CONFIG_REG_OFFSET               (0x0000)
-#define AXI2CFG_JTAG_ISC_REG_OFFSET                 (0x0004)
-#define AXI2CFG_IRQ_REG_OFFSET                      (0x0008)
-#define AXI2CFG_PURGE_CFG_PORT_REG_OFFSET           (0x000C)
-#define AXI2CFG_DMA_CFG_REG_OFFSET                  (0x0010)
-#define AXI2CFG_DEVICE_ID_REG_OFFSET                (0x0014)
-#define AXI2CFG_REVISION_ID_REG_OFFSET              (0x0018)
-#define AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET          (0x0034)
-#define AXI2CFG_USE_PAI_GPIO_REG_OFFSET             (0x0038)
-#define AXI2CFG_USE_EBI_GPIO_REG_OFFSET             (0x003C)
-#define AXI2CFG_USE_DECODE_GPIO_REG_OFFSET          (0x0040)
-#define AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET        (0x0044)
-#define AXI2CFG_CLK_GATING_REG_OFFSET               (0x0048)
-#define AXI2CFG_ARM_PLL_CLK_REG_OFFSET              (0x0050)
-#define AXI2CFG_FREQ_SENSE_REG_OFFSET               (0x0054)
-#define AXI2CFG_CONFIG_WRITE_REG_OFFSET             (0x0100)
-#define AXI2CFG_CONFIG_READ_REG_OFFSET              (0x0200)
-#define AXI2CFG_DMAC1_CONFIG_REG_OFFSET             (0x0300)
-
-
-/*****************************************************************************/
-/* Register Bit Fields		                                             */
-/*****************************************************************************/
-
-#define AXI2CFG_SYS_CONFIG_PA_RST_IDX               (30)
-#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ       (8)
-#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_HI       (23)
-#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO       (16)
-#define AXI2CFG_SYS_CONFIG_RW_EBI_CLK_DISABLE_IDX   (15)
-#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX         (14)
-#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX           (13)
-#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX         (12)
-#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ           (4)
-#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_HI           (11)
-#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO           (8)
-#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX       (7)
-#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX         (6)
-#define AXI2CFG_SYS_CONFIG_RW_REMAP_IDX             (5)
-#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX            (4)
-#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX            (3)
-#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX            (2)
-#define AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ             (2)
-#define AXI2CFG_SYS_CONFIG_BOOT_MODE_HI             (1)
-#define AXI2CFG_SYS_CONFIG_BOOT_MODE_LO             (0)
-
-#define AXI2CFG_SYS_CONFIG_PA_RST_MASK              (1 << AXI2CFG_SYS_CONFIG_PA_RST_IDX)
-#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK         (((1 << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO)
-#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX)
-#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_MASK          (1 << AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX)
-#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX)
-#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK         (((1 << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO)
-#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK      (1<<AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX)
-#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_MASK        (1 << AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX)
-#define AXI2CFG_SYS_CONFIG_RW_REMAP_MASK            (1 << AXI2CFG_SYS_CONFIG_RW_REMAP_IDX)
-#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_MASK           (1 << AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX)
-#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX)
-#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX)
-#define AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK           (((1 << AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ)-1) << AXI2CFG_SYS_CONFIG_BOOT_MODE_LO)
-
-#define AXI2CFG_DMAC1_CONFIG_WR_SZ                  (7)
-#define AXI2CFG_DMAC1_CONFIG_WR_HI                  (16)
-#define AXI2CFG_DMAC1_CONFIG_WR_LO                  (10)
-#define AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ           (7)
-#define AXI2CFG_DMAC1_CONFIG_WATERMARK_HI           (9)
-#define AXI2CFG_DMAC1_CONFIG_WATERMARK_LO           (3)
-#define AXI2CFG_DMAC1_CONFIG_SNGL_IDX               (2)
-#define AXI2CFG_DMAC1_CONFIG_STATE_IDX              (1)
-#define AXI2CFG_DMAC1_CONFIG_ENABLE_IDX             (0)
-
-#define AXI2CFG_JTAG_ISC_REGISTER_IDX               (0)
-#define AXI2CFG_JTAG_ISC_IN_CTRL_IDX                (1)
-#define AXI2CFG_JTAG_ISC_DISABLED_IDX               (2)
-/* [31:2] - Reserved */
-
-#define AXI2CFG_PURGE_CFG_RD_PORT_IDX               (0)
-#define AXI2CFG_PURGE_CFG_WR_PORT_IDX               (1)
-#define AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX         (2)
-/* [31:3]   Reserved */
-
-#define AXI2CFG_DEVICE_ID_NML_302_REG_VALUE         (0x03020004)
-
-/*****************************************************************************/
-/* Register Bit Field Manipulation                                           */
-/*****************************************************************************/
-
-#define AXI2CFG_PA_SOFT_RESET_IDX                   (30)
-#define AXI2CFG_SHD_GPIO_7_IDX                      (23)
-#define AXI2CFG_SHD_GPIO_6_IDX                      (22)
-#define AXI2CFG_SHD_GPIO_5_IDX                      (21)
-#define AXI2CFG_SHD_GPIO_4_IDX                      (20)
-#define AXI2CFG_SHD_GPIO_3_IDX                      (19)
-#define AXI2CFG_SHD_GPIO_2_IDX                      (18)
-#define AXI2CFG_SHD_GPIO_1_IDX                      (17)
-#define AXI2CFG_SHD_GPIO_0_IDX                      (16)
-#define AXI2CFG_EBI_CLK_DISABLE_IDX                 (15)
-#define AXI2CFG_EXCEPTION_VECT_EN_IDX               (14)
-#define AXI2CFG_RMII_EN_IDX                         (13)
-#define AXI2CFG_REV_MII_EN_IDX                      (12)
-#define AXI2CFG_DECODE_MUX_3_IDX                    (11)
-#define AXI2CFG_DECODE_MUX_2_IDX                    (10)
-#define AXI2CFG_DECODE_MUX_1_IDX                    (9)
-#define AXI2CFG_DECODE_MUX_0_IDX                    (8)
-#define AXI2CFG_MASK_AXI_ERROR_IDX                  (6)
-#define AXI2CFG_REMAP_IDX                           (5)
-#define AXI2CFG_WDG_PAUSE_IDX                       (4)
-#define AXI2CFG_DMA_CHAN_6_MUX_IDX                  (3)
-#define AXI2CFG_DMA_CHAN_7_MUX_IDX                  (2)
-#define AXI2CFG_BOOT_MODE_IDX                       (0)
-
-#define AXI2CFG_PA_SOFT_RESET               (1 << AXI2CFG_PA_SOFT_RESET_IDX)
-#define AXI2CFG_SHD_GPIO_7                  (1 << AXI2CFG_SHD_GPIO_7_IDX)
-#define AXI2CFG_SHD_GPIO_6                  (1 << AXI2CFG_SHD_GPIO_6_IDX)
-#define AXI2CFG_SHD_GPIO_5                  (1 << AXI2CFG_SHD_GPIO_5_IDX)
-#define AXI2CFG_SHD_GPIO_4                  (1 << AXI2CFG_SHD_GPIO_4_IDX)
-#define AXI2CFG_SHD_GPIO_3                  (1 << AXI2CFG_SHD_GPIO_3_IDX)
-#define AXI2CFG_SHD_GPIO_2                  (1 << AXI2CFG_SHD_GPIO_2_IDX)
-#define AXI2CFG_SHD_GPIO_1                  (1 << AXI2CFG_SHD_GPIO_1_IDX)
-#define AXI2CFG_SHD_GPIO_0                  (1 << AXI2CFG_SHD_GPIO_0_IDX)
-#define AXI2CFG_EBI_CLK_DISABLE             (1 << AXI2CFG_EBI_CLK_DISABLE_IDX)
-#define AXI2CFG_EXCEPTION_VECT_EN           (1 << AXI2CFG_EXCEPTION_VECT_EN_IDX)
-#define AXI2CFG_RMII_EN                     (1 << AXI2CFG_RMII_EN_IDX)
-#define AXI2CFG_REV_MII_EN                  (1 << AXI2CFG_REV_MII_EN_IDX)
-#define AXI2CFG_DECODE_MUX_3                (1 << AXI2CFG_DECODE_MUX_3_IDX)
-#define AXI2CFG_DECODE_MUX_2                (1 << AXI2CFG_DECODE_MUX_2_IDX)
-#define AXI2CFG_DECODE_MUX_1                (1 << AXI2CFG_DECODE_MUX_1_IDX)
-#define AXI2CFG_DECODE_MUX_0                (1 << AXI2CFG_DECODE_MUX_0_IDX)
-#define AXI2CFG_MASK_AXI_ERROR              (1 << AXI2CFG_MASK_AXI_ERROR_IDX)
-#define AXI2CFG_REMAP                       (1 << AXI2CFG_REMAP_IDX)
-#define AXI2CFG_WDG_PAUSE                   (1 << AXI2CFG_WDG_PAUSE_IDX)
-#define AXI2CFG_DMA_CHAN_6_MUX              (1 << AXI2CFG_DMA_CHAN_6_MUX_IDX)
-#define AXI2CFG_DMA_CHAN_7_MUX              (1 << AXI2CFG_DMA_CHAN_7_MUX_IDX)
-#define AXI2CFG_BOOT_MODE                   (1 << AXI2CFG_BOOT_MODE_IDX)
-
-#endif /* __PC3XX_AXI2CFG_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/ebi.h b/arch/arm/include/asm/arch-pc3xx/ebi.h
deleted file mode 100644
index 44ff838..0000000
--- a/arch/arm/include/asm/arch-pc3xx/ebi.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file ebi.h
-* \brief Definitions for the PC3xx EBI Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_EBI_H__
-#define __PC3XX_EBI_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define SDRAM_CON_REG_OFFSET                    (0x00)
-#define SDRAM_TIM0_REG_OFFSET                   (0x04)
-#define SDRAM_TIM1_REG_OFFSET                   (0x08)
-#define SDRAM_CTL_REG_OFFSET                    (0x0C)
-#define SDRAM_REFRESH_REG_OFFSET                (0x10)
-#define SCHIP_SEL_REGION0_LOW_REG_OFFSET        (0x14)
-#define SCHIP_SEL_REGION1_LOW_REG_OFFSET        (0x18)
-#define SCHIP_SEL_REGION2_LOW_REG_OFFSET        (0x1C)
-#define SCHIP_SEL_REGION3_LOW_REG_OFFSET        (0x20)
-#define SCHIP_SEL_REGION4_LOW_REG_OFFSET        (0x24)
-#define SCHIP_SEL_REGION5_LOW_REG_OFFSET        (0x28)
-#define SCHIP_SEL_REGION6_LOW_REG_OFFSET        (0x2C)
-#define SCHIP_SEL_REGION7_LOW_REG_OFFSET        (0x30)
-#define SCHIP_SEL_REGION0_HGH_REG_OFFSET        (0x34)
-#define SCHIP_SEL_REGION1_HGH_REG_OFFSET        (0x38)
-#define SCHIP_SEL_REGION2_HGH_REG_OFFSET        (0x3C)
-#define SCHIP_SEL_REGION3_HGH_REG_OFFSET        (0x40)
-#define SCHIP_SEL_REGION4_HGH_REG_OFFSET        (0x44)
-#define SCHIP_SEL_REGION5_HGH_REG_OFFSET        (0x48)
-#define SCHIP_SEL_REGION6_HGH_REG_OFFSET        (0x4C)
-#define SCHIP_SEL_REGION7_HGH_REG_OFFSET        (0x50)
-#define SMASK0_REG_OFFSET                       (0x54)
-#define SMASK1_REG_OFFSET                       (0x58)
-#define SMASK2_REG_OFFSET                       (0x5C)
-#define SMASK3_REG_OFFSET                       (0x60)
-#define SMASK4_REG_OFFSET                       (0x64)
-#define SMASK5_REG_OFFSET                       (0x68)
-#define SMASK6_REG_OFFSET                       (0x6C)
-#define SMASK7_REG_OFFSET                       (0x70)
-#define CHIP_SEL_ALIAS0_LOW_REG_OFFSET          (0x74)
-#define CHIP_SEL_ALIAS1_LOW_REG_OFFSET          (0x78)
-#define CHIP_SEL_ALIAS0_HGH_REG_OFFSET          (0x7C)
-#define CHIP_SEL_ALIAS1_HGH_REG_OFFSET          (0x80)
-#define CHIP_SEL_REMAP0_LOW_REG_OFFSET          (0x84)
-#define CHIP_SEL_REMAP1_LOW_REG_OFFSET          (0x88)
-#define CHIP_SEL_REMAP0_HGH_REG_OFFSET          (0x8C)
-#define CHIP_SEL_REMAP1_HGH_REG_OFFSET          (0x90)
-#define STATIC_MEM_TIMSET0_REG_OFFSET           (0x94)
-#define STATIC_MEM_TIMSET1_REG_OFFSET           (0x98)
-#define STATIC_MEM_TIMSET2_REG_OFFSET           (0x9C)
-#define FLASH_TRPDR_REG_OFFSET                  (0xA0)
-#define STATICM_EMCONTROL_REG_OFFSET            (0xA4)
-#define SYNC_FLASH_OPCODE_REG_OFFSET            (0xA8)
-#define EXTEND_MODE_REG_OFFSET                  (0xAC)
-#define SYNC_FLASH_CONFIG_REG_OFFSET            (0xB0)
-#define SYNC_FLASH_CONTROL_REG_OFFSET           (0xB4)
-#define SYNC_FLASH_TIM_REG_OFFSET               (0xB8)
-
-/* Macros ------------------------------------------------------------------ */
-
-#define SETLOWFREQDEV                           (1<<27)
-#define RESETLOWFREQDEV                         (0<<27)
-#define SETREADYMODE                            (1<<26)
-#define RESETREADYMODE                          (0<<26)
-#define SETPAGEMODE                             (1<<26)
-#define RESETPAGEMODE                           (0<<26)
-#define PAGESIZE4                               (0<<24)
-#define PAGESIZE8                               (1<<24)
-#define PAGESIZE16                              (2<<24)
-#define PAGESIZE32                              (3<<24)
-#define T_PRC_0                                 (4)
-#define T_BTA_0                                 (7)
-#define T_WP_0                                  (20<<10)
-#define T_WR_0                                  (3)
-#define T_AS_0                                  (1)
-#define T_RC_0                                  (32)
-#define T_PRC_1                                 (1)
-#define T_BTA_1                                 (1)
-#define T_WP_1                                  (2)
-#define T_WR_1                                  (1)
-#define T_AS_1                                  (1)
-#define T_RC_1                                  (4)
-#define T_PRC_2                                 (1)
-#define T_BTA_2                                 (1)
-#define T_WP_2                                  (2)
-#define T_WR_2                                  (1)
-#define T_AS_2                                  (1)
-#define T_RC_2                                  (4)
-
-#define EBI_DECODE_0                            (0)
-#define EBI_DECODE_1                            (1)
-#define EBI_DECODE_2                            (2)
-#define EBI_DECODE_3                            (3)
-
-#define EBI_SMSKR_REG_SELECT_SHIFT              (8)
-#define EBI_SMSKR_REG_SELECT_MASK               (3)
-#define EBI_REG_SELECT_TIMING_SET_0             (0)
-#define EBI_REG_SELECT_TIMING_SET_1             (1)
-#define EBI_REG_SELECT_TIMING_SET_2             (2)
-
-#define EBI_SMSKR_MEM_TYPE_SHIFT                (5)
-#define EBI_SMSKR_MEM_TYPE_MASK                 (3)
-#define EBI_MEM_TYPE_SDRAM                      (0)
-#define EBI_MEM_TYPE_SRAM                       (1)
-#define EBI_MEM_TYPE_FLASH                      (2)
-
-#define EBI_SMSKR_MEM_SIZE_SHIFT                (0)
-#define EBI_SMSKR_MEM_SIZE_MASK                 (0x1F)
-#define EBI_MEM_SIZE_NO_MEMORY                  (0x00)
-#define EBI_MEM_SIZE_64KB                       (0x01)
-#define EBI_MEM_SIZE_128KB                      (0x02)
-#define EBI_MEM_SIZE_256KB                      (0x03)
-#define EBI_MEM_SIZE_512KB                      (0x04)
-#define EBI_MEM_SIZE_1MB                        (0x05)
-#define EBI_MEM_SIZE_2MB                        (0x06)
-#define EBI_MEM_SIZE_4MB                        (0x07)
-#define EBI_MEM_SIZE_8MB                        (0x08)
-#define EBI_MEM_SIZE_16MB                       (0x09)
-#define EBI_MEM_SIZE_32MB                       (0x0A)
-#define EBI_MEM_SIZE_64MB                       (0x0B)
-#define EBI_MEM_SIZE_128MB                      (0x0C)
-#define EBI_MEM_SIZE_256MB                      (0x0D)
-#define EBI_MEM_SIZE_512MB                      (0x0E)
-#define EBI_MEM_SIZE_1GB                        (0x0F)
-#define EBI_MEM_SIZE_2GB                        (0x10)
-#define EBI_MEM_SIZE_4GB                        (0x11)
-
-#define EBI_TIMING_SET_0                        (0)
-#define EBI_TIMING_SET_1                        (1)
-#define EBI_TIMING_SET_2                        (2)
-
-#define EBI_SMTMGR_REG_READ_PIPE_SHIFT          (28)
-#define EBI_SMTMGR_REG_READ_PIPE_MASK           (3)
-
-#define EBI_SMTMGR_REG_CLK_SYNC_SHIFT           (27)
-#define EBI_SMTMGR_REG_CLK_SYNC_MASK            (1)
-
-#define EBI_SMTMGR_REG_READY_MODE_SHIFT         (26)
-#define EBI_SMTMGR_REG_READY_MODE_MASK          (1)
-
-#define EBI_SMTMGR_REG_PAGE_SIZE_SHIFT          (24)
-#define EBI_SMTMGR_REG_PAGE_SIZE_MASK           (3)
-#define EBI_PAGE_SIZE_4                         (0)
-#define EBI_PAGE_SIZE_8                         (1)
-#define EBI_PAGE_SIZE_16                        (2)
-#define EBI_PAGE_SIZE_32                        (3)
-
-#define EBI_SMTMGR_REG_PAGE_MODE_SHIFT          (23)
-#define EBI_SMTMGR_REG_PAGE_MODE_MASK           (1)
-
-#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT    (19)
-#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK     (0xF)
-
-#define EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT    (16)
-#define EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK     (0x7)
-
-#define EBI_SMTMGR_REG_WRITE_PULSE_SHIFT        (10)
-#define EBI_SMTMGR_REG_WRITE_PULSE_MASK         (0x3F)
-
-#define EBI_SMTMGR_REG_ADDR_HOLD_SHIFT          (8)
-#define EBI_SMTMGR_REG_ADDR_HOLD_MASK           (3)
-
-#define EBI_SMTMGR_REG_ADDR_SETUP_SHIFT         (6)
-#define EBI_SMTMGR_REG_ADDR_SETUP_MASK          (3)
-
-#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK   (0x1F)
-
-#endif /* __PC3XX_EBI_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/emac.h b/arch/arm/include/asm/arch-pc3xx/emac.h
deleted file mode 100644
index 55b0456..0000000
--- a/arch/arm/include/asm/arch-pc3xx/emac.h
+++ /dev/null
@@ -1,189 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file emac.h
-* \brief Definitions for the PC3xx EMAC Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_EMAC_H__
-#define __PC3XX_EMAC_H__
-
-/* Constant-s -------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define EMAC_NETWORK_CTRL_REG_OFFSET                                (0x0000)
-#define EMAC_NETWORK_CFG_REG_OFFSET                                 (0x0004)
-#define EMAC_NETWORK_STATUS_REG_OFFSET                              (0x0008)
-#define EMAC_USER_IO_REG_OFFSET                                     (0x000C)
-#define EMAC_DMA_CFG_REG_OFFSET                                     (0x0010)
-#define EMAC_TX_STATUS_REG_OFFSET                                   (0x0014)
-#define EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x0018)
-#define EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x001C)
-#define EMAC_RX_STATUS_REG_OFFSET                                   (0x0020)
-#define EMAC_INT_STATUS_REG_OFFSET                                  (0x0024)
-#define EMAC_INT_ENABLE_REG_OFFSET                                  (0x0028)
-#define EMAC_INT_DISABLE_REG_OFFSET                                 (0x002C)
-#define EMAC_INT_MASK_REG_OFFSET                                    (0x0030)
-#define EMAC_PHY_MAINTAIN_REG_OFFSET                                (0x0034)
-#define EMAC_RX_PAUSE_QUANTUM_REG_OFFSET                            (0x0038)
-#define EMAC_TX_PAUSE_QUATNUM_REG_OFFSET                            (0x003C)
-#define EMAC_HASH_BOT_32_0_REG_OFFSET                               (0x0080)
-#define EMAC_HASH_TOP_63_32_REG_OFFSET                              (0x0084)
-#define EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET                        (0x0088)
-#define EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET                       (0x008C)
-#define EMAC_SPEC_ADDR_2_BOT_31_0_REG_OFFSET                        (0x0090)
-#define EMAC_SPEC_ADDR_2_TOP_47_32_REG_OFFSET                       (0x0094)
-#define EMAC_SPEC_ADDR_3_BOT_31_0_REG_OFFSET                        (0x0098)
-#define EMAC_SPEC_ADDR_3_TOP_47_32_REG_OFFSET                       (0x009C)
-#define EMAC_SPEC_ADDR_4_BOT_31_0_REG_OFFSET                        (0x00A0)
-#define EMAC_SPEC_ADDR_4_TOP_47_32_REG_OFFSET                       (0x00A4)
-#define EMAC_TYPE_ID_MATCH_1_REG_OFFSET                             (0x00A8)
-#define EMAC_TYPE_ID_MATCH_2_REG_OFFSET                             (0x00AC)
-#define EMAC_TYPE_ID_MATCH_3_REG_OFFSET                             (0x00B0)
-#define EMAC_TYPE_ID_MATCH_4_REG_OFFSET                             (0x00B4)
-#define EMAC_WOL_REG_OFFSET                                         (0x00B8)
-#define EMAC_IPG_STRETCH_REG_OFFSET                                 (0x00BC)
-#define EMAC_STACKED_VLAN_REG_OFFSET                                (0x00C0)
-
-#define EMAC_MODULE_ID_REG_OFFSET                                   (0x00FC)
-
-#define EMAC_OCTETS_TX_31_0_REG_OFFSET                              (0x0100)
-#define EMAC_OCTETS_TX_47_32_REG_OFFSET                             (0x0104)
-#define EMAC_FRAMES_TX_NO_ERROR_REG_OFFSET                          (0x0108)
-#define EMAC_BROADCAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x010C)
-#define EMAC_MULTICAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x0110)
-#define EMAC_TX_PAUSE_FRAMES_REG_OFFSET                             (0x0114)
-#define EMAC_64_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET                  (0x0118)
-#define EMAC_65_127_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET              (0x011C)
-#define EMAC_128_255_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0120)
-#define EMAC_256_511_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0124)
-#define EMAC_512_1023_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET            (0x0128)
-#define EMAC_1024_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET           (0x012C)
-#define EMAC_GREATER_THAN_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET   (0x0130)
-#define EMAC_TX_UNDER_RUN_ERROR_REG_OFFSET                          (0x0134)
-#define EMAC_SINGLE_COLLISION_FRAMES_REG_OFFSET                     (0x0138)
-#define EMAC_MULTIPLE_COLLISION_FRAMES_REG_OFFSET                   (0x013C)
-#define EMAC_EXCESSIVE_COLLISIONS_REG_OFFSET                        (0x0140)
-#define EMAC_LATE_COLLISIONS_REG_OFFSET                             (0x0144)
-#define EMAC_DEFFERED_TX_FRAMES_REG_OFFSET                          (0x0148)
-#define EMAC_CARRIER_SENSE_ERRORS_REG_OFFSET                        (0x014C)
-#define EMAC_OCTETS_RX_31_0_NO_ERROR_REG_OFFSET                     (0x0150)
-#define EMAC_OCTETS_RX_47_32_NO_ERROR_REG_OFFSET                    (0x0154)
-#define EMAC_FRAMES_RX_NO_ERROR_REG_OFFSET                          (0x0158)
-#define EMAC_BROADCAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x015C)
-#define EMAC_MULTICAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x0160)
-#define EMAC_PAUSE_FRAME_RX_REG_OFFSET                              (0x0164)
-#define EMAC_64_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET                  (0x0168)
-#define EMAC_65_127_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x016C)
-#define EMAC_128_255_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0170)
-#define EMAC_256_511_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0174)
-#define EMAC_512_1023_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET            (0x0178)
-#define EMAC_1024_1518_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET           (0x017C)
-#define EMAC_1519_TO_MAX_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x0180)
-#define EMAC_UNDERSIZE_FRAMES_RX_REG_OFFSET                         (0x0184)
-#define EMAC_OVERSIZE_FRAMES_RX_REG_OFFSET                          (0x0188)
-#define EMAC_JABBER_FRAMES_RX_REG_OFFSET                            (0x018C)
-#define EMAC_FCS_ERRORS_REG_OFFSET                                  (0x0190)
-#define EMAC_LENGTH_FIELD_FRAME_ERRORS_REG_OFFSET                   (0x0194)
-#define EMAC_RX_SYMBOL_ERRORS_REG_OFFSET                            (0x0198)
-#define EMAC_ALLIGNMENT_ERRORS_REG_OFFSET                           (0x019C)
-#define EMAC_RX_RESOURCE_ERRORS_REG_OFFSET                          (0x01A0)
-#define EMAC_RX_OVERRUN_ERRORS_REG_OFFSET                           (0x01A4)
-#define EMAC_IP_HDR_CHECKSUM_ERRORS_REG_OFFSET                      (0x01A8)
-#define EMAC_TCP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01AC)
-#define EMAC_UDP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01B0)
-
-#define EMAC_1588_TIMERS_SECONDS_REG_OFFSET                         (0x01D0)
-#define EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET                     (0x01D4)
-#define EMAC_1588_TIMER_ADJUST_REG_OFFSET                           (0x01D8)
-#define EMAC_1588_TIMER_INCREMENT_REG_OFFSET                        (0x01DC)
-
-#define EMAC_PTP_EVENT_FRAME_TX_SECONDS_REG_OFFSET                  (0x01E0)
-#define EMAC_PTP_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET             (0x01E4)
-#define EMAC_PTP_EVENT_FRAME_RX_SECONDS_REG_OFFSET                  (0x01E8)
-#define EMAC_PTP_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET             (0x01EC)
-#define EMAC_PTP_PEER_EVENT_FRAME_TX_SECONDS_REG_OFFSET             (0x01F0)
-#define EMAC_PTP_PEER_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET        (0x01F4)
-#define EMAC_PTP_PEER_EVENT_FRAME_RX_SECONDS_REG_OFFSET             (0x01F8)
-#define EMAC_PTP_PEER_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET        (0x01FC)
-
-#define EMAC_PCS_CTRL_REG_OFFSET                                    (0x0200)
-#define EMAC_PCS_STATUS_REG_OFFSET                                  (0x0204)
-#define EMAC_PCS_UPPER_PHY_ID_REG_OFFSET                            (0x0208)
-#define EMAC_PCS_LOWER_PHY_ID_REG_OFFSET                            (0x020C)
-#define EMAC_PCS_AUTO_NEG_ADVERT_REG_OFFSET                         (0x0210)
-#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_AB_REG_OFFSET                (0x0214)
-#define EMAC_PCS_AUTO_NEG_EXPANSION_REG_OFFSET                      (0x0218)
-#define EMAC_PCS_AUTO_NEG_NEXT_PAGE_REG_OFFSET                      (0x021C)
-#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_NEXT_PAGE_REG_OFFSET         (0x0220)
-#define EMAC_PCS_EXTENDED_STATUS_REG_OFFSET                         (0x023C)
-
-/* EMAC_NETWORK_CTRL_REG_OFFSET bits */
-#define EMAC_TRANSMIT_HALT                                          (((unsigned int)1) << 10)
-#define EMAC_START_TX                                               (((unsigned int)1) << 9)
-#define EMAC_CLEAR_STATS_REGISTERS                                  (((unsigned int)1) << 5)
-#define EMAC_MDIO_ENABLE                                            (((unsigned int)1) << 4)
-#define EMAC_TX_ENABLE                                              (((unsigned int)1) << 3)
-#define EMAC_RX_ENABLE                                              (((unsigned int)1) << 2)
-
-/* EMAC_NETWORK_CFG_REG_OFFSET bits */
-#define EMAC_64_BIT_AMBA_DATA_BUS_WITDH                             (((unsigned int)1) << 21)
-#define EMAC_MDC_CLOCK_DIV_MASK                                     (0x7 << 18)
-#define EMAC_MDC_CLOCK_DIV_96                                       (0x5 << 18)
-#define EMAC_FCS_REMOVE                                             (((unsigned int)1) << 17)
-#define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (((unsigned int)1) << 16)
-#define EMAC_FULL_DUPLEX                                            (((unsigned int)1) << 1)
-#define EMAC_SPEED_100_MBPS                                         (((unsigned int)1) << 0)
-
-/* EMAC_NETWORK_STATUS_REG_OFFSET bits */
-#define EMAC_PHY_MANAGEMENT_IDLE                                    (((unsigned int)1) << 2)
-
-/* EMAC_DMA_CFG_REG_OFFSET bits */
-#define EMAC_DMA_RX_BUFFER_SIZE_IDX                                 (16)
-#define EMAC_DMA_RX_BUFFER_SIZE_MASK                                (0xFF << EMAC_DMA_RX_BUFFER_SIZE_IDX)
-#define EMAC_DMA_RX_BUFFER_SIZE                                     (0x18 << EMAC_DMA_RX_BUFFER_SIZE_IDX)
-
-/* EMAC_PHY_MAINTAIN_REG_OFFSET bits */
-#define EMAC_PHY_ID_MASK                                            (0x1F)
-#define EMAC_PHY_ID_SHIFT                                           (23)
-#define EMAC_PHY_REG_MASK                                           (0x1F)
-#define EMAC_PHY_REG_SHIFT                                          (18)
-#define EMAC_PHY_DATA_MASK                                          (0xFFFF)
-
-/* EMAC_TX_STATUS_REG_OFFSET bits */
-#define EMAC_TRANSMIT_COMPLETE                                      (((unsigned int)1) << 5)
-#define EMAC_TRANSMIT_GO                                            (((unsigned int)1) << 3)
-
-/* Rx Descriptor Bits */
-#define EMAC_RX_DESC_WRAP                                           (((unsigned int)1) << 1)
-#define EMAC_RX_DESC_HOST_OWN                                       (((unsigned int)1) << 0)
-
-#define EMAC_RX_DESC_END_OF_FRAME                                   (((unsigned int)1) << 15)
-#define EMAC_RX_DESC_START_OF_FRAME                                 (((unsigned int)1) << 14)
-#define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
-
-/* Tx Descriptor Bits */
-#define EMAC_TX_DESC_HOST_OWN                                       (((unsigned int)1) << 31)
-#define EMAC_TX_DESC_WRAP                                           (((unsigned int)1) << 30)
-#define EMAC_TX_RETRY_ERROR                                         (((unsigned int)1) << 29)
-#define EMAC_TX_UNDERRUN_ERROR                                      (((unsigned int)1) << 28)
-#define EMAC_TX_FRAME_CORRUPTION_ERROR                              (((unsigned int)1) << 27)
-#define EMAC_TX_LATE_COLLISION_ERROR                                (((unsigned int)1) << 26)
-#define EMAC_TX_NO_CRC_APPEND                                       (((unsigned int)1) << 16)
-#define EMAC_TX_LAST_BUFFER                                         (((unsigned int)1) << 15)
-#define EMAC_TX_BUFFER_LENGTH_MASK                                  (0x3FFF)
-
-#endif /* __PC3XX_EMAC_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/fuse.h b/arch/arm/include/asm/arch-pc3xx/fuse.h
deleted file mode 100644
index 30f0bad..0000000
--- a/arch/arm/include/asm/arch-pc3xx/fuse.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file fuse.h
-* \brief Definitions for the PC3xx Fuse Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-#ifndef __PC3XX_FUSE_H__
-#define __PC3XX_FUSE_H__
-
-/* Constants -------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define FUSE_MAP_0_REG_OFFSET           (0x00)
-#define FUSE_MAP_1_REG_OFFSET           (0x04)
-#define FUSE_MAP_2_REG_OFFSET           (0x08)
-#define FUSE_MAP_3_REG_OFFSET           (0x0C)
-
-#define FUSE_MAP_4_REG_OFFSET           (0x10)
-#define FUSE_MAP_5_REG_OFFSET           (0x14)
-#define FUSE_MAP_6_REG_OFFSET           (0x18)
-#define FUSE_MAP_7_REG_OFFSET           (0x1C)
-
-#define FUSE_MAP_8_REG_OFFSET           (0x20)
-#define FUSE_MAP_9_REG_OFFSET           (0x24)
-#define FUSE_MAP_10_REG_OFFSET          (0x28)
-#define FUSE_MAP_11_REG_OFFSET          (0x2C)
-
-#define FUSE_MAP_12_REG_OFFSET          (0x30)
-#define FUSE_MAP_13_REG_OFFSET          (0x34)
-#define FUSE_MAP_14_REG_OFFSET          (0x38)
-#define FUSE_MAP_15_REG_OFFSET          (0x3C)
-
-#define FUSE_MAP_16_REG_OFFSET          (0x40)
-#define FUSE_MAP_17_REG_OFFSET          (0x44)
-#define FUSE_MAP_18_REG_OFFSET          (0x48)
-#define FUSE_MAP_19_REG_OFFSET          (0x4C)
-
-#define FUSE_MAP_20_REG_OFFSET          (0x50)
-#define FUSE_MAP_21_REG_OFFSET          (0x54)
-#define FUSE_MAP_22_REG_OFFSET          (0x58)
-#define FUSE_MAP_23_REG_OFFSET          (0x5C)
-
-#define FUSE_MAP_24_REG_OFFSET          (0x60)
-#define FUSE_MAP_25_REG_OFFSET          (0x64)
-#define FUSE_MAP_26_REG_OFFSET          (0x68)
-#define FUSE_MAP_27_REG_OFFSET          (0x6C)
-
-#define FUSE_MAP_28_REG_OFFSET          (0x70)
-#define FUSE_MAP_29_REG_OFFSET          (0x74)
-#define FUSE_MAP_30_REG_OFFSET          (0x78)
-#define FUSE_MAP_31_REG_OFFSET          (0x7C)
-
-#define FUSE_CONTROL_REG_OFFSET         (0x80)
-#define FUSE_WRITE_BIT_ADDR_REG_OFFSET  (0x84)
-#define FUSE_WRITE_PERFORM              (0x88)
-
-/*****************************************************************************/
-/* Register Bit Field Manipulation                                           */
-/*****************************************************************************/
-
-#define FUSE_WRITE_FUSE_ENABLE          (0x66757365)
-
-#endif /* __PC3XX_FUSE_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/gpio.h b/arch/arm/include/asm/arch-pc3xx/gpio.h
deleted file mode 100644
index e7ab91a..0000000
--- a/arch/arm/include/asm/arch-pc3xx/gpio.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file gpio.h
-* \brief Definitions for the PC3xx GPIO Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_GPIO_H__
-#define __PC3XX_GPIO_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define GPIO_SW_PORT_A_DR_REG_OFFSET        (0x00)
-#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    (0x04)
-#define GPIO_SW_PORT_A_CTL_REG_OFFSET       (0x08)
-#define GPIO_SW_PORT_B_DR_REG_OFFSET        (0x0C)
-#define GPIO_SW_PORT_B_DDR_REG_OFFSET	    (0x10)
-#define GPIO_SW_PORT_B_CTL_REG_OFFSET       (0x14)
-#define GPIO_SW_PORT_C_DR_REG_OFFSET        (0x18)
-#define GPIO_SW_PORT_C_DDR_REG_OFFSET	    (0x1C)
-#define GPIO_SW_PORT_C_CTL_REG_OFFSET       (0x20)
-#define GPIO_SW_PORT_D_DR_REG_OFFSET        (0x24)
-#define GPIO_SW_PORT_D_DDR_REG_OFFSET	    (0x28)
-#define GPIO_SW_PORT_D_CTL_REG_OFFSET       (0x2C)
-
-
-/* global GPIO registers */
-#define GPIO_INT_EN_REG_OFFSET              (0x30)
-#define GPIO_INT_MASK_REG_OFFSET            (0x34)
-#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    (0x38)
-#define GPIO_INT_POLARITY_REG_OFFSET 	    (0x3c)
-
-#define GPIO_INT_STATUS_REG_OFFSET	    (0x40)
-#define GPIO_RAW_INT_STATUS_REG_OFFSET	    (0x44)
-
-/* no debounce */
-#define GPIO_PORT_A_EOI_REG_OFFSET          (0x4c)
-#define GPIO_EXT_PORT_A_REG_OFFSET          (0x50)
-#define GPIO_EXT_PORT_B_REG_OFFSET          (0x54)
-#define GPIO_EXT_PORT_C_REG_OFFSET          (0x58)
-#define GPIO_EXT_PORT_D_REG_OFFSET          (0x5C)
-
-#define GPIO_LS_SYNC_REG_OFFSET		    (0x60)
-#define GPIO_ID_CODE_REG_OFFSET		    (0x64)
-#define GPIO_RESERVED_REG_OFFSET            (0x68)
-#define GPIO_COMP_VERSION_REG_OFFSET	    (0x6c)
-
-/* Macros ------------------------------------------------------------------ */
-
-/* Useful bit definitions */
-#define GPIO_BIT_7  (0x80)
-#define GPIO_BIT_6  (0x40)
-#define GPIO_BIT_5  (0x20)
-#define GPIO_BIT_4  (0x10)
-#define GPIO_BIT_3  (0x08)
-#define GPIO_BIT_2  (0x04)
-#define GPIO_BIT_1  (0x02)
-#define GPIO_BIT_0  (0x01)
-
-#endif /* __PC3XX_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mem_arm.h b/arch/arm/include/asm/arch-pc3xx/mem_arm.h
deleted file mode 100644
index 5c61cf5..0000000
--- a/arch/arm/include/asm/arch-pc3xx/mem_arm.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file mem_arm.h
-* \brief Definitions for the PC3xx Memif-ARM Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_MEM_ARM_H__
-#define __PC3XX_MEM_ARM_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define MEMIF_ARM_INDIRECT_RW_CMD_OFFSET    (0x00 * 4)
-#define MEMIF_ARM_RSVD_0_OFFSET             (0x01 * 4)
-#define MEMIF_ARM_HPR_OFFSET                (0x02 * 4)
-#define MEMIF_ARM_LPR_OFFSET                (0x03 * 4)
-#define MEMIF_ARM_WR_OFFSET                 (0x04 * 4)
-#define MEMIF_ARM_DRAM_PARAM_0_OFFSET       (0x05 * 4)
-#define MEMIF_ARM_DRAM_PARAM_1_OFFSET       (0x06 * 4)
-#define MEMIF_ARM_DRAM_PARAM_2_OFFSET       (0x07 * 4)
-#define MEMIF_ARM_DRAM_PARAM_3_OFFSET       (0x08 * 4)
-#define MEMIF_ARM_DRAM_PARAM_4_OFFSET       (0x09 * 4)
-#define MEMIF_ARM_DRAM_INIT_PARAM_OFFSET    (0x0A * 4)
-#define MEMIF_ARM_DRAM_EMR2_EMR3_OFFSET     (0x0B * 4)
-#define MEMIF_ARM_DRAM_EMR_MR_OFFSET        (0x0C * 4)
-#define MEMIF_ARM_DRAM_BL_OFFSET            (0x0D * 4)
-#define MEMIF_ARM_DRAM_FORCE_LPR_OFFSET     (0x0E * 4)
-#define MEMIF_ARM_ADDR_MAP_0_OFFSET         (0x0F * 4)
-#define MEMIF_ARM_ADDR_MAP_1_OFFSET         (0x10 * 4)
-#define MEMIF_ARM_ADDR_MAP_2_OFFSET         (0x11 * 4)
-#define MEMIF_ARM_DRAM_ODT_OFFSET           (0x12 * 4)
-#define MEMIF_ARM_PHY_DEBUG_0_OFFSET        (0x13 * 4)
-#define MEMIF_ARM_PHY_CMD_RDC_OFFSET        (0x14 * 4)
-#define MEMIF_ARM_CTRL_MODE_OFFSET          (0x15 * 4)
-#define MEMIF_ARM_DLL_CALIB_OFFSET          (0x16 * 4)
-#define MEMIF_ARM_ODT_CTRL_OFFSET           (0x17 * 4)
-#define MEMIF_ARM_DDRC_CTRL_0_OFFSET        (0x18 * 4)
-#define MEMIF_ARM_DDRC_CTRL_1_OFFSET        (0x19 * 4)
-#define MEMIF_ARM_PHY_SLV_DLL_OFFSET        (0x1A * 4)
-#define MEMIF_ARM_PHY_DEBUG_1_OFFSET        (0x1B * 4)
-#define MEMIF_ARM_PHY_DEBUG_2_OFFSET        (0x1C * 4)
-#define MEMIF_ARM_PHY_DEBUG_3_OFFSET        (0x1D * 4)
-#define MEMIF_ARM_PHY_DEBUG_4_OFFSET        (0x1E * 4)
-#define MEMIF_ARM_PHY_LOCAL_ODT_OFFSET      (0x1F * 4)
-#define MEMIF_ARM_GP0_OFFSET                (0x20 * 4)
-#define MEMIF_ARM_GP1_OFFSET                (0x21 * 4)
-#define MEMIF_ARM_GP2_OFFSET                (0x22 * 4)
-#define MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET \
-        (MEMIF_ARM_GP2_OFFSET)
-#define MEMIF_ARM_GP3_OFFSET                (0x23 * 4)
-#define MEMIF_ARM_GP4_OFFSET                (0x24 * 4)
-
-#define MEMIF_ARM_AXI_HP_MSTR_0_OFFSET      (0x3A * 4)
-#define MEMIF_ARM_AXI_HP_MSTR_1_OFFSET      (0x3B * 4)
-#define MEMIF_ARM_AXI_HP_MSTR_2_OFFSET      (0x3C * 4)
-#define MEMIF_ARM_AXI_HP_MSTR_3_OFFSET      (0x3D * 4)
-#define MEMIF_ARM_AXI_START_ADDR_OFFSET     (0x3E * 4)
-#define MEMIF_ARM_AXI_END_ADDR_OFFSET       (0x3F * 4)
-
-/*****************************************************************************/
-/* Register Values                                                           */
-/*****************************************************************************/
-
-/* Set up values for a single 512Mbx16 sdram device */
-#define MEMIF_ARM_ADDR_MAP_0_VAL_512Mbx16   (0x00000F77)  /* bank */
-#define MEMIF_ARM_ADDR_MAP_1_VAL_512Mbx16   (0xFFF00000)  /* col */
-#define MEMIF_ARM_ADDR_MAP_2_VAL_512Mbx16   (0x0FF22222)  /* row */
-
-/* Set up values for a single 1Gbx16 sdram device */
-#define MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16     (0x00000777)  /* bank */
-#define MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16     (0xFFF00000)  /* col */
-#define MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16     (0x0FF33333)  /* row */
-
-#define MEMIF_ARM_DRAM_EMR_MR_VAL           (0x00000A63)
-
-/* final wait after ddr initialisation sequence is 8 cycles */
-#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX     (0)
-#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK     (0x3F)
-#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL     (0x8)
-
-/* pre cke assertion delay must be 200us */
-#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX   (14)
-#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK   (0xFF)
-#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL   (0x50)
-
-/* post cke assertion is 400ns */
-#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX   (22)
-#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK   (0xFF)
-#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL   (0x2)
-
-/*****************************************************************************/
-/* Base Addresses                                                            */
-/*****************************************************************************/
-
-/* col  [9:0]  = axaddr[10:1] */
-/* bank [1:0]  = axaddr[12:11] */
-/* row  [12:0] = axaddr[25:13] */
-#define BANK0_BASE_512Mbx16                 (0x00000000)
-#define BANK1_BASE_512Mbx16                 (0x00000800)
-#define BANK2_BASE_512Mbx16                 (0x00001000)
-#define BANK3_BASE_512Mbx16                 (0x00001800)
-
-/* col  [9:0]  = axaddr[10:1] */
-/* bank [2:0]  = axaddr[13:11] */
-/* row  [13:0] = axaddr[27:14] */
-#define BANK0_BASE_1Gbx8                    (0x00000000)
-#define BANK1_BASE_1Gbx8                    (0x00000800)
-#define BANK2_BASE_1Gbx8                    (0x00001000)
-#define BANK3_BASE_1Gbx8                    (0x00001800)
-#define BANK4_BASE_1Gbx8                    (0x00002000)
-#define BANK5_BASE_1Gbx8                    (0x00002800)
-#define BANK6_BASE_1Gbx8                    (0x00003000)
-#define BANK7_BASE_1Gbx8                    (0x00003800)
-
-#endif /* __PC3XX_MEM_ARM_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mem_shd.h b/arch/arm/include/asm/arch-pc3xx/mem_shd.h
deleted file mode 100644
index 80e3f10..0000000
--- a/arch/arm/include/asm/arch-pc3xx/mem_shd.h
+++ /dev/null
@@ -1,395 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file mem_shd.h
-* \brief Definitions for the PC3xx Memif-Shared Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_MEM_SHD_H__
-#define __PC3XX_MEM_SHD_H__
-
-/* Includes ---------------------------------------------------------------- */
-#include "pa.h"
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define ADDR_PA_BUF0_SETUP                  (0x0000)
-#define ADDR_PA_BUF0_ADDR                   (0x0001)
-#define ADDR_PA_BUF1_SETUP                  (0x0002)
-#define ADDR_PA_BUF1_ADDR                   (0x0003)
-#define ADDR_PA_BUF2_SETUP                  (0x0004)
-#define ADDR_PA_BUF2_ADDR                   (0x0005)
-#define ADDR_PA_BUF3_SETUP                  (0x0006)
-#define ADDR_PA_BUF3_ADDR                   (0x0007)
-#define ADDR_PA_BUF4_SETUP                  (0x0008)
-#define ADDR_PA_BUF4_ADDR                   (0x0009)
-#define ADDR_PA_BUF5_SETUP                  (0x000A)
-#define ADDR_PA_BUF5_ADDR                   (0x000B)
-#define ADDR_PA_BUF6_SETUP                  (0x000C)
-#define ADDR_PA_BUF6_ADDR                   (0x000D)
-#define ADDR_PA_BUF7_SETUP                  (0x000E)
-#define ADDR_PA_BUF7_ADDR                   (0x000F)
-#define ADDR_PA_BUF8_SETUP                  (0x0010)
-#define ADDR_PA_BUF8_ADDR                   (0x0011)
-#define ADDR_PA_BUF9_SETUP                  (0x0012)
-#define ADDR_PA_BUF9_ADDR                   (0x0013)
-#define ADDR_SDRAM_ARB_G0_S0_S1             (0x0020)
-#define ADDR_SDRAM_ARB_G0_S2_S3             (0x0021)
-#define ADDR_SDRAM_ARB_G1_S0_S1             (0x0022)
-#define ADDR_SDRAM_ARB_G1_S2_S3             (0x0023)
-#define ADDR_SDRAM_ARB_G2_S0_S1             (0x0024)
-#define ADDR_SDRAM_ARB_G2_S2_S3             (0x0025)
-#define ADDR_SDRAM_ARB_G3_S0_S1             (0x0026)
-#define ADDR_SDRAM_ARB_G3_S2_S3             (0x0027)
-#define ADDR_SDRAM_ARB_G4_S0_S1             (0x0028)
-#define ADDR_SDRAM_ARB_G4_S2_S3             (0x0029)
-#define ADDR_SDRAM_ARB_G5_S0_S1             (0x002A)
-#define ADDR_SDRAM_ARB_G5_S2_S3             (0x002B)
-#define ADDR_SDRAM_ARB_G6_S0_S1             (0x002C)
-#define ADDR_SDRAM_ARB_G6_S2_S3             (0x002D)
-#define ADDR_SDRAM_ARB_G7_S0_S1             (0x002E)
-#define ADDR_SDRAM_ARB_G7_S2_S3             (0x002F)
-#define ADDR_SDRAM_VALID_GROUPS             (0x0030)
-#define ADDR_SRAM_ARB_S0_S1                 (0x0040)
-#define ADDR_SRAM_ARB_S2_S3                 (0x0041)
-#define ADDR_SRAM_ARB_S4_S5                 (0x0042)
-#define ADDR_SRAM_VALID_SLOTS               (0x0043)
-#define ADDR_ARB_UPDATE                     (0x004F)
-#define ADDR_SDRAM_SETUP                    (0x0050)
-#define ADDR_SDRAM_REFRESH                  (0x0051)
-#define ADDR_SDRAM_MRS                      (0x0052)
-#define ADDR_SDRAM_EMRS                     (0x0053)
-#define ADDR_SDRAM_EMRS2                    (0x0054)
-#define ADDR_SDRAM_EMRS3                    (0x0055)
-#define ADDR_SDRAM_ODT_SETUP                (0x0056)
-#define ADDR_SDRAM_CFG_DONE                 (0x0057)
-#define ADDR_SDRAM_AXI_CONFIG               (0x0058)
-#define ADDR_SDRAM_DEBUG                    (0x0059)
-#define ADDR_SDRAM_STATUS                   (0x005A)
-#define ADDR_PHY_TEST                       (0x0060)
-#define ADDR_PHY_CONFIG                     (0x0061)
-#define ADDR_PHY_LOCAL_ODT_CONFIG           (0x0062)
-#define ADDR_PHY_RDC_FIFO_RST_ERR_CNT       (0x0063)
-#define ADDR_PHY_WR_SLAVE                   (0x0064)
-#define ADDR_PHY_RD_SLAVE                   (0x0065)
-#define ADDR_PHY_DEBUG_WR_DLL0              (0x0066)
-#define ADDR_PHY_DEBUG_RC_DLL0              (0x0068)
-#define ADDR_PHY_DEBUG_RC_DLL1              (0x0069)
-#define ADDR_PHY_IO_CELL_CONFIG             (0x006A)
-#define ADDR_PHY_DEBUG_STATUS_BC            (0x0070)
-#define ADDR_PHY_DEBUG_STATUS_RC_DLL_0      (0x0071)
-#define ADDR_PHY_DEBUG_STATUS_RC_DLL_1      (0x0072)
-#define ADDR_PHY_DEBUG_STATUS_MASTER_DLL_0  (0x0073)
-#define ADDR_PHY_DEBUG_STATUS_OF_IN_DELAY_0 (0x0075)
-#define ADDR_PHY_DEBUG_STATUS_OF_OUT_DELAY_0    (0x0076)
-#define ADDR_PA_FIFO_STATUS_LWR             (0x0080)
-#define ADDR_PA_FIFO_STATUS_UPR             (0x0081)
-#define ADDR_PA_ADDR_ERR_LWR                (0x0082)
-#define ADDR_PA_ADDR_ERR_UPR                (0x0083)
-#define ADDR_PA_ADDR_ERR_MASK_LWR           (0x0084)
-#define ADDR_PA_ADDR_ERR_MASK_UPR           (0x0085)
-
-#define CBFM_SLEEPREG_ADDR                  (0xA060)
-#define CBFM_RUNREG_ADDR                    (0xA061)
-#define CBFM_ERRREG_ADDR                    (0xA062)
-#define CBFM_RESETREG_ADDR                  (0xA063)
-#define CBFM_IDREG_ADDR                     (0xA064)
-#define CBFM_RSTRUNMASK_ADDR                (0xA065)
-#define CBFM_BISTEN_ADDR                    (0xA066)
-#define CBFM_BISTDATA_ADDR                  (0xA067)
-#define CBFM_TM_ADDR                        (0xA068)
-
-/*****************************************************************************/
-/* Register Values                                                           */
-/*****************************************************************************/
-
-#define DDR2_ROW_13_COL_9               (0x2)
-#define DDR2_ROW_13_COL_10              (0x1)
-#define DDR2_ROW_14_COL_10              (0x0)
-#define DDR2_8_BANKS                    (0x1)
-#define DDR2_4_BANKS                    (0x0)
-#define DDR2_BRC_ADDR                   (0x0)
-#define DDR2_RBC_ADDR                   (0x1)
-#define DDR2_RW_GAP                     (0x3)
-#define DDR2_WR_GAP                     (0xa)
-#define DDR2_CAS_4                      (0x4)
-#define DDR2_CAS_5                      (0x5)
-#define DDR2_CAS_6                      (0x6)
-#define DDR2_CAS_7                      (0x7)
-#define DDR2_REFRESH_TIME               (0x07d0)
-#define DDR2_BURST_SEQUENTIAL           (0x0000)
-#define DDR2_WR                         (0x05)
-#define DDR2_DQSN_DISABLE               (0x1)
-
-#define SDRAM_ARB_AXI_SLOT              (0)
-#define SDRAM_ARB_PA_SLOT               (1)
-#define SDRAM_ARB_DET_SLOT              (0)
-#define SDRAM_ARB_OPP_SLOT              (1)
-#define SDRAM_ARB_RD_SLOT               (0)
-#define SDRAM_ARB_WR_SLOT               (1)
-#define SDRAM_ARB_CSP_1_SLOT            (0)
-#define SDRAM_ARB_CSP_2_SLOT            (1)
-#define SDRAM_ARB_CSP_4_SLOT            (2)
-#define SDRAM_ARB_CSP_8_SLOT            (3)
-
-#define SDRAM_ARB_1_VALID_SLOT          (1)
-#define SDRAM_ARB_2_VALID_SLOT          (3)
-#define SDRAM_ARB_3_VALID_SLOT          (7)
-#define SDRAM_ARB_4_VALID_SLOT          (15)
-#define SDRAM_ARB_5_VALID_SLOT          (31)
-#define SDRAM_ARB_6_VALID_SLOT          (63)
-#define SDRAM_ARB_7_VALID_SLOT          (127)
-#define SDRAM_ARB_8_VALID_SLOT          (255)
-
-#define PHY_CONFIG_BL_4                 (2)
-#define PHY_CONFIG_BL_8                 (3)
-#define PHY_CONFIG_RDC_WE_TO_RE_2       (2)
-#define PHY_CONFIG_FIXED_RE             (1)
-
-#define ADDR_SDRAM_STATUS_INIT_DONE_BIT     (0)
-#define ADDR_SDRAM_STATUS_IN_RESET_BIT      (1)
-#define ADDR_SDRAM_STATUS_IN_STB_CLK_BIT    (2)
-#define ADDR_SDRAM_STATUS_IN_INIT_BIT       (3)
-#define ADDR_SDRAM_STATUS_IN_ARB_BIT        (4)
-#define ADDR_SDRAM_STATUS_IN_REF_BIT        (5)
-#define ADDR_SDRAM_STATUS_IN_UPDATE_BIT     (6)
-#define ADDR_SDRAM_STATUS_IN_RW_GAP_BIT     (7)
-#define ADDR_SDRAM_STATUS_IN_WR_GAP_BIT     (8)
-
-#define SDRAM_SETUP_SIZE_IDX            (0)
-#define SDRAM_SETUP_BANK_IDX            (2)
-#define SDRAM_SETUP_RW_GAP_IDX          (3)
-#define SDRAM_SETUP_WR_GAP_IDX          (7)
-#define SDRAM_SETUP_CAS_IDX             (11)
-
-#define SDRAM_AXI_SETUP_RBC_IDX         (0)
-#define SDRAM_AXI_SETUP_SIZE_IDX        (1)
-#define SDRAM_AXI_SETUP_BANK_IDX        (3)
-
-#define SDRAM_ARB_S0_AP_IDX             (0)
-#define SDRAM_ARB_S0_APOD_IDX           (1)
-#define SDRAM_ARB_S0_RW_IDX             (2)
-#define SDRAM_ARB_S0_RWOD_IDX           (3)
-#define SDRAM_ARB_S0_CSP_IDX            (4)
-
-#define SDRAM_ARB_S1_AP_IDX             (8)
-#define SDRAM_ARB_S1_APOD_IDX           (9)
-#define SDRAM_ARB_S1_RW_IDX             (10)
-#define SDRAM_ARB_S1_RWOD_IDX           (11)
-#define SDRAM_ARB_S1_CSP_IDX            (12)
-
-#define SDRAM_ARB_S2_AP_IDX             (0)
-#define SDRAM_ARB_S2_APOD_IDX           (1)
-#define SDRAM_ARB_S2_RW_IDX             (2)
-#define SDRAM_ARB_S2_RWOD_IDX           (3)
-#define SDRAM_ARB_S2_CSP_IDX            (4)
-
-#define SDRAM_ARB_S3_AP_IDX             (8)
-#define SDRAM_ARB_S3_APOD_IDX           (9)
-#define SDRAM_ARB_S3_RW_IDX             (10)
-#define SDRAM_ARB_S3_RWOD_IDX           (11)
-#define SDRAM_ARB_S3_CSP_IDX            (12)
-
-#define PHY_CONFIG_FIRST_RD_IDX         (0)
-#define PHY_CONFIG_FIRST_WR_IDX         (4)
-#define PHY_CONFIG_BL_IDX               (8)
-#define PHY_CONFIG_RDC_WE_TO_RE_IDX     (11)
-#define PHY_CONFIG_FIXED_RE_IDX         (13)
-
-#define MRS_PHY_CONFIG_BL_IDX           (0)
-#define MRS_DDR2_BURST_SEQUENTIAL_IDX   (3)
-#define MRS_DDR2_CAS_IDX                (4)
-#define MRS_DDR2_WR_IDX                 (9)
-
-#define EMRS_ODT_LOW_BIT_IDX            (2)
-#define EMRS_ODT_HIGH_BIT_IDX           (6)
-#define EMRS_DQSN_DISABLE_IDX           (10)
-
-/*****************************************************************************/
-/* Used to create a 'load file' for the pA                                   */
-/*****************************************************************************/
-
-#define LF_PA_AEID_MEMIF                (PA_AEID_MEMIF | PA_CONFIG_AEID)
-
-#define LF_CBFM_SLEEPREG_ADDR           (CBFM_SLEEPREG_ADDR | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_ARB_G0_S0_S1      (ADDR_SDRAM_ARB_G0_S0_S1 | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_ARB_G0_S2_S3      (ADDR_SDRAM_ARB_G0_S2_S3 | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_ARB_G1_S0_S1      (ADDR_SDRAM_ARB_G1_S0_S1 | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_ARB_G1_S2_S3      (ADDR_SDRAM_ARB_G1_S2_S3 | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_VALID_GROUPS      (ADDR_SDRAM_VALID_GROUPS | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_SETUP             (ADDR_SDRAM_SETUP | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_REFRESH           (ADDR_SDRAM_REFRESH | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_ODT_SETUP         (ADDR_SDRAM_ODT_SETUP | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_AXI_CONFIG        (ADDR_SDRAM_AXI_CONFIG | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_MRS               (ADDR_SDRAM_MRS | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_EMRS              (ADDR_SDRAM_EMRS | PA_CONFIG_ADDR)
-#define LF_ADDR_PHY_CONFIG              (ADDR_PHY_CONFIG | PA_CONFIG_ADDR)
-#define LF_ADDR_PHY_LOCAL_ODT_CONFIG    (ADDR_PHY_LOCAL_ODT_CONFIG | PA_CONFIG_ADDR)
-#define LF_ADDR_PHY_RD_SLAVE            (ADDR_PHY_RD_SLAVE | PA_CONFIG_ADDR)
-#define LF_ADDR_PHY_WR_SLAVE            (ADDR_PHY_WR_SLAVE | PA_CONFIG_ADDR)
-#define LF_ADDR_PHY_IO_CELL_CONFIG      (ADDR_PHY_IO_CELL_CONFIG | PA_CONFIG_ADDR)
-#define LF_ADDR_SDRAM_CFG_DONE          (ADDR_SDRAM_CFG_DONE | PA_CONFIG_ADDR)
-
-#define ADDR_SDRAM_ARB_G0_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
-
-#define ADDR_SDRAM_ARB_G0_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
-
-#define ADDR_SDRAM_ARB_G1_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
-
-#define ADDR_SDRAM_ARB_G1_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
-                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
-                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
-                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
-                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
-
-#define ADDR_SDRAM_VALID_GROUPS_DATA    (0x00000000 | PA_CONFIG_WRITE | SDRAM_ARB_2_VALID_SLOT)
-
-#define ADDR_SDRAM_SETUP_DATA           (0x00000000 | PA_CONFIG_WRITE | \
-                                        (DDR2_ROW_13_COL_10 << SDRAM_SETUP_SIZE_IDX)     | \
-                                        (DDR2_8_BANKS       << SDRAM_SETUP_BANK_IDX)     | \
-                                        (DDR2_RW_GAP        << SDRAM_SETUP_RW_GAP_IDX)   | \
-                                        (DDR2_WR_GAP        << SDRAM_SETUP_WR_GAP_IDX)   | \
-                                        (DDR2_CAS_6         << SDRAM_SETUP_CAS_IDX))
-
-#define ADDR_SDRAM_REFRESH_DATA         (0x00000000 | PA_CONFIG_WRITE | DDR2_REFRESH_TIME)
-
-#define ADDR_SDRAM_AXI_CONFIG_DATA      (0x00000000 | PA_CONFIG_WRITE | \
-                                        (DDR2_BRC_ADDR      << SDRAM_AXI_SETUP_RBC_IDX)   | \
-                                        (DDR2_ROW_13_COL_10 << SDRAM_AXI_SETUP_SIZE_IDX)  | \
-                                        (DDR2_8_BANKS       << SDRAM_AXI_SETUP_BANK_IDX))
-
-#define ADDR_SDRAM_MRS_DATA             (0x00000000 | PA_CONFIG_WRITE | \
-                                        (PHY_CONFIG_BL_4        << MRS_PHY_CONFIG_BL_IDX) | \
-                                        (DDR2_BURST_SEQUENTIAL  << MRS_DDR2_BURST_SEQUENTIAL_IDX) | \
-                                        (DDR2_CAS_6             << MRS_DDR2_CAS_IDX) | \
-                                        (DDR2_WR                << MRS_DDR2_WR_IDX))
-
-#define SDRAM_ODT_75_OHM_LO             (0x1)
-#define SDRAM_ODT_75_OHM_HI             (0x0)
-
-#define ADDR_SDRAM_EMRS_DATA            (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ODT_75_OHM_LO        << EMRS_ODT_LOW_BIT_IDX) | \
-                                        (SDRAM_ODT_75_OHM_HI        << EMRS_ODT_HIGH_BIT_IDX) | \
-                                        (DDR2_DQSN_DISABLE << EMRS_DQSN_DISABLE_IDX))
-
-#define ADDR_PHY_CONFIG_DATA            (0x00000000 | PA_CONFIG_WRITE | \
-                                        (DDR2_CAS_6                 << PHY_CONFIG_FIRST_RD_IDX) | \
-                                        ((DDR2_CAS_6 - 1)           << PHY_CONFIG_FIRST_WR_IDX) | \
-                                        (PHY_CONFIG_BL_4            << PHY_CONFIG_BL_IDX)       | \
-                                        (PHY_CONFIG_RDC_WE_TO_RE_2  << PHY_CONFIG_RDC_WE_TO_RE_IDX) | \
-                                        (PHY_CONFIG_FIXED_RE        << PHY_CONFIG_FIXED_RE_IDX))
-
-#define SDRAM_ODT_ENABLE_IDX            (0)
-#define SDRAM_ODT_ON_DELAY_IDX          (1)
-#define SDRAM_ODT_ON_DURN_IDX           (4)
-#define SDRAM_ODT_ENABLE                (0x1)
-#define SDRAM_ODT_ON_DURN               (0x2)
-
-#define ADDR_SDRAM_ODT_DATA             (0x00000000 | PA_CONFIG_WRITE | \
-                                        (SDRAM_ODT_ENABLE   << SDRAM_ODT_ENABLE_IDX) | \
-                                        ((DDR2_CAS_6 - 4)   << SDRAM_ODT_ON_DELAY_IDX) | \
-                                        (SDRAM_ODT_ON_DURN  << SDRAM_ODT_ON_DURN_IDX))
-
-#define PHY_LOCAL_ODT_75_OHM            (0x1)
-#define PHY_LOCAL_ODT_OFF               (0x0)
-#define PHY_LOCAL_ODT_READ_IDX          (0)
-#define PHY_LOCAL_ODT_WRITE_IDX         (2)
-#define PHY_LOCAL_ODT_IDLE_IDX          (4)
-
-#define ADDR_PHY_LOCAL_ODT_CONFIG_DATA  (0x00000000 | PA_CONFIG_WRITE | \
-                                        (PHY_LOCAL_ODT_75_OHM   << PHY_LOCAL_ODT_READ_IDX) | \
-                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_WRITE_IDX) | \
-                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_IDLE_IDX))
-
-#define PHY_RD0_DLL_SLAVE_DELAY         (0x30)
-#define PHY_RD1_DLL_SLAVE_DELAY         (0x30)
-#define PHY_WR_DLL_SLAVE_DELAY          (0x40)
-
-#define PHY_RD0_DLL_SLAVE_IDX           (0)
-#define PHY_RD1_DLL_SLAVE_IDX           (8)
-#define PHY_WR_DLL_SLAVE_IDX            (0)
-
-
-#define ADDR_PHY_RD_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
-                                        (PHY_RD0_DLL_SLAVE_DELAY << PHY_RD0_DLL_SLAVE_IDX) | \
-                                        (PHY_RD1_DLL_SLAVE_DELAY << PHY_RD1_DLL_SLAVE_IDX))
-
-#define ADDR_PHY_WR_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
-                                        (PHY_WR_DLL_SLAVE_DELAY << PHY_WR_DLL_SLAVE_IDX))
-
-
-#define PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX   (4)
-
-#define PHY_CTRL_DRV_STRENGTH_HALF              (1)
-#define PHY_DATA_DRV_STRENGTH_HALF              (1)
-#define PHY_CLK_DRV_STRENGTH_HALF               (1)
-#define PHY_FIFO_WE_DRV_STRENGTH_HALF           (1)
-
-#define PHY_CTRL_DRV_STRENGTH_HALF_IDX          (0)
-#define PHY_DATA_DRV_STRENGTH_HALF_IDX          (1)
-#define PHY_CLK_DRV_STRENGTH_HALF_IDX           (2)
-#define PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX       (3)
-
-
-#define ADDR_PHY_IO_CELL_CONFIG_DATA    (0x00000000 | PA_CONFIG_WRITE | \
-                                        (PHY_LOCAL_ODT_75_OHM           << PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX) | \
-                                        (PHY_FIFO_WE_DRV_STRENGTH_HALF  << PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX) | \
-                                        (PHY_CLK_DRV_STRENGTH_HALF      << PHY_CLK_DRV_STRENGTH_HALF_IDX) | \
-                                        (PHY_DATA_DRV_STRENGTH_HALF     << PHY_DATA_DRV_STRENGTH_HALF_IDX) | \
-                                        (PHY_CTRL_DRV_STRENGTH_HALF     << PHY_CTRL_DRV_STRENGTH_HALF_IDX))
-
-#define ADDR_SDRAM_CFG_DONE_DATA        (0x0001 | PA_CONFIG_WRITE)
-
-#define PA_WRITE_ZERO_DATA              (PA_CONFIG_WRITE)
-
-#endif /* __PC3XX_MEM_SHD_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/mux.h b/arch/arm/include/asm/arch-pc3xx/mux.h
deleted file mode 100644
index 736093c..0000000
--- a/arch/arm/include/asm/arch-pc3xx/mux.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file mux.h
-* \brief Definitions for the PC3xx gpio muxing
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_MUX_H__
-#define __PC3XX_MUX_H__
-
-/* stringify used in mux.c */
-#define __stringify_1(x...)     #x
-#define __stringify(x...)       __stringify_1(x)
-
-/*
- * Pins can typically be:
- *	- a system function such as EBI, SSI etc,
- *	- ARM controlled GPIO.
- *	- picoArray controlled GPIO.
- *	- not multiplexed at all (MUX_UNMUXED).
- */
-enum mux_setting {
-	MUX_PERIPHERAL	= (1 << 0),
-	MUX_ARM		= (1 << 1),
-	MUX_SD		= (1 << 2),
-	MUX_UNMUXED	= (1 << 3),
-};
-
-int
-pc3xx_pin_set_mux(int pin_nr,
-		  enum mux_setting setting);
-
-int
-pc3xx_group_set_mux(const char *group_name,
-		    enum mux_setting setting);
-
-int
-pc3xx_get_pin_mux(int pin_nr);
-
-void
-pc3xx_muxing_init(void);
-
-#endif /* __PC3XX_MUX_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pa.h b/arch/arm/include/asm/arch-pc3xx/pa.h
deleted file mode 100644
index 2e8e240..0000000
--- a/arch/arm/include/asm/arch-pc3xx/pa.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file pa.h
-* \brief Definitions for the picoArray.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_PA_H__
-#define __PC3XX_PA_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/* Broadcast Id for memif-Shared */
-#define PA_BROADCAST_ID_MEMIF   (0x8020)
-
-/* The memif-Shared aeid changed from PC3x2 devices to PC3x3 devices,
- * to avoid lots of code changes we just use the memif-Shared
- * broadcast address instead.
- */
-#define PA_AEID_MEMIF       (PA_BROADCAST_ID_MEMIF)
-
-#define PA_CONFIG_WRITE     (0x00010000)
-#define PA_CONFIG_READ      (0x00020000)
-#define PA_CONFIG_ADDR      (0x00040000)
-#define PA_CONFIG_AEID      (0x00080000)
-#define PA_CONFIG_VALID     (0x00010000)
-#define PA_CONFIG_FAIL      (0x00020000)
-#define PA_CONFIG_TIMEOUT   (0x00040000)
-
-#endif /* __PC3XX_PA_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pc302.h b/arch/arm/include/asm/arch-pc3xx/pc302.h
deleted file mode 100644
index 49934af..0000000
--- a/arch/arm/include/asm/arch-pc3xx/pc302.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file pc302.h
-* \brief Definitions for the PC3xx ARM sub-system.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_H__
-#define __PC3XX_H__
-
-/*****************************************************************************/
-/* Internal Boot ROM                                                         */
-/*****************************************************************************/
-#define PC302_BOOT_ROM_BASE         (0xFFFF0000)
-
-/*****************************************************************************/
-/* AXI2PICO Buffers                                                          */
-/*****************************************************************************/
-#define PC302_AXI2PICO_BUFFERS_BASE (0xC0000000)
-
-/*****************************************************************************/
-/* Peripheral Bus                                                            */
-/*****************************************************************************/
-#define PC302_MEMIF_BASE            (0x80000000)
-#define PC302_EBI_BASE              (0x80010000)
-#define PC302_EMAC_BASE             (0x80030000)
-#define PC302_DMAC1_BASE            (0x80040000)
-#define PC302_DMAC2_BASE            (0x80050000)
-#define PC302_VIC0_BASE             (0x80060000)
-#define PC302_VIC1_BASE             (0x80064000)
-#define PC302_TZIC_BASE             (0x80068000)
-#define PC302_TZPC_BASE             (0x80070000)
-#define PC302_FUSE_BASE             (0x80080000)
-#define PC302_SSI_BASE              (0x80090000)
-#define PC302_AXI2CFG_BASE          (0x800A0000)
-#define PC302_IPSEC_BASE            (0x80100000)
-#define PC302_SRTP_BASE             (0x80140000)
-#define PC302_CIPHER_BASE           (0x80180000)
-#define PC302_RTCLK_BASE            (0x80200000)
-#define PC302_TIMER_BASE            (0x80210000)
-#define PC302_GPIO_BASE             (0x80220000)
-#define PC302_UART1_BASE            (0x80230000)
-#define PC302_UART2_BASE            (0x80240000)
-#define PC302_WDOG_BASE             (0x80250000)
-
-/*****************************************************************************/
-/* External Memory                                                           */
-/*****************************************************************************/
-#define PC302_DDRBANK_BASE          (0x00000000)
-
-#define PC302_EBI_CS0_BASE          (0x40000000)
-#define PC302_EBI_CS1_BASE          (0x48000000)
-#define PC302_EBI_CS2_BASE          (0x50000000)
-#define PC302_EBI_CS3_BASE          (0x58000000)
-
-#define PC302_FLASH_BASE            (PC302_EBI_CS0_BASE)
-#define PC302_FLASH_START           (PC302_EBI_CS0_BASE)
-#define PC302_FLASH_SIZE            (0x08000000)
-
-/*****************************************************************************/
-/* Internal SRAM Memory                                                      */
-/*****************************************************************************/
-#define PC302_SRAM_BASE             (0x20000000)
-#define PC302_SRAM_START            (0x20000000)
-#define PC302_SRAM_SIZE             (0x00020000)
-
-/*****************************************************************************/
-/* Silicon Revision                                                          */
-/*****************************************************************************/
-#define PC3X2_REV_A                 (0)
-#define PC3X2_REV_D                 (1)
-
-/*****************************************************************************/
-/* Device Ids                                                                */
-/*****************************************************************************/
-#define PC302_DEVICE_ID             (0x03)
-#define PC312_DEVICE_ID             (0x07)
-#define PC313_DEVICE_ID             (0x20)
-#define PC323_DEVICE_ID             (0x21)
-#define PC333_DEVICE_ID             (0x22)
-
-#endif /* __PC3XX_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h b/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
deleted file mode 100644
index 2bea499..0000000
--- a/arch/arm/include/asm/arch-pc3xx/pc3xxgpio.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file pc3xxgpio.h
-* \brief Definitions for use with the PC3xx gpio library
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __MACH_GPIO_H__
-#define __MACH_GPIO_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/* Use on PC3x2 devices */
-enum {
-	PC302_GPIO_PIN_ARM_0 =  0,  /* ARM GPIO pin identifiers. */
-	PC302_GPIO_PIN_ARM_1,
-	PC302_GPIO_PIN_ARM_2,
-	PC302_GPIO_PIN_ARM_3,
-	PC302_GPIO_PIN_ARM_4,
-	PC302_GPIO_PIN_ARM_5,
-	PC302_GPIO_PIN_ARM_6,
-	PC302_GPIO_PIN_ARM_7,
-	PC302_GPIO_PIN_SDGPIO_0,    /* SDGPIO pin identifiers. */
-	PC302_GPIO_PIN_SDGPIO_1,
-	PC302_GPIO_PIN_SDGPIO_2,
-	PC302_GPIO_PIN_SDGPIO_3,
-	PC302_GPIO_PIN_SDGPIO_4,
-	PC302_GPIO_PIN_SDGPIO_5,
-	PC302_GPIO_PIN_SDGPIO_6,
-	PC302_GPIO_PIN_SDGPIO_7,
-	PC302_GPIO_PIN_ARM_8,      /* ARM shared pins. */
-	PC302_GPIO_PIN_ARM_9,
-	PC302_GPIO_PIN_ARM_10,
-	PC302_GPIO_PIN_ARM_11,
-	PC302_GPIO_PIN_ARM_12,
-	PC302_GPIO_PIN_ARM_13,
-	PC302_GPIO_PIN_ARM_14,
-	PC302_GPIO_PIN_ARM_15,
-	PC302_GPIO_PIN_SDGPIO_8,  /* SDGPIO shared pins. */
-	PC302_GPIO_PIN_SDGPIO_9,
-	PC302_GPIO_PIN_SDGPIO_10,
-	PC302_GPIO_PIN_SDGPIO_11,
-	PC302_GPIO_PIN_SDGPIO_12,
-	PC302_GPIO_PIN_SDGPIO_13,
-	PC302_GPIO_PIN_SDGPIO_14,
-	PC302_GPIO_PIN_SDGPIO_15,
-};
-
-/* Use on PC3x3 devices */
-enum {
-	PC3X3_GPIO_PIN_ARM_0,
-	PC3X3_GPIO_PIN_ARM_1,
-	PC3X3_GPIO_PIN_ARM_2,
-	PC3X3_GPIO_PIN_ARM_3,
-	PC3X3_GPIO_PIN_ARM_4,
-	PC3X3_GPIO_PIN_ARM_5,
-	PC3X3_GPIO_PIN_ARM_6,
-	PC3X3_GPIO_PIN_ARM_7,
-	PC3X3_GPIO_PIN_ARM_8,
-	PC3X3_GPIO_PIN_ARM_9,
-	PC3X3_GPIO_PIN_ARM_10,
-	PC3X3_GPIO_PIN_ARM_11,
-	PC3X3_GPIO_PIN_ARM_12,
-	PC3X3_GPIO_PIN_ARM_13,
-	PC3X3_GPIO_PIN_ARM_14,
-	PC3X3_GPIO_PIN_ARM_15,
-	PC3X3_GPIO_PIN_ARM_16,
-	PC3X3_GPIO_PIN_ARM_17,
-	PC3X3_GPIO_PIN_ARM_18,
-	PC3X3_GPIO_PIN_ARM_19,
-	PC3X3_GPIO_PIN_ARM_20,
-	PC3X3_GPIO_PIN_ARM_21,
-	PC3X3_GPIO_PIN_ARM_22,
-	PC3X3_GPIO_PIN_ARM_23,
-	PC3X3_GPIO_PIN_ARM_24,
-	PC3X3_GPIO_PIN_ARM_25,
-	PC3X3_GPIO_PIN_ARM_26,
-	PC3X3_GPIO_PIN_ARM_27,
-	PC3X3_GPIO_PIN_ARM_28,
-	PC3X3_GPIO_PIN_ARM_29,
-	PC3X3_GPIO_PIN_ARM_30,
-	PC3X3_GPIO_PIN_ARM_31,
-	PC3X3_GPIO_PIN_ARM_32,
-	PC3X3_GPIO_PIN_ARM_33,
-	PC3X3_GPIO_PIN_ARM_34,
-	PC3X3_GPIO_PIN_ARM_35,
-	PC3X3_GPIO_PIN_ARM_36,
-	PC3X3_GPIO_PIN_ARM_37,
-	PC3X3_GPIO_PIN_ARM_38,
-	PC3X3_GPIO_PIN_ARM_39,
-	PC3X3_GPIO_PIN_ARM_40,
-	PC3X3_GPIO_PIN_ARM_41,
-	PC3X3_GPIO_PIN_ARM_42,
-	PC3X3_GPIO_PIN_ARM_43,
-	PC3X3_GPIO_PIN_ARM_44,
-	PC3X3_GPIO_PIN_ARM_45,
-	PC3X3_GPIO_PIN_ARM_46,
-	PC3X3_GPIO_PIN_ARM_47,
-	PC3X3_GPIO_PIN_ARM_48,
-	PC3X3_GPIO_PIN_ARM_49,
-	PC3X3_GPIO_PIN_ARM_50,
-	PC3X3_GPIO_PIN_ARM_51,
-	PC3X3_GPIO_PIN_ARM_52,
-	PC3X3_GPIO_PIN_ARM_53,
-	PC3X3_GPIO_PIN_SDGPIO_0,
-	PC3X3_GPIO_PIN_SDGPIO_1,
-	PC3X3_GPIO_PIN_SDGPIO_2,
-	PC3X3_GPIO_PIN_SDGPIO_3,
-	PC3X3_GPIO_PIN_SDGPIO_4,
-	PC3X3_GPIO_PIN_SDGPIO_5,
-	PC3X3_GPIO_PIN_SDGPIO_6,
-	PC3X3_GPIO_PIN_SDGPIO_7,
-	PC3X3_GPIO_PIN_SDGPIO_8,
-	PC3X3_GPIO_PIN_SDGPIO_9,
-	PC3X3_GPIO_PIN_SDGPIO_10,
-	PC3X3_GPIO_PIN_SDGPIO_11,
-	PC3X3_GPIO_PIN_SDGPIO_12,
-	PC3X3_GPIO_PIN_SDGPIO_13,
-	PC3X3_GPIO_PIN_SDGPIO_14,
-	PC3X3_GPIO_PIN_SDGPIO_15,
-	PC3X3_GPIO_PIN_SDGPIO_16,
-	PC3X3_GPIO_PIN_SDGPIO_17,
-	PC3X3_GPIO_PIN_SDGPIO_18,
-	PC3X3_GPIO_PIN_SDGPIO_19,
-	PC3X3_GPIO_PIN_SDGPIO_20,
-	PC3X3_GPIO_PIN_SDGPIO_21,
-	PC3X3_GPIO_PIN_SDGPIO_22,
-	PC3X3_GPIO_PIN_SDGPIO_23,
-};
-
-/* Prototypes--------------------------------------------------------------- */
-/**
- * Initialise the gpio library for use
- *
- * \return Returns zero on success, non-zero on failure.
- */
-int
-pc3xx_gpio_init(void);
-
-/**
- * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
- *
- * \param gpio The pin to request.
- * \return Returns zero on success, non-zero on failure.
- */
-int
-pc3xx_gpio_request(unsigned gpio);
-
-/**
- * Free a GPIO pin previously requested with gpio_request().
- *
- * \param gpio The GPIO pin to free.
- */
-void
-pc3xx_gpio_free(unsigned gpio);
-
-/**
- * Set the direction of a GPIO pin requested with gpio_request() to be an
- * input.
- *
- * \param gpio The GPIO pin to configure.
- * \return Returns zero on success, non-zero on failure.
- */
-int
-pc3xx_gpio_direction_input(unsigned gpio);
-
-/**
- * Set the direction of a GPIO pin requested with gpio_request() to be an
- * output.
- *
- * \param gpio The GPIO pin to configure.
- * \param value The initial output value for the gpio pin.
- * \return Returns zero on success, non-zero on failure.
- */
-int
-pc3xx_gpio_direction_output(unsigned gpio,
-                            int value);
-
-/**
- * Set the value of a GPIO pin.
- *
- * \param gpio The number of the pin to set the value of.
- * \param value The value to set the pin to.
- */
-void
-pc3xx_gpio_set_value(unsigned gpio,
-                     int value);
-
-/**
- * Get the value of a GPIO pin.
- *
- * \param gpio The number of the pin to get the value of.
- * \return Returns the value of the pin on success,
- * negative on failure.
- */
-int
-pc3xx_gpio_get_value(unsigned gpio);
-
-int
-pc3xx_gpio_configure_dac(unsigned gpio,
-                         u8 converter_size,
-                         u16 analogue_rate);
-
-#endif /* __MACH_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/spi.h b/arch/arm/include/asm/arch-pc3xx/spi.h
deleted file mode 100644
index 5e18879..0000000
--- a/arch/arm/include/asm/arch-pc3xx/spi.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file spi.h
-* \brief Definitions for the PC3xx SSI Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_SSI_H__
-#define __PC3XX_SSI_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-/* Functional Registers */
-
-#define SSI_CTRL_REG_0_REG_OFFSET                   (0x00)
-#define SSI_CTRL_REG_1_REG_OFFSET                   (0x04)
-#define SSI_ENABLE_REG_REG_OFFSET                   (0x08)
-#define SSI_MW_CTRL_REG_OFFSET                      (0x0C)
-#define SSI_SLAVE_ENABLE_REG_OFFSET                 (0x10)
-#define SSI_BAUD_RATE_SEL_REG_OFFSET                (0x14)
-#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            (0x18)
-#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            (0x1C)
-#define SSI_TX_FIFO_LEVEL_REG_OFFSET                (0x20)
-#define SSI_RX_FIFO_LEVEL_REG_OFFSET                (0x24)
-#define SSI_STATUS_REG_OFFSET                       (0x28)
-#define SSI_IMR_REG_OFFSET                          (0x2C)
-#define SSI_ISR_REG_OFFSET                          (0x30)
-#define SSI_RAW_ISR_REG_OFFSET                      (0x34)
-#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x38)
-#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x3C)
-#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_OFFSET    (0x40)
-#define SSI_MM_INT_CLEAR_REG_OFFSET                 (0x44)
-#define SSI_INT_CLEAR_REG_OFFSET                    (0x48)
-#define SSI_DMA_CTRL_REG_OFFSET                     (0x4C)
-#define SSI_DMA_TX_DATA_LEVEL_REG_OFFSET            (0x50)
-#define SSI_DMA_RX_DATA_LEVEL_REG_OFFSET            (0x54)
-#define SSI_DATA_REG_OFFSET                         (0x60)
-
-/* Identification Registers */
-
-#define SSI_ID_REG_OFFSET                           (0x58)
-#define SSI_COMP_VERSION_REG_OFFSET                 (0x5C)
-
-/* Types ------------------------------------------------------------------- */
-
-/* Macros ------------------------------------------------------------------ */
-#define PC302_MAX_NUMBER_SPI_CS     (4)
-#define PC302_MAX_NUMBER_SPI_BUSSES (1)
-#define PC302_MIN_SPI_CLK_DIVIDER   (2)
-#define PC302_MAX_SPI_CLK_DIVIDER   (65534)
-
-/* SSI_CTRL_REG_0_REG_OFFSET bites */
-#define PC302_SPI_LOOPBACK_MODE     (1 << 11)
-#define PC302_SPI_NORMAL_MODE       (0)
-#define PC302_SPI_TMOD_TX_RX        (0x0)
-#define PC302_SPI_TMOD_TX           (0x1 << 8)
-#define PC302_SPI_TMOD_RX           (0x2 << 8)
-#define PC302_SPI_TMOD_EEPROM_RX    (0x3 << 8)
-#define PC302_SPI_SCPOL             (1 << 7)
-#define PC302_SPI_SCPH              (1 << 6)
-#define PC302_SPI_MOTO_FORMAT       (0x0)
-#define PC302_SPI_DATA_FRM_8_BIT    (0x7)
-
-
-/* SSI_ENABLE_REG_REG_OFFSET bits */
-#define PC302_SPI_ENABLE            (1)
-#define PC302_SPI_DISABLE           (0)
-
-/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
-#define PC302_SPI_SLAVES_DISABLE    (0)
-
-/* SSI_STATUS_REG_OFFSET bits */
-#define PC302_SPI_STATUS_DCOL       (1 << 6)
-#define PC302_SPI_STATUS_TXE        (1 << 5)
-#define PC302_SPI_STATUS_RFF        (1 << 4)
-#define PC302_SPI_STATUS_RFNE       (1 << 3)
-#define PC302_SPI_STATUS_TFE        (1 << 2)
-#define PC302_SPI_STATUS_TFNF       (1 << 1)
-#define PC302_SPI_STATUS_BUSY       (1 << 0)
-
-/* SSI_IMR_REG_RESET bits */
-#define PC302_SPI_MASK_ALL_INTS     (0xFFFF)
-
-#endif /* __PC302_SSI_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/timer.h b/arch/arm/include/asm/arch-pc3xx/timer.h
deleted file mode 100644
index 5cb5094..0000000
--- a/arch/arm/include/asm/arch-pc3xx/timer.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file timer.h
-* \brief Definitions for the PC3xx Timer Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_TIMER_H__
-#define __PC3XX_TIMER_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-/* Individual definitions */
-#define TIMER1_LOAD_COUNT_REG_OFFSET        (0x00)
-#define TIMER1_CURRENT_VALUE_REG_OFFSET     (0x04)
-#define TIMER1_CONTROL_REG_OFFSET           (0x08)
-#define TIMER1_EOI_REG_OFFSET               (0x0c)
-#define TIMER1_INT_STATUS_REG_OFFSET        (0x10)
-
-#define TIMER2_LOAD_COUNT_REG_OFFSET        (0x14)
-#define TIMER2_CURRENT_VALUE_REG_OFFSET     (0x18)
-#define TIMER2_CONTROL_REG_OFFSET           (0x1c)
-#define TIMER2_EOI_REG_OFFSET               (0x20)
-#define TIMER2_INT_STATUS_REG_OFFSET        (0x24)
-
-#define TIMER3_LOAD_COUNT_REG_OFFSET        (0x28)
-#define TIMER3_CURRENT_VALUE_REG_OFFSET     (0x2c)
-#define TIMER3_CONTROL_REG_OFFSET           (0x30)
-#define TIMER3_EOI_REG_OFFSET               (0x34)
-#define TIMER3_INT_STATUS_REG_OFFSET        (0x38)
-
-#define TIMER4_LOAD_COUNT_REG_OFFSET        (0x3c)
-#define TIMER4_CURRENT_VALUE_REG_OFFSET     (0x40)
-#define TIMER4_CONTROL_REG_OFFSET           (0x44)
-#define TIMER4_EOI_REG_OFFSET               (0x48)
-#define TIMER4_INT_STATUS_REG_OFFSET        (0x4c)
-
-#define TIMERS_INT_STATUS_REG_OFFSET        (0xa0)
-#define TIMERS_EOI_REG_OFFSET               (0xa4)
-#define TIMERS_RAW_INT_STATUS_REG_OFFSET    (0xa8)
-#define TIMERS_COMP_VERSION_REG_OFFSET      (0xac)
-
-/* Macros ------------------------------------------------------------------ */
-
-/* Generic definitions 'borrowed' from U-Boot land */
-
-/* The number of timers in the hardware, numbered 0 to N-1 */
-#define TIMERNUMBEROFTIMERS                 (4)
-
-/* Register definitions for the timers */
-#define TIMERNLOADCOUNTREGOFFSET(__N)       (0x0000 + (0x14 * (__N)))
-#define TIMERNCURRENTVALUEREGOFFSET(__N)    (0x0004 + (0x14 * (__N)))
-#define TIMERNCONTROLREGOFFSET(__N)         (0x0008 + (0x14 * (__N)))
-#define TIMERNEOIREGOFFSET(__N)             (0x000c + (0x14 * (__N)))
-#define TIMERNINTERRUPTSTATUSREGOFFSET(__N) (0x0010 + (0x14 * (__N)))
-
-/* Timer N control register bit definitions */
-#define TIMERENABLE                         (0x00000001)
-#define TIMERMODE                           (0x00000002)
-#define TIMERINTERRUPTMASK                  (0x00000004)
-
-
-/* Register definitions for global timer registers */
-#define TIMERSINTERRUPTSTATUSREGOFFSET      (0x00a0)
-#define TIMERSEOIREGOFFSET                  (0x00a4)
-#define TIMERSRAWINTERRUPTSTATUSREGOFFSET   (0x00a8)
-
-/* Global Timer Registers bit definitions */
-#define TIMER(__N)                          (0x00000001 << (__N))
-
-#endif /* __PC3XX_TIMER_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/uart.h b/arch/arm/include/asm/arch-pc3xx/uart.h
deleted file mode 100644
index 2730160..0000000
--- a/arch/arm/include/asm/arch-pc3xx/uart.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file uart.h
-* \brief Definitions for the PC3xx UART Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_UART_H__
-#define __PC3XX_UART_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define UART_RX_BUFFER_REG_OFFSET               (0x00)
-#define UART_TX_HOLDING_REG_OFFSET		(0x00)
-#define UART_DIVISOR_LOW_REG_OFFSET		(0x00)
-#define UART_DIVISOR_HIGH_REG_OFFSET		(0x04)
-#define UART_INT_ENABLE_REG_OFFSET		(0x04)
-#define UART_INT_IDENTITY_REG_OFFSET		(0x08)
-#define UART_FIFO_CTRL_REG_OFFSET		(0x08)
-#define UART_LINE_CTRL_REG_OFFSET		(0x0c)
-#define UART_MODEM_CTRL_REG_OFFSET		(0x10)
-#define UART_LINE_STATUS_REG_OFFSET		(0x14)
-#define UART_MODEM_STATUS_REG_OFFSET		(0x18)
-#define UART_SCRATCH_REG_OFFSET			(0x1c)
-
-#define UART_UART_STATUS_REG_OFFSET             (0x7c)
-
-#define UART_SHADOW_RTS_REG_OFFSET		(0x8c)
-#define UART_SHADOW_BRK_CTRL_REG_OFFSET		(0x90)
-#define UART_SHADOW_DMA_MODE_REG_OFFSET		(0x94)
-#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET	(0x98)
-#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET	(0x9c)
-#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET	(0xa0)
-#define UART_HALT_TX_REG_OFFSET			(0xa4)
-#define UART_DMA_SOFT_ACK_REG_OFFSET		(0xa8)
-#define UART_COMP_PARAM_REG_OFFSET		(0xf4)
-#define UART_UART_VERSION_REG_OFFSET		(0xf8)
-#define UART_COMP_TYPE_REG_OFFSET		(0xfc)
-
-/* Macros ------------------------------------------------------------------ */
-
-/* DLL & DLH */
-#define UART_DIVISOR_MASK               (0xFF)
-
-/* IER */
-#define UART_INT_ENABLE_PTIME_IDX	(0x7)	/* Programmable THRE Interrupt Mode Enable that can be */
-						/*  written to only when THRE_MODE_USER == Enabled, */
-						/*  always readable. This is used to enable/disable the */
-						/*  generation of THRE Interrupt. */
-#define UART_INT_ENABLE_EDSSI_IDX       (0x3)   /*  R/W Enable Modem Status Interrupt. */
-#define UART_INT_ENABLE_ELSI_IDX        (0x2)   /*  R/W Enable Receiver Line Status Interrupt. */
-#define UART_INT_ENABLE_ETBEI_IDX       (0x1)   /*  R/W Enable Transmit Holding Register Empty Interrupt. */
-#define UART_INT_ENABLE_ERBFI_IDX       (0x0)   /*  R/W Enable Received Data Available Interrupt. */
-
-#define UART_INT_ENABLE_PTIME_MASK          (1 << UART_INT_ENABLE_PTIME_IDX)
-#define UART_INT_ENABLE_EDSSI_MASK          (1 << UART_INT_ENABLE_EDSSI_IDX)
-#define UART_INT_ENABLE_ELSI_MASK           (1 << UART_INT_ENABLE_ELSI_IDX)
-#define UART_INT_ENABLE_ETBEI_MASK          (1 << UART_INT_ENABLE_ETBEI_IDX)
-#define UART_INT_ENABLE_ERBFI_MASK          (1 << UART_INT_ENABLE_ERBFI_IDX)
-
-/* IIR */
-#define UART_INT_IDENTITY_MASK	            (0x0F)
-#define UART_INT_IDENTITY_MODEM_STATUS      (0x00)
-#define UART_INT_IDENTITY_NONE	            (0x01)
-#define UART_INT_IDENTITY_THR_EMPTY	    (0x02)
-#define UART_INT_IDENTITY_RX_DATA	    (0x04)
-#define UART_INT_IDENTITY_RX_LINE_STATUS    (0x06)
-#define UART_INT_IDENTITY_BUSY_DETECT       (0x07)
-#define UART_INT_IDENTITY_CHARACTER_TIMEOUT (0x0C)
-
-/* FCR */
-#define UART_FIFO_CTRL_RCVR_MASK	        (0xC0)
-#define UART_FIFO_CTRL_RCVR1_CHAR	        (0x00)  /* 00 = 1 character in the FIFO */
-#define UART_FIFO_CTRL_RCVR_QUARTER_FULL        (0x40)  /* 01 = FIFO  full */
-#define UART_FIFO_CTRL_RCVR_HALF_FULL           (0x80)  /* 10 = FIFO  full */
-#define UART_FIFO_CTRL_RCVR_2_LESS_THAN_FULL    (0xC0)  /* 11 = FIFO 2 less than full */
-
-#define UART_FIFO_CTRL_TX_EMPTY_MASK	        (0x30)
-#define UART_FIFO_CTRL_TX_EMPTY_EMPTY           (0x00)  /* 00 = FIFO empty */
-#define UART_FIFO_CTRL_TX_EMPTY_2_CHARS         (0x10)  /* 01 = 2 characters in the FIFO */
-#define UART_FIFO_CTRL_TX_EMPTY_QUARTER_FULL    (0x20)  /* 10 = FIFO  full */
-#define UART_FIFO_CTRL_TX_EMPTY_HALF_FULL       (0x30)  /* 11 = FIFO  full */
-
-#define UART_FIFO_CTRL_ENABLE		        (0x01)	/* fifo enable bit */
-
-
-/* LCR indices */
-#define UART_LINE_CTRL_DLAB_IDX                 (7)     /* Divisor latch access bit */
-#define UART_LINE_CTRL_BRK_IDX                  (6)
-#define UART_LINE_CTRL_EPS_IDX                  (4)
-#define UART_LINE_CTRL_PEN_IDX                  (3)
-#define UART_LINE_CTRL_STOP_IDX                 (2)
-#define UART_LINE_CTRL_DLS_IDX                  (0)
-
-/* LCR bit masks */
-#define UART_LINE_CTRL_DLAB_MASK	        (1 << UART_LINE_CTRL_DLAB_IDX)
-#define UART_LINE_CTRL_BRK_MASK	                (1 << UART_LINE_CTRL_BRK_IDX)
-#define UART_LINE_CTRL_EPS_MASK	                (1 << UART_LINE_CTRL_EPS_IDX)
-#define UART_LINE_CTRL_PEN_MASK	                (1 << UART_LINE_CTRL_PEN_IDX)
-#define UART_LINE_CTRL_STOP_MASK                (1 << UART_LINE_CTRL_STOP_IDX)
-#define UART_LINE_CTRL_DLS_MASK	                (3)
-#define UART_LINE_CTRL_DLS_8BITS	        (3)     /* 8 bit data length */
-#define UART_LINE_CTRL_DLS_7BITS	        (2)     /* 7 bit data length */
-#define UART_LINE_CTRL_DLS_6BITS	        (1)     /* 6 bit data length */
-#define UART_LINE_CTRL_DLS_5BITS	        (0)     /* 5 bit data length */
-
-#define UART_LINE_CTRL_1STOP_BIT                (~(UART_LINE_CTRL_STOP_MASK))
-#define UART_LINE_CTRL_PARITY_DISABLE           (~(UART_LINE_CTRL_PEN_MASK))
-
-/* MCR indices */
-#define UART_MODEM_CTRL_LOOPBACK_IDX            (4)
-#define UART_MODEM_CTRL_OUT2_IDX		(3)
-#define UART_MODEM_CTRL_OUT1_IDX		(2)
-#define UART_MODEM_CTRL_CTS_IDX		        (1)
-#define UART_MODEM_CTRL_DTR_IDX		        (0)
-
-/* MCR bit masks */
-#define UART_MODEM_CTRL_LOOPBACK_MASK	        (1 << UART_MODEM_CTRL_LOOPBACK_IDX)
-#define UART_MODEM_CTRL_OUT2_MASK		(1 << UART_MODEM_CTRL_OUT2_IDX)
-#define UART_MODEM_CTRL_OUT1_MASK		(1 << UART_MODEM_CTRL_OUT1_IDX)
-#define UART_MODEM_CTRL_CTS_MASK		(1 << UART_MODEM_CTRL_CTS_IDX)
-#define UART_MODEM_CTRL_DTR_MASK		(1 << UART_MODEM_CTRL_DTR_IDX)
-
-#define UART_MODEM_STATUS_CTS_IDX               (4)     /* CTS input */
-#define UART_MODEM_STATUS_DCTS_IDX              (0)     /* change in CTS input since last read */
-
-#define UART_LINE_STATUS_THRE_IDX	        (5)
-#define UART_LINE_STATUS_DATA_READY_IDX         (0)
-#define UART_LINE_STATUS_THRE_MASK	        (1 << UART_LINE_STATUS_THRE_IDX)
-#define UART_LINE_STATUS_DATA_READY_MASK        (1 << UART_LINE_STATUS_DATA_READY_IDX)
-
-#define UART_UART_STATUS_RFF_IDX                (4)     /* RX FIFO full */
-#define UART_UART_STATUS_RFNE_IDX	        (3)     /* RX FIFO not empty */
-#define UART_UART_STATUS_TFE_IDX	        (2)
-#define UART_UART_STATUS_TFNF_IDX	        (1)
-#define UART_UART_STATUS_BUSY_IDX	        (0)
-
-#define UART_UART_STATUS_RFF_MASK               (1 << UART_UART_STATUS_RFF_IDX)
-#define UART_UART_STATUS_RFNE_MASK              (1 << UART_UART_STATUS_RFNE_IDX)
-#define UART_UART_STATUS_TFE_MASK               (1 << UART_UART_STATUS_TFE_IDX)
-#define UART_UART_STATUS_TFNF_MASK              (1 << UART_UART_STATUS_TFNF_IDX)
-#define UART_UART_STATUS_BUSY_MASK              (1 << UART_UART_STATUS_BUSY_IDX)
-
-#endif /* __PC3XX_UART_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/utilities.h b/arch/arm/include/asm/arch-pc3xx/utilities.h
deleted file mode 100644
index f95a2a2..0000000
--- a/arch/arm/include/asm/arch-pc3xx/utilities.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file utilities.h
-* \brief Definitions for some useful PC3xx functions.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-#ifndef __PC3XX_UTILS_H__
-#define __PC3XX_UTILS_H__
-
-/* Includes ---------------------------------------------------------------- */
-#include <common.h>
-
-/* Prototypes--------------------------------------------------------------- */
-/*!
- * \brief Read a 32 bit value from a register.
- *
- * \param The address to read from
- * \return The value read
- */
-__inline unsigned int
-pc302_read_from_register (const unsigned int address);
-
-/*!
- * \brief Write a 32 bit value to a register
- *
- * \param The address to write to
- * \param The value to write.
- */
-__inline void
-pc302_write_to_register (const unsigned int address,
-                         const unsigned int value);
-
-/*!
- * \brief Read the device identification code from the axi2cfg block
- *
- * \return The value read
- */
-unsigned int
-pc302_read_device_id (void);
-
-/*!
- * \brief Read the device revision from the axi2cfg block
- *
- * \return The value read
- */
-unsigned int
-pc302_read_device_revision (void);
-
-/*!
- * \brief Read the die id number from the fuse block
- *
- * \param die_number Pointer to an array
- */
-void
-pc302_read_die_id_number (unsigned int * die_number);
-
-/*!
- * \brief Return the state of the Reduced MII enabled bit.
- *
- * \return 0 - RMII not enabled
- *         1 - RMII enabled
- */
-unsigned int
-pc302_get_rmii_enabled (void);
-
-/*!
- * \brief Read a number of 16 bit words from the PC3xx axi2cfg.
- *
- * \param caeid The CAEID of the AE to read from.
- * \param address The start address in the AE to begin reading from.
- * \param[out] data The buffer to store the data in.
- * \param count The number of 16 bit words to read.
- * \return Returns the number of words read on success, negative on failure.
- */
-int
-axi2cfg_config_read( u16 caeid,
-                     u16 address,
-                     u16 *data,
-                     u16 count );
-
-/*!
- * \brief Write a number of 16 bit words to the PC3xx axi2cfg.
- *
- * \param caeid The CAEID of the AE to write to.
- * \param address The start address in the AE to begin writing to.
- * \param[in] data The buffer to write from.
- * \param count The number of 16 bit words to write.
- * \return Returns the number of words written on success, negative on failure.
- */
-int
-axi2cfg_config_write( u16 caeid,
-                      u16 address,
-                      u16 *data,
-                      u16 count );
-
-/*!
- * \brief Read the system configuration register.
- *
- * \return Returns the value of the system configuration register.
- */
-u32
-syscfg_read(void);
-
-/*!
- * \brief Update the system configuration register.
- *
- * \param mask Mask of the bits to update.
- * \param val The value to write.
- */
-void
-syscfg_update(u32 mask,
-              u32 val);
-
-/*!
- * \brief Are we running on a PC3x3 ?
- *
- * \return 1 if running on a PC3x3 device
- *         0 if not running on a PC3x3 device
- */
-__inline int
-is_pc3x3(void);
-
-#endif /* __PC3XX_UTILS_H__ */
diff --git a/arch/arm/include/asm/arch-pc3xx/wdog.h b/arch/arm/include/asm/arch-pc3xx/wdog.h
deleted file mode 100644
index 105a903..0000000
--- a/arch/arm/include/asm/arch-pc3xx/wdog.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*****************************************************************************
- * $picoChipHeaderSubst$
- *****************************************************************************/
-
-/*!
-* \file wdog.h
-* \brief Definitions for the PC3xx WDOG Block.
-*
-* Copyright (c) 2006-2011 Picochip Ltd
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* All enquiries to support@picochip.com
-*/
-
-#ifndef __PC3XX_WDOG_H__
-#define __PC3XX_WDOG_H__
-
-/* Constants --------------------------------------------------------------- */
-
-/*****************************************************************************/
-/* Register Offset Addresses                                                 */
-/*****************************************************************************/
-
-#define WDOG_CONTROL_REG_OFFSET             (0x00)
-#define WDOG_TIMEOUT_RANGE_REG_OFFSET       (0x04)
-#define WDOG_CURRENT_COUNT_REG_OFFSET       (0x08)
-#define WDOG_COUNTER_RESTART_REG_OFFSET     (0x0c)
-#define WDOG_INT_STATUS_REG_OFFSET          (0x10)
-#define WDOG_CLEAR_REG_OFFSET               (0x14)
-
-#define WDOG_PARAMS_5_REG_OFFSET            (0xe4)
-#define WDOG_PARAMS_4_REG_OFFSET            (0xe8)
-#define WDOG_PARAMS_3_REG_OFFSET            (0xec)
-#define WDOG_PARAMS_2_REG_OFFSET            (0xf0)
-#define WDOG_PARAMS_1_REG_OFFSET            (0xf4)
-
-#define WDOG_COMP_VERSION_REG_OFFSET        (0xf8)
-#define WDOG_COMP_TYPE_REG_OFFSET           (0xfc)
-
-/*****************************************************************************/
-/* Register Bit Field Manipulation                                           */
-/*****************************************************************************/
-
-/* Kick value */
-#define WDOG_COUNTER_RESTART_KICK_VALUE	    (0x76)
-
-/* Control bits */
-#define WDOGCONTROLREGWDT_ENIDX		    (0)
-#define WDOGCONTROLREGRMODIDX		    (1)
-#define WDOGCONTROLREGRPLIDX		    (2)
-
-/* Masks */
-#define WDOGCONTROLREGWDT_ENMASK	    (1 << WDOGCONTROLREGWDT_ENIDX)
-#define WDOGCONTROLREGRMODMASK		    (1 << WDOGCONTROLREGRMODIDX)
-#define WDOGCONTROLREGRPLMASK		    (0x7 << WDOGCONTROLREGRPLIDX)
-
-#endif /* __PC3XX_WDOG_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/axi2cfg.h b/arch/arm/include/asm/arch-picoxcell/axi2cfg.h
new file mode 100644
index 0000000..5d33ac4
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/axi2cfg.h
@@ -0,0 +1,161 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file axi2cfg.h
+* \brief Definitions for the picoxcell axi2cfg block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_AXI2CFG_H__
+#define __PICOXCELL_AXI2CFG_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define AXI2CFG_SYS_CONFIG_REG_OFFSET               (0x0000)
+#define AXI2CFG_JTAG_ISC_REG_OFFSET                 (0x0004)
+#define AXI2CFG_IRQ_REG_OFFSET                      (0x0008)
+#define AXI2CFG_PURGE_CFG_PORT_REG_OFFSET           (0x000C)
+#define AXI2CFG_DMA_CFG_REG_OFFSET                  (0x0010)
+#define AXI2CFG_DEVICE_ID_REG_OFFSET                (0x0014)
+#define AXI2CFG_REVISION_ID_REG_OFFSET              (0x0018)
+#define AXI2CFG_SHD_GPIO_MUXING_REG_OFFSET          (0x0034)
+#define AXI2CFG_USE_PAI_GPIO_REG_OFFSET             (0x0038)
+#define AXI2CFG_USE_EBI_GPIO_REG_OFFSET             (0x003C)
+#define AXI2CFG_USE_DECODE_GPIO_REG_OFFSET          (0x0040)
+#define AXI2CFG_USE_MISC_INT_GPIO_REG_OFFSET        (0x0044)
+#define AXI2CFG_CLK_GATING_REG_OFFSET               (0x0048)
+#define AXI2CFG_ARM_PLL_CLK_REG_OFFSET              (0x0050)
+#define AXI2CFG_FREQ_SENSE_REG_OFFSET               (0x0054)
+#define AXI2CFG_CONFIG_WRITE_REG_OFFSET             (0x0100)
+#define AXI2CFG_CONFIG_READ_REG_OFFSET              (0x0200)
+#define AXI2CFG_DMAC1_CONFIG_REG_OFFSET             (0x0300)
+
+/*****************************************************************************/
+/* Register Bit Fields		                                             */
+/*****************************************************************************/
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_IDX               (30)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ       (8)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_HI       (23)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO       (16)
+#define AXI2CFG_SYS_CONFIG_RW_EBI_CLK_DISABLE_IDX   (15)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX         (14)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX           (13)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX         (12)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ           (4)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_HI           (11)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO           (8)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX       (7)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX         (6)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_IDX             (5)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX            (4)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX            (3)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX            (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ             (2)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_HI             (1)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_LO             (0)
+
+#define AXI2CFG_SYS_CONFIG_PA_RST_MASK              (1 << AXI2CFG_SYS_CONFIG_PA_RST_IDX)
+#define AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_MASK         (((1 << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SD_ARM_GPIO_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_EXCVEC_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_RMII_EN_MASK          (1 << AXI2CFG_SYS_CONFIG_RW_RMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REVMII_EN_MASK        (1 << AXI2CFG_SYS_CONFIG_RW_REVMII_EN_IDX)
+#define AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_MASK         (((1 << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_SZ)-1) << AXI2CFG_SYS_CONFIG_SSI_EBI_SEL_LO)
+#define AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_MASK      (1<<AXI2CFG_SYS_CONFIG_FREQ_SYNTH_MUX_IDX)
+#define AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_MASK        (1 << AXI2CFG_SYS_CONFIG_MASK_AXI_ERR_IDX)
+#define AXI2CFG_SYS_CONFIG_RW_REMAP_MASK            (1 << AXI2CFG_SYS_CONFIG_RW_REMAP_IDX)
+#define AXI2CFG_SYS_CONFIG_WDG_PAUSE_MASK           (1 << AXI2CFG_SYS_CONFIG_WDG_PAUSE_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH6_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH6_IDX)
+#define AXI2CFG_SYS_CONFIG_DMAC1_CH7_MASK           (1 << AXI2CFG_SYS_CONFIG_DMAC1_CH7_IDX)
+#define AXI2CFG_SYS_CONFIG_BOOT_MODE_MASK           (((1 << AXI2CFG_SYS_CONFIG_BOOT_MODE_SZ)-1) << AXI2CFG_SYS_CONFIG_BOOT_MODE_LO)
+
+#define AXI2CFG_DMAC1_CONFIG_WR_SZ                  (7)
+#define AXI2CFG_DMAC1_CONFIG_WR_HI                  (16)
+#define AXI2CFG_DMAC1_CONFIG_WR_LO                  (10)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_SZ           (7)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_HI           (9)
+#define AXI2CFG_DMAC1_CONFIG_WATERMARK_LO           (3)
+#define AXI2CFG_DMAC1_CONFIG_SNGL_IDX               (2)
+#define AXI2CFG_DMAC1_CONFIG_STATE_IDX              (1)
+#define AXI2CFG_DMAC1_CONFIG_ENABLE_IDX             (0)
+
+#define AXI2CFG_JTAG_ISC_REGISTER_IDX               (0)
+#define AXI2CFG_JTAG_ISC_IN_CTRL_IDX                (1)
+#define AXI2CFG_JTAG_ISC_DISABLED_IDX               (2)
+/* [31:2] - Reserved */
+
+#define AXI2CFG_PURGE_CFG_RD_PORT_IDX               (0)
+#define AXI2CFG_PURGE_CFG_WR_PORT_IDX               (1)
+#define AXI2CFG_PURGE_CFG_WR_PRGSS_PORT_IDX         (2)
+/* [31:3]   Reserved */
+
+#define AXI2CFG_DEVICE_ID_NML_302_REG_VALUE         (0x03020004)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define AXI2CFG_PA_SOFT_RESET_IDX                   (30)
+#define AXI2CFG_SHD_GPIO_7_IDX                      (23)
+#define AXI2CFG_SHD_GPIO_6_IDX                      (22)
+#define AXI2CFG_SHD_GPIO_5_IDX                      (21)
+#define AXI2CFG_SHD_GPIO_4_IDX                      (20)
+#define AXI2CFG_SHD_GPIO_3_IDX                      (19)
+#define AXI2CFG_SHD_GPIO_2_IDX                      (18)
+#define AXI2CFG_SHD_GPIO_1_IDX                      (17)
+#define AXI2CFG_SHD_GPIO_0_IDX                      (16)
+#define AXI2CFG_EBI_CLK_DISABLE_IDX                 (15)
+#define AXI2CFG_EXCEPTION_VECT_EN_IDX               (14)
+#define AXI2CFG_RMII_EN_IDX                         (13)
+#define AXI2CFG_REV_MII_EN_IDX                      (12)
+#define AXI2CFG_DECODE_MUX_3_IDX                    (11)
+#define AXI2CFG_DECODE_MUX_2_IDX                    (10)
+#define AXI2CFG_DECODE_MUX_1_IDX                    (9)
+#define AXI2CFG_DECODE_MUX_0_IDX                    (8)
+#define AXI2CFG_MASK_AXI_ERROR_IDX                  (6)
+#define AXI2CFG_REMAP_IDX                           (5)
+#define AXI2CFG_WDG_PAUSE_IDX                       (4)
+#define AXI2CFG_DMA_CHAN_6_MUX_IDX                  (3)
+#define AXI2CFG_DMA_CHAN_7_MUX_IDX                  (2)
+#define AXI2CFG_BOOT_MODE_IDX                       (0)
+
+#define AXI2CFG_PA_SOFT_RESET               (1 << AXI2CFG_PA_SOFT_RESET_IDX)
+#define AXI2CFG_SHD_GPIO_7                  (1 << AXI2CFG_SHD_GPIO_7_IDX)
+#define AXI2CFG_SHD_GPIO_6                  (1 << AXI2CFG_SHD_GPIO_6_IDX)
+#define AXI2CFG_SHD_GPIO_5                  (1 << AXI2CFG_SHD_GPIO_5_IDX)
+#define AXI2CFG_SHD_GPIO_4                  (1 << AXI2CFG_SHD_GPIO_4_IDX)
+#define AXI2CFG_SHD_GPIO_3                  (1 << AXI2CFG_SHD_GPIO_3_IDX)
+#define AXI2CFG_SHD_GPIO_2                  (1 << AXI2CFG_SHD_GPIO_2_IDX)
+#define AXI2CFG_SHD_GPIO_1                  (1 << AXI2CFG_SHD_GPIO_1_IDX)
+#define AXI2CFG_SHD_GPIO_0                  (1 << AXI2CFG_SHD_GPIO_0_IDX)
+#define AXI2CFG_EBI_CLK_DISABLE             (1 << AXI2CFG_EBI_CLK_DISABLE_IDX)
+#define AXI2CFG_EXCEPTION_VECT_EN           (1 << AXI2CFG_EXCEPTION_VECT_EN_IDX)
+#define AXI2CFG_RMII_EN                     (1 << AXI2CFG_RMII_EN_IDX)
+#define AXI2CFG_REV_MII_EN                  (1 << AXI2CFG_REV_MII_EN_IDX)
+#define AXI2CFG_DECODE_MUX_3                (1 << AXI2CFG_DECODE_MUX_3_IDX)
+#define AXI2CFG_DECODE_MUX_2                (1 << AXI2CFG_DECODE_MUX_2_IDX)
+#define AXI2CFG_DECODE_MUX_1                (1 << AXI2CFG_DECODE_MUX_1_IDX)
+#define AXI2CFG_DECODE_MUX_0                (1 << AXI2CFG_DECODE_MUX_0_IDX)
+#define AXI2CFG_MASK_AXI_ERROR              (1 << AXI2CFG_MASK_AXI_ERROR_IDX)
+#define AXI2CFG_REMAP                       (1 << AXI2CFG_REMAP_IDX)
+#define AXI2CFG_WDG_PAUSE                   (1 << AXI2CFG_WDG_PAUSE_IDX)
+#define AXI2CFG_DMA_CHAN_6_MUX              (1 << AXI2CFG_DMA_CHAN_6_MUX_IDX)
+#define AXI2CFG_DMA_CHAN_7_MUX              (1 << AXI2CFG_DMA_CHAN_7_MUX_IDX)
+#define AXI2CFG_BOOT_MODE                   (1 << AXI2CFG_BOOT_MODE_IDX)
+
+#endif /* __PICOXCELL_AXI2CFG_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/ebi.h b/arch/arm/include/asm/arch-picoxcell/ebi.h
new file mode 100644
index 0000000..9a9ee6d
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/ebi.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file ebi.h
+* \brief Definitions for the picoxcell ebi block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_EBI_H__
+#define __PICOXCELL_EBI_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define SDRAM_CON_REG_OFFSET                    (0x00)
+#define SDRAM_TIM0_REG_OFFSET                   (0x04)
+#define SDRAM_TIM1_REG_OFFSET                   (0x08)
+#define SDRAM_CTL_REG_OFFSET                    (0x0C)
+#define SDRAM_REFRESH_REG_OFFSET                (0x10)
+#define SCHIP_SEL_REGION0_LOW_REG_OFFSET        (0x14)
+#define SCHIP_SEL_REGION1_LOW_REG_OFFSET        (0x18)
+#define SCHIP_SEL_REGION2_LOW_REG_OFFSET        (0x1C)
+#define SCHIP_SEL_REGION3_LOW_REG_OFFSET        (0x20)
+#define SCHIP_SEL_REGION4_LOW_REG_OFFSET        (0x24)
+#define SCHIP_SEL_REGION5_LOW_REG_OFFSET        (0x28)
+#define SCHIP_SEL_REGION6_LOW_REG_OFFSET        (0x2C)
+#define SCHIP_SEL_REGION7_LOW_REG_OFFSET        (0x30)
+#define SCHIP_SEL_REGION0_HGH_REG_OFFSET        (0x34)
+#define SCHIP_SEL_REGION1_HGH_REG_OFFSET        (0x38)
+#define SCHIP_SEL_REGION2_HGH_REG_OFFSET        (0x3C)
+#define SCHIP_SEL_REGION3_HGH_REG_OFFSET        (0x40)
+#define SCHIP_SEL_REGION4_HGH_REG_OFFSET        (0x44)
+#define SCHIP_SEL_REGION5_HGH_REG_OFFSET        (0x48)
+#define SCHIP_SEL_REGION6_HGH_REG_OFFSET        (0x4C)
+#define SCHIP_SEL_REGION7_HGH_REG_OFFSET        (0x50)
+#define SMASK0_REG_OFFSET                       (0x54)
+#define SMASK1_REG_OFFSET                       (0x58)
+#define SMASK2_REG_OFFSET                       (0x5C)
+#define SMASK3_REG_OFFSET                       (0x60)
+#define SMASK4_REG_OFFSET                       (0x64)
+#define SMASK5_REG_OFFSET                       (0x68)
+#define SMASK6_REG_OFFSET                       (0x6C)
+#define SMASK7_REG_OFFSET                       (0x70)
+#define CHIP_SEL_ALIAS0_LOW_REG_OFFSET          (0x74)
+#define CHIP_SEL_ALIAS1_LOW_REG_OFFSET          (0x78)
+#define CHIP_SEL_ALIAS0_HGH_REG_OFFSET          (0x7C)
+#define CHIP_SEL_ALIAS1_HGH_REG_OFFSET          (0x80)
+#define CHIP_SEL_REMAP0_LOW_REG_OFFSET          (0x84)
+#define CHIP_SEL_REMAP1_LOW_REG_OFFSET          (0x88)
+#define CHIP_SEL_REMAP0_HGH_REG_OFFSET          (0x8C)
+#define CHIP_SEL_REMAP1_HGH_REG_OFFSET          (0x90)
+#define STATIC_MEM_TIMSET0_REG_OFFSET           (0x94)
+#define STATIC_MEM_TIMSET1_REG_OFFSET           (0x98)
+#define STATIC_MEM_TIMSET2_REG_OFFSET           (0x9C)
+#define FLASH_TRPDR_REG_OFFSET                  (0xA0)
+#define STATICM_EMCONTROL_REG_OFFSET            (0xA4)
+#define SYNC_FLASH_OPCODE_REG_OFFSET            (0xA8)
+#define EXTEND_MODE_REG_OFFSET                  (0xAC)
+#define SYNC_FLASH_CONFIG_REG_OFFSET            (0xB0)
+#define SYNC_FLASH_CONTROL_REG_OFFSET           (0xB4)
+#define SYNC_FLASH_TIM_REG_OFFSET               (0xB8)
+
+/* Macros ------------------------------------------------------------------ */
+
+#define SETLOWFREQDEV                           (1<<27)
+#define RESETLOWFREQDEV                         (0<<27)
+#define SETREADYMODE                            (1<<26)
+#define RESETREADYMODE                          (0<<26)
+#define SETPAGEMODE                             (1<<26)
+#define RESETPAGEMODE                           (0<<26)
+#define PAGESIZE4                               (0<<24)
+#define PAGESIZE8                               (1<<24)
+#define PAGESIZE16                              (2<<24)
+#define PAGESIZE32                              (3<<24)
+#define T_PRC_0                                 (4)
+#define T_BTA_0                                 (7)
+#define T_WP_0                                  (20<<10)
+#define T_WR_0                                  (3)
+#define T_AS_0                                  (1)
+#define T_RC_0                                  (32)
+#define T_PRC_1                                 (1)
+#define T_BTA_1                                 (1)
+#define T_WP_1                                  (2)
+#define T_WR_1                                  (1)
+#define T_AS_1                                  (1)
+#define T_RC_1                                  (4)
+#define T_PRC_2                                 (1)
+#define T_BTA_2                                 (1)
+#define T_WP_2                                  (2)
+#define T_WR_2                                  (1)
+#define T_AS_2                                  (1)
+#define T_RC_2                                  (4)
+
+#define EBI_DECODE_0                            (0)
+#define EBI_DECODE_1                            (1)
+#define EBI_DECODE_2                            (2)
+#define EBI_DECODE_3                            (3)
+
+#define EBI_SMSKR_REG_SELECT_SHIFT              (8)
+#define EBI_SMSKR_REG_SELECT_MASK               (3)
+#define EBI_REG_SELECT_TIMING_SET_0             (0)
+#define EBI_REG_SELECT_TIMING_SET_1             (1)
+#define EBI_REG_SELECT_TIMING_SET_2             (2)
+
+#define EBI_SMSKR_MEM_TYPE_SHIFT                (5)
+#define EBI_SMSKR_MEM_TYPE_MASK                 (3)
+#define EBI_MEM_TYPE_SDRAM                      (0)
+#define EBI_MEM_TYPE_SRAM                       (1)
+#define EBI_MEM_TYPE_FLASH                      (2)
+
+#define EBI_SMSKR_MEM_SIZE_SHIFT                (0)
+#define EBI_SMSKR_MEM_SIZE_MASK                 (0x1F)
+#define EBI_MEM_SIZE_NO_MEMORY                  (0x00)
+#define EBI_MEM_SIZE_64KB                       (0x01)
+#define EBI_MEM_SIZE_128KB                      (0x02)
+#define EBI_MEM_SIZE_256KB                      (0x03)
+#define EBI_MEM_SIZE_512KB                      (0x04)
+#define EBI_MEM_SIZE_1MB                        (0x05)
+#define EBI_MEM_SIZE_2MB                        (0x06)
+#define EBI_MEM_SIZE_4MB                        (0x07)
+#define EBI_MEM_SIZE_8MB                        (0x08)
+#define EBI_MEM_SIZE_16MB                       (0x09)
+#define EBI_MEM_SIZE_32MB                       (0x0A)
+#define EBI_MEM_SIZE_64MB                       (0x0B)
+#define EBI_MEM_SIZE_128MB                      (0x0C)
+#define EBI_MEM_SIZE_256MB                      (0x0D)
+#define EBI_MEM_SIZE_512MB                      (0x0E)
+#define EBI_MEM_SIZE_1GB                        (0x0F)
+#define EBI_MEM_SIZE_2GB                        (0x10)
+#define EBI_MEM_SIZE_4GB                        (0x11)
+
+#define EBI_TIMING_SET_0                        (0)
+#define EBI_TIMING_SET_1                        (1)
+#define EBI_TIMING_SET_2                        (2)
+
+#define EBI_SMTMGR_REG_READ_PIPE_SHIFT          (28)
+#define EBI_SMTMGR_REG_READ_PIPE_MASK           (3)
+
+#define EBI_SMTMGR_REG_CLK_SYNC_SHIFT           (27)
+#define EBI_SMTMGR_REG_CLK_SYNC_MASK            (1)
+
+#define EBI_SMTMGR_REG_READY_MODE_SHIFT         (26)
+#define EBI_SMTMGR_REG_READY_MODE_MASK          (1)
+
+#define EBI_SMTMGR_REG_PAGE_SIZE_SHIFT          (24)
+#define EBI_SMTMGR_REG_PAGE_SIZE_MASK           (3)
+#define EBI_PAGE_SIZE_4                         (0)
+#define EBI_PAGE_SIZE_8                         (1)
+#define EBI_PAGE_SIZE_16                        (2)
+#define EBI_PAGE_SIZE_32                        (3)
+
+#define EBI_SMTMGR_REG_PAGE_MODE_SHIFT          (23)
+#define EBI_SMTMGR_REG_PAGE_MODE_MASK           (1)
+
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_SHIFT    (19)
+#define EBI_SMTMGR_REG_PAGE_READ_CYCLE_MASK     (0xF)
+
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_SHIFT    (16)
+#define EBI_SMTMGR_REG_BUS_TURN_AROUND_MASK     (0x7)
+
+#define EBI_SMTMGR_REG_WRITE_PULSE_SHIFT        (10)
+#define EBI_SMTMGR_REG_WRITE_PULSE_MASK         (0x3F)
+
+#define EBI_SMTMGR_REG_ADDR_HOLD_SHIFT          (8)
+#define EBI_SMTMGR_REG_ADDR_HOLD_MASK           (3)
+
+#define EBI_SMTMGR_REG_ADDR_SETUP_SHIFT         (6)
+#define EBI_SMTMGR_REG_ADDR_SETUP_MASK          (3)
+
+#define EBI_SMTMGR_REG_TIMING_READ_CYCLE_MASK   (0x1F)
+
+#endif /* __PICOXCELL_EBI_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/emac.h b/arch/arm/include/asm/arch-picoxcell/emac.h
new file mode 100644
index 0000000..a441dab
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/emac.h
@@ -0,0 +1,189 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file emac.h
+* \brief Definitions for the picoxcell emac block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_EMAC_H__
+#define __PICOXCELL_EMAC_H__
+
+/* Constant-s -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define EMAC_NETWORK_CTRL_REG_OFFSET                                (0x0000)
+#define EMAC_NETWORK_CFG_REG_OFFSET                                 (0x0004)
+#define EMAC_NETWORK_STATUS_REG_OFFSET                              (0x0008)
+#define EMAC_USER_IO_REG_OFFSET                                     (0x000C)
+#define EMAC_DMA_CFG_REG_OFFSET                                     (0x0010)
+#define EMAC_TX_STATUS_REG_OFFSET                                   (0x0014)
+#define EMAC_RX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x0018)
+#define EMAC_TX_BUFF_Q_BASE_ADDR_REG_OFFSET                         (0x001C)
+#define EMAC_RX_STATUS_REG_OFFSET                                   (0x0020)
+#define EMAC_INT_STATUS_REG_OFFSET                                  (0x0024)
+#define EMAC_INT_ENABLE_REG_OFFSET                                  (0x0028)
+#define EMAC_INT_DISABLE_REG_OFFSET                                 (0x002C)
+#define EMAC_INT_MASK_REG_OFFSET                                    (0x0030)
+#define EMAC_PHY_MAINTAIN_REG_OFFSET                                (0x0034)
+#define EMAC_RX_PAUSE_QUANTUM_REG_OFFSET                            (0x0038)
+#define EMAC_TX_PAUSE_QUATNUM_REG_OFFSET                            (0x003C)
+#define EMAC_HASH_BOT_32_0_REG_OFFSET                               (0x0080)
+#define EMAC_HASH_TOP_63_32_REG_OFFSET                              (0x0084)
+#define EMAC_SPEC_ADDR_1_BOT_31_0_REG_OFFSET                        (0x0088)
+#define EMAC_SPEC_ADDR_1_TOP_47_32_REG_OFFSET                       (0x008C)
+#define EMAC_SPEC_ADDR_2_BOT_31_0_REG_OFFSET                        (0x0090)
+#define EMAC_SPEC_ADDR_2_TOP_47_32_REG_OFFSET                       (0x0094)
+#define EMAC_SPEC_ADDR_3_BOT_31_0_REG_OFFSET                        (0x0098)
+#define EMAC_SPEC_ADDR_3_TOP_47_32_REG_OFFSET                       (0x009C)
+#define EMAC_SPEC_ADDR_4_BOT_31_0_REG_OFFSET                        (0x00A0)
+#define EMAC_SPEC_ADDR_4_TOP_47_32_REG_OFFSET                       (0x00A4)
+#define EMAC_TYPE_ID_MATCH_1_REG_OFFSET                             (0x00A8)
+#define EMAC_TYPE_ID_MATCH_2_REG_OFFSET                             (0x00AC)
+#define EMAC_TYPE_ID_MATCH_3_REG_OFFSET                             (0x00B0)
+#define EMAC_TYPE_ID_MATCH_4_REG_OFFSET                             (0x00B4)
+#define EMAC_WOL_REG_OFFSET                                         (0x00B8)
+#define EMAC_IPG_STRETCH_REG_OFFSET                                 (0x00BC)
+#define EMAC_STACKED_VLAN_REG_OFFSET                                (0x00C0)
+
+#define EMAC_MODULE_ID_REG_OFFSET                                   (0x00FC)
+
+#define EMAC_OCTETS_TX_31_0_REG_OFFSET                              (0x0100)
+#define EMAC_OCTETS_TX_47_32_REG_OFFSET                             (0x0104)
+#define EMAC_FRAMES_TX_NO_ERROR_REG_OFFSET                          (0x0108)
+#define EMAC_BROADCAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x010C)
+#define EMAC_MULTICAST_FRAMES_TX_NO_ERROR_REG_OFFSET                (0x0110)
+#define EMAC_TX_PAUSE_FRAMES_REG_OFFSET                             (0x0114)
+#define EMAC_64_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET                  (0x0118)
+#define EMAC_65_127_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET              (0x011C)
+#define EMAC_128_255_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0120)
+#define EMAC_256_511_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET             (0x0124)
+#define EMAC_512_1023_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET            (0x0128)
+#define EMAC_1024_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET           (0x012C)
+#define EMAC_GREATER_THAN_1518_BYTE_FRAMES_TX_NO_ERROR_REG_OFFSET   (0x0130)
+#define EMAC_TX_UNDER_RUN_ERROR_REG_OFFSET                          (0x0134)
+#define EMAC_SINGLE_COLLISION_FRAMES_REG_OFFSET                     (0x0138)
+#define EMAC_MULTIPLE_COLLISION_FRAMES_REG_OFFSET                   (0x013C)
+#define EMAC_EXCESSIVE_COLLISIONS_REG_OFFSET                        (0x0140)
+#define EMAC_LATE_COLLISIONS_REG_OFFSET                             (0x0144)
+#define EMAC_DEFFERED_TX_FRAMES_REG_OFFSET                          (0x0148)
+#define EMAC_CARRIER_SENSE_ERRORS_REG_OFFSET                        (0x014C)
+#define EMAC_OCTETS_RX_31_0_NO_ERROR_REG_OFFSET                     (0x0150)
+#define EMAC_OCTETS_RX_47_32_NO_ERROR_REG_OFFSET                    (0x0154)
+#define EMAC_FRAMES_RX_NO_ERROR_REG_OFFSET                          (0x0158)
+#define EMAC_BROADCAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x015C)
+#define EMAC_MULTICAST_FRAMES_RX_NO_ERROR_REG_OFFSET                (0x0160)
+#define EMAC_PAUSE_FRAME_RX_REG_OFFSET                              (0x0164)
+#define EMAC_64_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET                  (0x0168)
+#define EMAC_65_127_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x016C)
+#define EMAC_128_255_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0170)
+#define EMAC_256_511_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET             (0x0174)
+#define EMAC_512_1023_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET            (0x0178)
+#define EMAC_1024_1518_BYTE_FRAMES_RX_NO_ERROR_REG_OFFSET           (0x017C)
+#define EMAC_1519_TO_MAX_FRAMES_RX_NO_ERROR_REG_OFFSET              (0x0180)
+#define EMAC_UNDERSIZE_FRAMES_RX_REG_OFFSET                         (0x0184)
+#define EMAC_OVERSIZE_FRAMES_RX_REG_OFFSET                          (0x0188)
+#define EMAC_JABBER_FRAMES_RX_REG_OFFSET                            (0x018C)
+#define EMAC_FCS_ERRORS_REG_OFFSET                                  (0x0190)
+#define EMAC_LENGTH_FIELD_FRAME_ERRORS_REG_OFFSET                   (0x0194)
+#define EMAC_RX_SYMBOL_ERRORS_REG_OFFSET                            (0x0198)
+#define EMAC_ALLIGNMENT_ERRORS_REG_OFFSET                           (0x019C)
+#define EMAC_RX_RESOURCE_ERRORS_REG_OFFSET                          (0x01A0)
+#define EMAC_RX_OVERRUN_ERRORS_REG_OFFSET                           (0x01A4)
+#define EMAC_IP_HDR_CHECKSUM_ERRORS_REG_OFFSET                      (0x01A8)
+#define EMAC_TCP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01AC)
+#define EMAC_UDP_CHECKSUM_ERRORS_REG_OFFSET                         (0x01B0)
+
+#define EMAC_1588_TIMERS_SECONDS_REG_OFFSET                         (0x01D0)
+#define EMAC_1588_TIMER_NANO_SECONDS_REG_OFFSET                     (0x01D4)
+#define EMAC_1588_TIMER_ADJUST_REG_OFFSET                           (0x01D8)
+#define EMAC_1588_TIMER_INCREMENT_REG_OFFSET                        (0x01DC)
+
+#define EMAC_PTP_EVENT_FRAME_TX_SECONDS_REG_OFFSET                  (0x01E0)
+#define EMAC_PTP_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET             (0x01E4)
+#define EMAC_PTP_EVENT_FRAME_RX_SECONDS_REG_OFFSET                  (0x01E8)
+#define EMAC_PTP_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET             (0x01EC)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_SECONDS_REG_OFFSET             (0x01F0)
+#define EMAC_PTP_PEER_EVENT_FRAME_TX_NANO_SECONDS_REG_OFFSET        (0x01F4)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_SECONDS_REG_OFFSET             (0x01F8)
+#define EMAC_PTP_PEER_EVENT_FRAME_RX_NANO_SECONDS_REG_OFFSET        (0x01FC)
+
+#define EMAC_PCS_CTRL_REG_OFFSET                                    (0x0200)
+#define EMAC_PCS_STATUS_REG_OFFSET                                  (0x0204)
+#define EMAC_PCS_UPPER_PHY_ID_REG_OFFSET                            (0x0208)
+#define EMAC_PCS_LOWER_PHY_ID_REG_OFFSET                            (0x020C)
+#define EMAC_PCS_AUTO_NEG_ADVERT_REG_OFFSET                         (0x0210)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_AB_REG_OFFSET                (0x0214)
+#define EMAC_PCS_AUTO_NEG_EXPANSION_REG_OFFSET                      (0x0218)
+#define EMAC_PCS_AUTO_NEG_NEXT_PAGE_REG_OFFSET                      (0x021C)
+#define EMAC_PCS_AUTO_NEG_LINK_PARTNER_NEXT_PAGE_REG_OFFSET         (0x0220)
+#define EMAC_PCS_EXTENDED_STATUS_REG_OFFSET                         (0x023C)
+
+/* EMAC_NETWORK_CTRL_REG_OFFSET bits */
+#define EMAC_TRANSMIT_HALT                                          (((unsigned int)1) << 10)
+#define EMAC_START_TX                                               (((unsigned int)1) << 9)
+#define EMAC_CLEAR_STATS_REGISTERS                                  (((unsigned int)1) << 5)
+#define EMAC_MDIO_ENABLE                                            (((unsigned int)1) << 4)
+#define EMAC_TX_ENABLE                                              (((unsigned int)1) << 3)
+#define EMAC_RX_ENABLE                                              (((unsigned int)1) << 2)
+
+/* EMAC_NETWORK_CFG_REG_OFFSET bits */
+#define EMAC_64_BIT_AMBA_DATA_BUS_WITDH                             (((unsigned int)1) << 21)
+#define EMAC_MDC_CLOCK_DIV_MASK                                     (0x7 << 18)
+#define EMAC_MDC_CLOCK_DIV_96                                       (0x5 << 18)
+#define EMAC_FCS_REMOVE                                             (((unsigned int)1) << 17)
+#define EMAC_LENGTH_FIELD_ERROR_FRAME_DISCARD                       (((unsigned int)1) << 16)
+#define EMAC_FULL_DUPLEX                                            (((unsigned int)1) << 1)
+#define EMAC_SPEED_100_MBPS                                         (((unsigned int)1) << 0)
+
+/* EMAC_NETWORK_STATUS_REG_OFFSET bits */
+#define EMAC_PHY_MANAGEMENT_IDLE                                    (((unsigned int)1) << 2)
+
+/* EMAC_DMA_CFG_REG_OFFSET bits */
+#define EMAC_DMA_RX_BUFFER_SIZE_IDX                                 (16)
+#define EMAC_DMA_RX_BUFFER_SIZE_MASK                                (0xFF << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+#define EMAC_DMA_RX_BUFFER_SIZE                                     (0x18 << EMAC_DMA_RX_BUFFER_SIZE_IDX)
+
+/* EMAC_PHY_MAINTAIN_REG_OFFSET bits */
+#define EMAC_PHY_ID_MASK                                            (0x1F)
+#define EMAC_PHY_ID_SHIFT                                           (23)
+#define EMAC_PHY_REG_MASK                                           (0x1F)
+#define EMAC_PHY_REG_SHIFT                                          (18)
+#define EMAC_PHY_DATA_MASK                                          (0xFFFF)
+
+/* EMAC_TX_STATUS_REG_OFFSET bits */
+#define EMAC_TRANSMIT_COMPLETE                                      (((unsigned int)1) << 5)
+#define EMAC_TRANSMIT_GO                                            (((unsigned int)1) << 3)
+
+/* Rx Descriptor Bits */
+#define EMAC_RX_DESC_WRAP                                           (((unsigned int)1) << 1)
+#define EMAC_RX_DESC_HOST_OWN                                       (((unsigned int)1) << 0)
+
+#define EMAC_RX_DESC_END_OF_FRAME                                   (((unsigned int)1) << 15)
+#define EMAC_RX_DESC_START_OF_FRAME                                 (((unsigned int)1) << 14)
+#define EMAC_RX_DESC_LENGTH_MASK                                    (0x1FFF)
+
+/* Tx Descriptor Bits */
+#define EMAC_TX_DESC_HOST_OWN                                       (((unsigned int)1) << 31)
+#define EMAC_TX_DESC_WRAP                                           (((unsigned int)1) << 30)
+#define EMAC_TX_RETRY_ERROR                                         (((unsigned int)1) << 29)
+#define EMAC_TX_UNDERRUN_ERROR                                      (((unsigned int)1) << 28)
+#define EMAC_TX_FRAME_CORRUPTION_ERROR                              (((unsigned int)1) << 27)
+#define EMAC_TX_LATE_COLLISION_ERROR                                (((unsigned int)1) << 26)
+#define EMAC_TX_NO_CRC_APPEND                                       (((unsigned int)1) << 16)
+#define EMAC_TX_LAST_BUFFER                                         (((unsigned int)1) << 15)
+#define EMAC_TX_BUFFER_LENGTH_MASK                                  (0x3FFF)
+
+#endif /* __PICOXCELL_EMAC_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/fuse.h b/arch/arm/include/asm/arch-picoxcell/fuse.h
new file mode 100644
index 0000000..f569f10
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/fuse.h
@@ -0,0 +1,76 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file fuse.h
+* \brief Definitions for the picoxcell fuse block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef __PICOXCELL_FUSE_H__
+#define __PICOXCELL_FUSE_H__
+
+/* Constants -------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define FUSE_MAP_0_REG_OFFSET           (0x00)
+#define FUSE_MAP_1_REG_OFFSET           (0x04)
+#define FUSE_MAP_2_REG_OFFSET           (0x08)
+#define FUSE_MAP_3_REG_OFFSET           (0x0C)
+
+#define FUSE_MAP_4_REG_OFFSET           (0x10)
+#define FUSE_MAP_5_REG_OFFSET           (0x14)
+#define FUSE_MAP_6_REG_OFFSET           (0x18)
+#define FUSE_MAP_7_REG_OFFSET           (0x1C)
+
+#define FUSE_MAP_8_REG_OFFSET           (0x20)
+#define FUSE_MAP_9_REG_OFFSET           (0x24)
+#define FUSE_MAP_10_REG_OFFSET          (0x28)
+#define FUSE_MAP_11_REG_OFFSET          (0x2C)
+
+#define FUSE_MAP_12_REG_OFFSET          (0x30)
+#define FUSE_MAP_13_REG_OFFSET          (0x34)
+#define FUSE_MAP_14_REG_OFFSET          (0x38)
+#define FUSE_MAP_15_REG_OFFSET          (0x3C)
+
+#define FUSE_MAP_16_REG_OFFSET          (0x40)
+#define FUSE_MAP_17_REG_OFFSET          (0x44)
+#define FUSE_MAP_18_REG_OFFSET          (0x48)
+#define FUSE_MAP_19_REG_OFFSET          (0x4C)
+
+#define FUSE_MAP_20_REG_OFFSET          (0x50)
+#define FUSE_MAP_21_REG_OFFSET          (0x54)
+#define FUSE_MAP_22_REG_OFFSET          (0x58)
+#define FUSE_MAP_23_REG_OFFSET          (0x5C)
+
+#define FUSE_MAP_24_REG_OFFSET          (0x60)
+#define FUSE_MAP_25_REG_OFFSET          (0x64)
+#define FUSE_MAP_26_REG_OFFSET          (0x68)
+#define FUSE_MAP_27_REG_OFFSET          (0x6C)
+
+#define FUSE_MAP_28_REG_OFFSET          (0x70)
+#define FUSE_MAP_29_REG_OFFSET          (0x74)
+#define FUSE_MAP_30_REG_OFFSET          (0x78)
+#define FUSE_MAP_31_REG_OFFSET          (0x7C)
+
+#define FUSE_CONTROL_REG_OFFSET         (0x80)
+#define FUSE_WRITE_BIT_ADDR_REG_OFFSET  (0x84)
+#define FUSE_WRITE_PERFORM              (0x88)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+#define FUSE_WRITE_FUSE_ENABLE          (0x66757365)
+
+#endif /*__PICOXCELL_FUSE_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/gpio.h b/arch/arm/include/asm/arch-picoxcell/gpio.h
new file mode 100644
index 0000000..73a14f3
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/gpio.h
@@ -0,0 +1,73 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file gpio.h
+* \brief Definitions for the picoxcell gpio block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_GPIO_H__
+#define __PICOXCELL_GPIO_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define GPIO_SW_PORT_A_DR_REG_OFFSET        (0x00)
+#define GPIO_SW_PORT_A_DDR_REG_OFFSET	    (0x04)
+#define GPIO_SW_PORT_A_CTL_REG_OFFSET       (0x08)
+#define GPIO_SW_PORT_B_DR_REG_OFFSET        (0x0C)
+#define GPIO_SW_PORT_B_DDR_REG_OFFSET	    (0x10)
+#define GPIO_SW_PORT_B_CTL_REG_OFFSET       (0x14)
+#define GPIO_SW_PORT_C_DR_REG_OFFSET        (0x18)
+#define GPIO_SW_PORT_C_DDR_REG_OFFSET	    (0x1C)
+#define GPIO_SW_PORT_C_CTL_REG_OFFSET       (0x20)
+#define GPIO_SW_PORT_D_DR_REG_OFFSET        (0x24)
+#define GPIO_SW_PORT_D_DDR_REG_OFFSET	    (0x28)
+#define GPIO_SW_PORT_D_CTL_REG_OFFSET       (0x2C)
+
+/* global GPIO registers */
+#define GPIO_INT_EN_REG_OFFSET              (0x30)
+#define GPIO_INT_MASK_REG_OFFSET            (0x34)
+#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	    (0x38)
+#define GPIO_INT_POLARITY_REG_OFFSET 	    (0x3c)
+
+#define GPIO_INT_STATUS_REG_OFFSET	    (0x40)
+#define GPIO_RAW_INT_STATUS_REG_OFFSET	    (0x44)
+
+/* no debounce */
+#define GPIO_PORT_A_EOI_REG_OFFSET          (0x4c)
+#define GPIO_EXT_PORT_A_REG_OFFSET          (0x50)
+#define GPIO_EXT_PORT_B_REG_OFFSET          (0x54)
+#define GPIO_EXT_PORT_C_REG_OFFSET          (0x58)
+#define GPIO_EXT_PORT_D_REG_OFFSET          (0x5C)
+
+#define GPIO_LS_SYNC_REG_OFFSET		    (0x60)
+#define GPIO_ID_CODE_REG_OFFSET		    (0x64)
+#define GPIO_RESERVED_REG_OFFSET            (0x68)
+#define GPIO_COMP_VERSION_REG_OFFSET	    (0x6c)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Useful bit definitions */
+#define GPIO_BIT_7  (0x80)
+#define GPIO_BIT_6  (0x40)
+#define GPIO_BIT_5  (0x20)
+#define GPIO_BIT_4  (0x10)
+#define GPIO_BIT_3  (0x08)
+#define GPIO_BIT_2  (0x04)
+#define GPIO_BIT_1  (0x02)
+#define GPIO_BIT_0  (0x01)
+
+#endif /* __PICOXCELL_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/mem_arm.h b/arch/arm/include/asm/arch-picoxcell/mem_arm.h
new file mode 100644
index 0000000..b4067b9
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/mem_arm.h
@@ -0,0 +1,129 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mem_arm.h
+* \brief Definitions for the picoxcell memif-arm block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_MEM_ARM_H__
+#define __PICOXCELL_MEM_ARM_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define MEMIF_ARM_INDIRECT_RW_CMD_OFFSET    (0x00 * 4)
+#define MEMIF_ARM_RSVD_0_OFFSET             (0x01 * 4)
+#define MEMIF_ARM_HPR_OFFSET                (0x02 * 4)
+#define MEMIF_ARM_LPR_OFFSET                (0x03 * 4)
+#define MEMIF_ARM_WR_OFFSET                 (0x04 * 4)
+#define MEMIF_ARM_DRAM_PARAM_0_OFFSET       (0x05 * 4)
+#define MEMIF_ARM_DRAM_PARAM_1_OFFSET       (0x06 * 4)
+#define MEMIF_ARM_DRAM_PARAM_2_OFFSET       (0x07 * 4)
+#define MEMIF_ARM_DRAM_PARAM_3_OFFSET       (0x08 * 4)
+#define MEMIF_ARM_DRAM_PARAM_4_OFFSET       (0x09 * 4)
+#define MEMIF_ARM_DRAM_INIT_PARAM_OFFSET    (0x0A * 4)
+#define MEMIF_ARM_DRAM_EMR2_EMR3_OFFSET     (0x0B * 4)
+#define MEMIF_ARM_DRAM_EMR_MR_OFFSET        (0x0C * 4)
+#define MEMIF_ARM_DRAM_BL_OFFSET            (0x0D * 4)
+#define MEMIF_ARM_DRAM_FORCE_LPR_OFFSET     (0x0E * 4)
+#define MEMIF_ARM_ADDR_MAP_0_OFFSET         (0x0F * 4)
+#define MEMIF_ARM_ADDR_MAP_1_OFFSET         (0x10 * 4)
+#define MEMIF_ARM_ADDR_MAP_2_OFFSET         (0x11 * 4)
+#define MEMIF_ARM_DRAM_ODT_OFFSET           (0x12 * 4)
+#define MEMIF_ARM_PHY_DEBUG_0_OFFSET        (0x13 * 4)
+#define MEMIF_ARM_PHY_CMD_RDC_OFFSET        (0x14 * 4)
+#define MEMIF_ARM_CTRL_MODE_OFFSET          (0x15 * 4)
+#define MEMIF_ARM_DLL_CALIB_OFFSET          (0x16 * 4)
+#define MEMIF_ARM_ODT_CTRL_OFFSET           (0x17 * 4)
+#define MEMIF_ARM_DDRC_CTRL_0_OFFSET        (0x18 * 4)
+#define MEMIF_ARM_DDRC_CTRL_1_OFFSET        (0x19 * 4)
+#define MEMIF_ARM_PHY_SLV_DLL_OFFSET        (0x1A * 4)
+#define MEMIF_ARM_PHY_DEBUG_1_OFFSET        (0x1B * 4)
+#define MEMIF_ARM_PHY_DEBUG_2_OFFSET        (0x1C * 4)
+#define MEMIF_ARM_PHY_DEBUG_3_OFFSET        (0x1D * 4)
+#define MEMIF_ARM_PHY_DEBUG_4_OFFSET        (0x1E * 4)
+#define MEMIF_ARM_PHY_LOCAL_ODT_OFFSET      (0x1F * 4)
+#define MEMIF_ARM_GP0_OFFSET                (0x20 * 4)
+#define MEMIF_ARM_GP1_OFFSET                (0x21 * 4)
+#define MEMIF_ARM_GP2_OFFSET                (0x22 * 4)
+#define MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET \
+        (MEMIF_ARM_GP2_OFFSET)
+#define MEMIF_ARM_GP3_OFFSET                (0x23 * 4)
+#define MEMIF_ARM_GP4_OFFSET                (0x24 * 4)
+
+#define MEMIF_ARM_AXI_HP_MSTR_0_OFFSET      (0x3A * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_1_OFFSET      (0x3B * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_2_OFFSET      (0x3C * 4)
+#define MEMIF_ARM_AXI_HP_MSTR_3_OFFSET      (0x3D * 4)
+#define MEMIF_ARM_AXI_START_ADDR_OFFSET     (0x3E * 4)
+#define MEMIF_ARM_AXI_END_ADDR_OFFSET       (0x3F * 4)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+/* Set up values for a single 512Mbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_512Mbx16   (0x00000F77)	/* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_512Mbx16   (0xFFF00000)	/* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_512Mbx16   (0x0FF22222)	/* row */
+
+/* Set up values for a single 1Gbx16 sdram device */
+#define MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16     (0x00000777)	/* bank */
+#define MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16     (0xFFF00000)	/* col */
+#define MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16     (0x0FF33333)	/* row */
+
+#define MEMIF_ARM_DRAM_EMR_MR_VAL           (0x00000A63)
+
+/* final wait after ddr initialisation sequence is 8 cycles */
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX     (0)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK     (0x3F)
+#define MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL     (0x8)
+
+/* pre cke assertion delay must be 200us */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX   (14)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL   (0x50)
+
+/* post cke assertion is 400ns */
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX   (22)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK   (0xFF)
+#define MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL   (0x2)
+
+/*****************************************************************************/
+/* Base Addresses                                                            */
+/*****************************************************************************/
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [1:0]  = axaddr[12:11] */
+/* row  [12:0] = axaddr[25:13] */
+#define BANK0_BASE_512Mbx16                 (0x00000000)
+#define BANK1_BASE_512Mbx16                 (0x00000800)
+#define BANK2_BASE_512Mbx16                 (0x00001000)
+#define BANK3_BASE_512Mbx16                 (0x00001800)
+
+/* col  [9:0]  = axaddr[10:1] */
+/* bank [2:0]  = axaddr[13:11] */
+/* row  [13:0] = axaddr[27:14] */
+#define BANK0_BASE_1Gbx8                    (0x00000000)
+#define BANK1_BASE_1Gbx8                    (0x00000800)
+#define BANK2_BASE_1Gbx8                    (0x00001000)
+#define BANK3_BASE_1Gbx8                    (0x00001800)
+#define BANK4_BASE_1Gbx8                    (0x00002000)
+#define BANK5_BASE_1Gbx8                    (0x00002800)
+#define BANK6_BASE_1Gbx8                    (0x00003000)
+#define BANK7_BASE_1Gbx8                    (0x00003800)
+
+#endif /* __PICOXCELL_MEM_ARM_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/mem_shd.h b/arch/arm/include/asm/arch-picoxcell/mem_shd.h
new file mode 100644
index 0000000..5b0a45b
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/mem_shd.h
@@ -0,0 +1,392 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mem_shd.h
+* \brief Definitions for the picoxcell memif-shared block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_MEM_SHD_H__
+#define __PICOXCELL_MEM_SHD_H__
+
+/* Includes ---------------------------------------------------------------- */
+#include "pa.h"
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define ADDR_PA_BUF0_SETUP                  (0x0000)
+#define ADDR_PA_BUF0_ADDR                   (0x0001)
+#define ADDR_PA_BUF1_SETUP                  (0x0002)
+#define ADDR_PA_BUF1_ADDR                   (0x0003)
+#define ADDR_PA_BUF2_SETUP                  (0x0004)
+#define ADDR_PA_BUF2_ADDR                   (0x0005)
+#define ADDR_PA_BUF3_SETUP                  (0x0006)
+#define ADDR_PA_BUF3_ADDR                   (0x0007)
+#define ADDR_PA_BUF4_SETUP                  (0x0008)
+#define ADDR_PA_BUF4_ADDR                   (0x0009)
+#define ADDR_PA_BUF5_SETUP                  (0x000A)
+#define ADDR_PA_BUF5_ADDR                   (0x000B)
+#define ADDR_PA_BUF6_SETUP                  (0x000C)
+#define ADDR_PA_BUF6_ADDR                   (0x000D)
+#define ADDR_PA_BUF7_SETUP                  (0x000E)
+#define ADDR_PA_BUF7_ADDR                   (0x000F)
+#define ADDR_PA_BUF8_SETUP                  (0x0010)
+#define ADDR_PA_BUF8_ADDR                   (0x0011)
+#define ADDR_PA_BUF9_SETUP                  (0x0012)
+#define ADDR_PA_BUF9_ADDR                   (0x0013)
+#define ADDR_SDRAM_ARB_G0_S0_S1             (0x0020)
+#define ADDR_SDRAM_ARB_G0_S2_S3             (0x0021)
+#define ADDR_SDRAM_ARB_G1_S0_S1             (0x0022)
+#define ADDR_SDRAM_ARB_G1_S2_S3             (0x0023)
+#define ADDR_SDRAM_ARB_G2_S0_S1             (0x0024)
+#define ADDR_SDRAM_ARB_G2_S2_S3             (0x0025)
+#define ADDR_SDRAM_ARB_G3_S0_S1             (0x0026)
+#define ADDR_SDRAM_ARB_G3_S2_S3             (0x0027)
+#define ADDR_SDRAM_ARB_G4_S0_S1             (0x0028)
+#define ADDR_SDRAM_ARB_G4_S2_S3             (0x0029)
+#define ADDR_SDRAM_ARB_G5_S0_S1             (0x002A)
+#define ADDR_SDRAM_ARB_G5_S2_S3             (0x002B)
+#define ADDR_SDRAM_ARB_G6_S0_S1             (0x002C)
+#define ADDR_SDRAM_ARB_G6_S2_S3             (0x002D)
+#define ADDR_SDRAM_ARB_G7_S0_S1             (0x002E)
+#define ADDR_SDRAM_ARB_G7_S2_S3             (0x002F)
+#define ADDR_SDRAM_VALID_GROUPS             (0x0030)
+#define ADDR_SRAM_ARB_S0_S1                 (0x0040)
+#define ADDR_SRAM_ARB_S2_S3                 (0x0041)
+#define ADDR_SRAM_ARB_S4_S5                 (0x0042)
+#define ADDR_SRAM_VALID_SLOTS               (0x0043)
+#define ADDR_ARB_UPDATE                     (0x004F)
+#define ADDR_SDRAM_SETUP                    (0x0050)
+#define ADDR_SDRAM_REFRESH                  (0x0051)
+#define ADDR_SDRAM_MRS                      (0x0052)
+#define ADDR_SDRAM_EMRS                     (0x0053)
+#define ADDR_SDRAM_EMRS2                    (0x0054)
+#define ADDR_SDRAM_EMRS3                    (0x0055)
+#define ADDR_SDRAM_ODT_SETUP                (0x0056)
+#define ADDR_SDRAM_CFG_DONE                 (0x0057)
+#define ADDR_SDRAM_AXI_CONFIG               (0x0058)
+#define ADDR_SDRAM_DEBUG                    (0x0059)
+#define ADDR_SDRAM_STATUS                   (0x005A)
+#define ADDR_PHY_TEST                       (0x0060)
+#define ADDR_PHY_CONFIG                     (0x0061)
+#define ADDR_PHY_LOCAL_ODT_CONFIG           (0x0062)
+#define ADDR_PHY_RDC_FIFO_RST_ERR_CNT       (0x0063)
+#define ADDR_PHY_WR_SLAVE                   (0x0064)
+#define ADDR_PHY_RD_SLAVE                   (0x0065)
+#define ADDR_PHY_DEBUG_WR_DLL0              (0x0066)
+#define ADDR_PHY_DEBUG_RC_DLL0              (0x0068)
+#define ADDR_PHY_DEBUG_RC_DLL1              (0x0069)
+#define ADDR_PHY_IO_CELL_CONFIG             (0x006A)
+#define ADDR_PHY_DEBUG_STATUS_BC            (0x0070)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_0      (0x0071)
+#define ADDR_PHY_DEBUG_STATUS_RC_DLL_1      (0x0072)
+#define ADDR_PHY_DEBUG_STATUS_MASTER_DLL_0  (0x0073)
+#define ADDR_PHY_DEBUG_STATUS_OF_IN_DELAY_0 (0x0075)
+#define ADDR_PHY_DEBUG_STATUS_OF_OUT_DELAY_0    (0x0076)
+#define ADDR_PA_FIFO_STATUS_LWR             (0x0080)
+#define ADDR_PA_FIFO_STATUS_UPR             (0x0081)
+#define ADDR_PA_ADDR_ERR_LWR                (0x0082)
+#define ADDR_PA_ADDR_ERR_UPR                (0x0083)
+#define ADDR_PA_ADDR_ERR_MASK_LWR           (0x0084)
+#define ADDR_PA_ADDR_ERR_MASK_UPR           (0x0085)
+
+#define CBFM_SLEEPREG_ADDR                  (0xA060)
+#define CBFM_RUNREG_ADDR                    (0xA061)
+#define CBFM_ERRREG_ADDR                    (0xA062)
+#define CBFM_RESETREG_ADDR                  (0xA063)
+#define CBFM_IDREG_ADDR                     (0xA064)
+#define CBFM_RSTRUNMASK_ADDR                (0xA065)
+#define CBFM_BISTEN_ADDR                    (0xA066)
+#define CBFM_BISTDATA_ADDR                  (0xA067)
+#define CBFM_TM_ADDR                        (0xA068)
+
+/*****************************************************************************/
+/* Register Values                                                           */
+/*****************************************************************************/
+
+#define DDR2_ROW_13_COL_9               (0x2)
+#define DDR2_ROW_13_COL_10              (0x1)
+#define DDR2_ROW_14_COL_10              (0x0)
+#define DDR2_8_BANKS                    (0x1)
+#define DDR2_4_BANKS                    (0x0)
+#define DDR2_BRC_ADDR                   (0x0)
+#define DDR2_RBC_ADDR                   (0x1)
+#define DDR2_RW_GAP                     (0x3)
+#define DDR2_WR_GAP                     (0xa)
+#define DDR2_CAS_4                      (0x4)
+#define DDR2_CAS_5                      (0x5)
+#define DDR2_CAS_6                      (0x6)
+#define DDR2_CAS_7                      (0x7)
+#define DDR2_REFRESH_TIME               (0x07d0)
+#define DDR2_BURST_SEQUENTIAL           (0x0000)
+#define DDR2_WR                         (0x05)
+#define DDR2_DQSN_DISABLE               (0x1)
+
+#define SDRAM_ARB_AXI_SLOT              (0)
+#define SDRAM_ARB_PA_SLOT               (1)
+#define SDRAM_ARB_DET_SLOT              (0)
+#define SDRAM_ARB_OPP_SLOT              (1)
+#define SDRAM_ARB_RD_SLOT               (0)
+#define SDRAM_ARB_WR_SLOT               (1)
+#define SDRAM_ARB_CSP_1_SLOT            (0)
+#define SDRAM_ARB_CSP_2_SLOT            (1)
+#define SDRAM_ARB_CSP_4_SLOT            (2)
+#define SDRAM_ARB_CSP_8_SLOT            (3)
+
+#define SDRAM_ARB_1_VALID_SLOT          (1)
+#define SDRAM_ARB_2_VALID_SLOT          (3)
+#define SDRAM_ARB_3_VALID_SLOT          (7)
+#define SDRAM_ARB_4_VALID_SLOT          (15)
+#define SDRAM_ARB_5_VALID_SLOT          (31)
+#define SDRAM_ARB_6_VALID_SLOT          (63)
+#define SDRAM_ARB_7_VALID_SLOT          (127)
+#define SDRAM_ARB_8_VALID_SLOT          (255)
+
+#define PHY_CONFIG_BL_4                 (2)
+#define PHY_CONFIG_BL_8                 (3)
+#define PHY_CONFIG_RDC_WE_TO_RE_2       (2)
+#define PHY_CONFIG_FIXED_RE             (1)
+
+#define ADDR_SDRAM_STATUS_INIT_DONE_BIT     (0)
+#define ADDR_SDRAM_STATUS_IN_RESET_BIT      (1)
+#define ADDR_SDRAM_STATUS_IN_STB_CLK_BIT    (2)
+#define ADDR_SDRAM_STATUS_IN_INIT_BIT       (3)
+#define ADDR_SDRAM_STATUS_IN_ARB_BIT        (4)
+#define ADDR_SDRAM_STATUS_IN_REF_BIT        (5)
+#define ADDR_SDRAM_STATUS_IN_UPDATE_BIT     (6)
+#define ADDR_SDRAM_STATUS_IN_RW_GAP_BIT     (7)
+#define ADDR_SDRAM_STATUS_IN_WR_GAP_BIT     (8)
+
+#define SDRAM_SETUP_SIZE_IDX            (0)
+#define SDRAM_SETUP_BANK_IDX            (2)
+#define SDRAM_SETUP_RW_GAP_IDX          (3)
+#define SDRAM_SETUP_WR_GAP_IDX          (7)
+#define SDRAM_SETUP_CAS_IDX             (11)
+
+#define SDRAM_AXI_SETUP_RBC_IDX         (0)
+#define SDRAM_AXI_SETUP_SIZE_IDX        (1)
+#define SDRAM_AXI_SETUP_BANK_IDX        (3)
+
+#define SDRAM_ARB_S0_AP_IDX             (0)
+#define SDRAM_ARB_S0_APOD_IDX           (1)
+#define SDRAM_ARB_S0_RW_IDX             (2)
+#define SDRAM_ARB_S0_RWOD_IDX           (3)
+#define SDRAM_ARB_S0_CSP_IDX            (4)
+
+#define SDRAM_ARB_S1_AP_IDX             (8)
+#define SDRAM_ARB_S1_APOD_IDX           (9)
+#define SDRAM_ARB_S1_RW_IDX             (10)
+#define SDRAM_ARB_S1_RWOD_IDX           (11)
+#define SDRAM_ARB_S1_CSP_IDX            (12)
+
+#define SDRAM_ARB_S2_AP_IDX             (0)
+#define SDRAM_ARB_S2_APOD_IDX           (1)
+#define SDRAM_ARB_S2_RW_IDX             (2)
+#define SDRAM_ARB_S2_RWOD_IDX           (3)
+#define SDRAM_ARB_S2_CSP_IDX            (4)
+
+#define SDRAM_ARB_S3_AP_IDX             (8)
+#define SDRAM_ARB_S3_APOD_IDX           (9)
+#define SDRAM_ARB_S3_RW_IDX             (10)
+#define SDRAM_ARB_S3_RWOD_IDX           (11)
+#define SDRAM_ARB_S3_CSP_IDX            (12)
+
+#define PHY_CONFIG_FIRST_RD_IDX         (0)
+#define PHY_CONFIG_FIRST_WR_IDX         (4)
+#define PHY_CONFIG_BL_IDX               (8)
+#define PHY_CONFIG_RDC_WE_TO_RE_IDX     (11)
+#define PHY_CONFIG_FIXED_RE_IDX         (13)
+
+#define MRS_PHY_CONFIG_BL_IDX           (0)
+#define MRS_DDR2_BURST_SEQUENTIAL_IDX   (3)
+#define MRS_DDR2_CAS_IDX                (4)
+#define MRS_DDR2_WR_IDX                 (9)
+
+#define EMRS_ODT_LOW_BIT_IDX            (2)
+#define EMRS_ODT_HIGH_BIT_IDX           (6)
+#define EMRS_DQSN_DISABLE_IDX           (10)
+
+/*****************************************************************************/
+/* Used to create a 'load file' for the pA                                   */
+/*****************************************************************************/
+
+#define LF_PA_AEID_MEMIF                (PA_AEID_MEMIF | PA_CONFIG_AEID)
+
+#define LF_CBFM_SLEEPREG_ADDR           (CBFM_SLEEPREG_ADDR | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S0_S1      (ADDR_SDRAM_ARB_G0_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G0_S2_S3      (ADDR_SDRAM_ARB_G0_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S0_S1      (ADDR_SDRAM_ARB_G1_S0_S1 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ARB_G1_S2_S3      (ADDR_SDRAM_ARB_G1_S2_S3 | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_VALID_GROUPS      (ADDR_SDRAM_VALID_GROUPS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_SETUP             (ADDR_SDRAM_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_REFRESH           (ADDR_SDRAM_REFRESH | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_ODT_SETUP         (ADDR_SDRAM_ODT_SETUP | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_AXI_CONFIG        (ADDR_SDRAM_AXI_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_MRS               (ADDR_SDRAM_MRS | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_EMRS              (ADDR_SDRAM_EMRS | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_CONFIG              (ADDR_PHY_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_LOCAL_ODT_CONFIG    (ADDR_PHY_LOCAL_ODT_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_RD_SLAVE            (ADDR_PHY_RD_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_WR_SLAVE            (ADDR_PHY_WR_SLAVE | PA_CONFIG_ADDR)
+#define LF_ADDR_PHY_IO_CELL_CONFIG      (ADDR_PHY_IO_CELL_CONFIG | PA_CONFIG_ADDR)
+#define LF_ADDR_SDRAM_CFG_DONE          (ADDR_SDRAM_CFG_DONE | PA_CONFIG_ADDR)
+
+#define ADDR_SDRAM_ARB_G0_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G0_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S0_S1_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S0_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S0_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S0_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S0_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S1_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S1_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S1_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S1_CSP_IDX))
+
+#define ADDR_SDRAM_ARB_G1_S2_S3_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S2_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S2_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S2_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S2_CSP_IDX)  | \
+                                        (SDRAM_ARB_AXI_SLOT     << SDRAM_ARB_S3_AP_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_APOD_IDX) | \
+                                        (SDRAM_ARB_RD_SLOT      << SDRAM_ARB_S3_RW_IDX)   | \
+                                        (SDRAM_ARB_OPP_SLOT     << SDRAM_ARB_S3_RWOD_IDX) | \
+                                        (SDRAM_ARB_CSP_2_SLOT   << SDRAM_ARB_S3_CSP_IDX))
+
+#define ADDR_SDRAM_VALID_GROUPS_DATA    (0x00000000 | PA_CONFIG_WRITE | SDRAM_ARB_2_VALID_SLOT)
+
+#define ADDR_SDRAM_SETUP_DATA           (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_SETUP_SIZE_IDX)     | \
+                                        (DDR2_8_BANKS       << SDRAM_SETUP_BANK_IDX)     | \
+                                        (DDR2_RW_GAP        << SDRAM_SETUP_RW_GAP_IDX)   | \
+                                        (DDR2_WR_GAP        << SDRAM_SETUP_WR_GAP_IDX)   | \
+                                        (DDR2_CAS_6         << SDRAM_SETUP_CAS_IDX))
+
+#define ADDR_SDRAM_REFRESH_DATA         (0x00000000 | PA_CONFIG_WRITE | DDR2_REFRESH_TIME)
+
+#define ADDR_SDRAM_AXI_CONFIG_DATA      (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_BRC_ADDR      << SDRAM_AXI_SETUP_RBC_IDX)   | \
+                                        (DDR2_ROW_13_COL_10 << SDRAM_AXI_SETUP_SIZE_IDX)  | \
+                                        (DDR2_8_BANKS       << SDRAM_AXI_SETUP_BANK_IDX))
+
+#define ADDR_SDRAM_MRS_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_CONFIG_BL_4        << MRS_PHY_CONFIG_BL_IDX) | \
+                                        (DDR2_BURST_SEQUENTIAL  << MRS_DDR2_BURST_SEQUENTIAL_IDX) | \
+                                        (DDR2_CAS_6             << MRS_DDR2_CAS_IDX) | \
+                                        (DDR2_WR                << MRS_DDR2_WR_IDX))
+
+#define SDRAM_ODT_75_OHM_LO             (0x1)
+#define SDRAM_ODT_75_OHM_HI             (0x0)
+
+#define ADDR_SDRAM_EMRS_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_75_OHM_LO        << EMRS_ODT_LOW_BIT_IDX) | \
+                                        (SDRAM_ODT_75_OHM_HI        << EMRS_ODT_HIGH_BIT_IDX) | \
+                                        (DDR2_DQSN_DISABLE << EMRS_DQSN_DISABLE_IDX))
+
+#define ADDR_PHY_CONFIG_DATA            (0x00000000 | PA_CONFIG_WRITE | \
+                                        (DDR2_CAS_6                 << PHY_CONFIG_FIRST_RD_IDX) | \
+                                        ((DDR2_CAS_6 - 1)           << PHY_CONFIG_FIRST_WR_IDX) | \
+                                        (PHY_CONFIG_BL_4            << PHY_CONFIG_BL_IDX)       | \
+                                        (PHY_CONFIG_RDC_WE_TO_RE_2  << PHY_CONFIG_RDC_WE_TO_RE_IDX) | \
+                                        (PHY_CONFIG_FIXED_RE        << PHY_CONFIG_FIXED_RE_IDX))
+
+#define SDRAM_ODT_ENABLE_IDX            (0)
+#define SDRAM_ODT_ON_DELAY_IDX          (1)
+#define SDRAM_ODT_ON_DURN_IDX           (4)
+#define SDRAM_ODT_ENABLE                (0x1)
+#define SDRAM_ODT_ON_DURN               (0x2)
+
+#define ADDR_SDRAM_ODT_DATA             (0x00000000 | PA_CONFIG_WRITE | \
+                                        (SDRAM_ODT_ENABLE   << SDRAM_ODT_ENABLE_IDX) | \
+                                        ((DDR2_CAS_6 - 4)   << SDRAM_ODT_ON_DELAY_IDX) | \
+                                        (SDRAM_ODT_ON_DURN  << SDRAM_ODT_ON_DURN_IDX))
+
+#define PHY_LOCAL_ODT_75_OHM            (0x1)
+#define PHY_LOCAL_ODT_OFF               (0x0)
+#define PHY_LOCAL_ODT_READ_IDX          (0)
+#define PHY_LOCAL_ODT_WRITE_IDX         (2)
+#define PHY_LOCAL_ODT_IDLE_IDX          (4)
+
+#define ADDR_PHY_LOCAL_ODT_CONFIG_DATA  (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM   << PHY_LOCAL_ODT_READ_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_WRITE_IDX) | \
+                                        (PHY_LOCAL_ODT_OFF      << PHY_LOCAL_ODT_IDLE_IDX))
+
+#define PHY_RD0_DLL_SLAVE_DELAY         (0x30)
+#define PHY_RD1_DLL_SLAVE_DELAY         (0x30)
+#define PHY_WR_DLL_SLAVE_DELAY          (0x40)
+
+#define PHY_RD0_DLL_SLAVE_IDX           (0)
+#define PHY_RD1_DLL_SLAVE_IDX           (8)
+#define PHY_WR_DLL_SLAVE_IDX            (0)
+
+#define ADDR_PHY_RD_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_RD0_DLL_SLAVE_DELAY << PHY_RD0_DLL_SLAVE_IDX) | \
+                                        (PHY_RD1_DLL_SLAVE_DELAY << PHY_RD1_DLL_SLAVE_IDX))
+
+#define ADDR_PHY_WR_SLAVE_DATA          (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_WR_DLL_SLAVE_DELAY << PHY_WR_DLL_SLAVE_IDX))
+
+#define PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX   (4)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF              (1)
+#define PHY_DATA_DRV_STRENGTH_HALF              (1)
+#define PHY_CLK_DRV_STRENGTH_HALF               (1)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF           (1)
+
+#define PHY_CTRL_DRV_STRENGTH_HALF_IDX          (0)
+#define PHY_DATA_DRV_STRENGTH_HALF_IDX          (1)
+#define PHY_CLK_DRV_STRENGTH_HALF_IDX           (2)
+#define PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX       (3)
+
+#define ADDR_PHY_IO_CELL_CONFIG_DATA    (0x00000000 | PA_CONFIG_WRITE | \
+                                        (PHY_LOCAL_ODT_75_OHM           << PHY_IO_CELL_CONFIG_FIFO_WE_IN_ODT_IDX) | \
+                                        (PHY_FIFO_WE_DRV_STRENGTH_HALF  << PHY_FIFO_WE_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CLK_DRV_STRENGTH_HALF      << PHY_CLK_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_DATA_DRV_STRENGTH_HALF     << PHY_DATA_DRV_STRENGTH_HALF_IDX) | \
+                                        (PHY_CTRL_DRV_STRENGTH_HALF     << PHY_CTRL_DRV_STRENGTH_HALF_IDX))
+
+#define ADDR_SDRAM_CFG_DONE_DATA        (0x0001 | PA_CONFIG_WRITE)
+
+#define PA_WRITE_ZERO_DATA              (PA_CONFIG_WRITE)
+
+#endif /* __PICOXCELL_MEM_SHD_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/mux.h b/arch/arm/include/asm/arch-picoxcell/mux.h
new file mode 100644
index 0000000..d3aeebe
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/mux.h
@@ -0,0 +1,47 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file mux.h
+* \brief Definitions for the picoxcell gpio muxing
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_MUX_H__
+#define __PICOXCELL_MUX_H__
+
+/* stringify used in mux.c */
+#define __stringify_1(x...)     #x
+#define __stringify(x...)       __stringify_1(x)
+
+/*
+ * Pins can typically be:
+ *	- a system function such as EBI, SSI etc,
+ *	- ARM controlled GPIO.
+ *	- picoArray controlled GPIO.
+ *	- not multiplexed at all (MUX_UNMUXED).
+ */
+enum mux_setting {
+	MUX_PERIPHERAL = (1 << 0),
+	MUX_ARM = (1 << 1),
+	MUX_SD = (1 << 2),
+	MUX_UNMUXED = (1 << 3),
+};
+
+int picoxcell_pin_set_mux (int pin_nr, enum mux_setting setting);
+
+int picoxcell_group_set_mux (const char *group_name, enum mux_setting setting);
+
+int picoxcell_get_pin_mux (int pin_nr);
+
+void picoxcell_muxing_init (void);
+
+#endif /* __PICOXCELL_MUX_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/pa.h b/arch/arm/include/asm/arch-picoxcell/pa.h
new file mode 100644
index 0000000..526f3f5
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/pa.h
@@ -0,0 +1,40 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file pa.h
+* \brief Definitions for the picoArray.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_PA_H__
+#define __PICOXCELL_PA_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/* Broadcast Id for memif-Shared */
+#define PA_BROADCAST_ID_MEMIF   (0x8020)
+
+/* The memif-Shared aeid changed from PC3x2 devices to PC3x3 devices,
+ * to avoid lots of code changes we just use the memif-Shared
+ * broadcast address instead.
+ */
+#define PA_AEID_MEMIF       (PA_BROADCAST_ID_MEMIF)
+
+#define PA_CONFIG_WRITE     (0x00010000)
+#define PA_CONFIG_READ      (0x00020000)
+#define PA_CONFIG_ADDR      (0x00040000)
+#define PA_CONFIG_AEID      (0x00080000)
+#define PA_CONFIG_VALID     (0x00010000)
+#define PA_CONFIG_FAIL      (0x00020000)
+#define PA_CONFIG_TIMEOUT   (0x00040000)
+
+#endif /* __PICOXCELL_PA_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/picoxcell.h b/arch/arm/include/asm/arch-picoxcell/picoxcell.h
new file mode 100644
index 0000000..bba63e6
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/picoxcell.h
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file picoxcell.h
+* \brief Definitions for the picoxcell ARM sub-system.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_H__
+#define __PICOXCELL_H__
+
+/*****************************************************************************/
+/* Internal Boot ROM                                                         */
+/*****************************************************************************/
+#define PICOXCELL_BOOT_ROM_BASE         (0xFFFF0000)
+
+/*****************************************************************************/
+/* AXI2PICO Buffers                                                          */
+/*****************************************************************************/
+#define PICOXCELL_AXI2PICO_BUFFERS_BASE (0xC0000000)
+
+/*****************************************************************************/
+/* Peripheral Bus                                                            */
+/*****************************************************************************/
+#define PICOXCELL_MEMIF_BASE            (0x80000000)
+#define PICOXCELL_EBI_BASE              (0x80010000)
+#define PICOXCELL_EMAC_BASE             (0x80030000)
+#define PICOXCELL_DMAC1_BASE            (0x80040000)
+#define PICOXCELL_DMAC2_BASE            (0x80050000)
+#define PICOXCELL_VIC0_BASE             (0x80060000)
+#define PICOXCELL_VIC1_BASE             (0x80064000)
+#define PICOXCELL_TZIC_BASE             (0x80068000)
+#define PICOXCELL_TZPC_BASE             (0x80070000)
+#define PICOXCELL_FUSE_BASE             (0x80080000)
+#define PICOXCELL_SSI_BASE              (0x80090000)
+#define PICOXCELL_AXI2CFG_BASE          (0x800A0000)
+#define PICOXCELL_IPSEC_BASE            (0x80100000)
+#define PICOXCELL_SRTP_BASE             (0x80140000)
+#define PICOXCELL_CIPHER_BASE           (0x80180000)
+#define PICOXCELL_RTCLK_BASE            (0x80200000)
+#define PICOXCELL_TIMER_BASE            (0x80210000)
+#define PICOXCELL_GPIO_BASE             (0x80220000)
+#define PICOXCELL_UART1_BASE            (0x80230000)
+#define PICOXCELL_UART2_BASE            (0x80240000)
+#define PICOXCELL_WDOG_BASE             (0x80250000)
+
+/*****************************************************************************/
+/* External Memory                                                           */
+/*****************************************************************************/
+#define PICOXCELL_DDRBANK_BASE          (0x00000000)
+
+#define PICOXCELL_EBI_CS0_BASE          (0x40000000)
+#define PICOXCELL_EBI_CS1_BASE          (0x48000000)
+#define PICOXCELL_EBI_CS2_BASE          (0x50000000)
+#define PICOXCELL_EBI_CS3_BASE          (0x58000000)
+
+#define PICOXCELL_FLASH_BASE            (PICOXCELL_EBI_CS0_BASE)
+
+/*****************************************************************************/
+/* Internal SRAM Memory                                                      */
+/*****************************************************************************/
+#define PICOXCELL_SRAM_BASE             (0x20000000)
+#define PICOXCELL_SRAM_SIZE             (0x00020000)
+
+/*****************************************************************************/
+/* Silicon Revision                                                          */
+/*****************************************************************************/
+#define PC3X2_REV_A                 (0)
+#define PC3X2_REV_D                 (1)
+
+/*****************************************************************************/
+/* Device Ids                                                                */
+/*****************************************************************************/
+#define PC302_DEVICE_ID             (0x03)
+#define PC312_DEVICE_ID             (0x07)
+#define PC313_DEVICE_ID             (0x20)
+#define PC323_DEVICE_ID             (0x21)
+#define PC333_DEVICE_ID             (0x22)
+
+#endif /* __PICOXCELL_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/picoxcell_gpio.h b/arch/arm/include/asm/arch-picoxcell/picoxcell_gpio.h
new file mode 100644
index 0000000..398c176
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/picoxcell_gpio.h
@@ -0,0 +1,204 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file PC302_gpio.h
+* \brief Definitions for use with the picoxcell gpio library.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_MACH_GPIO_H__
+#define __PICOXCELL_MACH_GPIO_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/* Use on PC3x2 devices */
+enum {
+	PC302_GPIO_PIN_ARM_0 = 0,	/* ARM GPIO pin identifiers. */
+	PC302_GPIO_PIN_ARM_1,
+	PC302_GPIO_PIN_ARM_2,
+	PC302_GPIO_PIN_ARM_3,
+	PC302_GPIO_PIN_ARM_4,
+	PC302_GPIO_PIN_ARM_5,
+	PC302_GPIO_PIN_ARM_6,
+	PC302_GPIO_PIN_ARM_7,
+	PC302_GPIO_PIN_SDGPIO_0,	/* SDGPIO pin identifiers. */
+	PC302_GPIO_PIN_SDGPIO_1,
+	PC302_GPIO_PIN_SDGPIO_2,
+	PC302_GPIO_PIN_SDGPIO_3,
+	PC302_GPIO_PIN_SDGPIO_4,
+	PC302_GPIO_PIN_SDGPIO_5,
+	PC302_GPIO_PIN_SDGPIO_6,
+	PC302_GPIO_PIN_SDGPIO_7,
+	PC302_GPIO_PIN_ARM_8,	/* ARM shared pins. */
+	PC302_GPIO_PIN_ARM_9,
+	PC302_GPIO_PIN_ARM_10,
+	PC302_GPIO_PIN_ARM_11,
+	PC302_GPIO_PIN_ARM_12,
+	PC302_GPIO_PIN_ARM_13,
+	PC302_GPIO_PIN_ARM_14,
+	PC302_GPIO_PIN_ARM_15,
+	PC302_GPIO_PIN_SDGPIO_8,	/* SDGPIO shared pins. */
+	PC302_GPIO_PIN_SDGPIO_9,
+	PC302_GPIO_PIN_SDGPIO_10,
+	PC302_GPIO_PIN_SDGPIO_11,
+	PC302_GPIO_PIN_SDGPIO_12,
+	PC302_GPIO_PIN_SDGPIO_13,
+	PC302_GPIO_PIN_SDGPIO_14,
+	PC302_GPIO_PIN_SDGPIO_15,
+};
+
+/* Use on PC3x3 devices */
+enum {
+	PC3X3_GPIO_PIN_ARM_0,
+	PC3X3_GPIO_PIN_ARM_1,
+	PC3X3_GPIO_PIN_ARM_2,
+	PC3X3_GPIO_PIN_ARM_3,
+	PC3X3_GPIO_PIN_ARM_4,
+	PC3X3_GPIO_PIN_ARM_5,
+	PC3X3_GPIO_PIN_ARM_6,
+	PC3X3_GPIO_PIN_ARM_7,
+	PC3X3_GPIO_PIN_ARM_8,
+	PC3X3_GPIO_PIN_ARM_9,
+	PC3X3_GPIO_PIN_ARM_10,
+	PC3X3_GPIO_PIN_ARM_11,
+	PC3X3_GPIO_PIN_ARM_12,
+	PC3X3_GPIO_PIN_ARM_13,
+	PC3X3_GPIO_PIN_ARM_14,
+	PC3X3_GPIO_PIN_ARM_15,
+	PC3X3_GPIO_PIN_ARM_16,
+	PC3X3_GPIO_PIN_ARM_17,
+	PC3X3_GPIO_PIN_ARM_18,
+	PC3X3_GPIO_PIN_ARM_19,
+	PC3X3_GPIO_PIN_ARM_20,
+	PC3X3_GPIO_PIN_ARM_21,
+	PC3X3_GPIO_PIN_ARM_22,
+	PC3X3_GPIO_PIN_ARM_23,
+	PC3X3_GPIO_PIN_ARM_24,
+	PC3X3_GPIO_PIN_ARM_25,
+	PC3X3_GPIO_PIN_ARM_26,
+	PC3X3_GPIO_PIN_ARM_27,
+	PC3X3_GPIO_PIN_ARM_28,
+	PC3X3_GPIO_PIN_ARM_29,
+	PC3X3_GPIO_PIN_ARM_30,
+	PC3X3_GPIO_PIN_ARM_31,
+	PC3X3_GPIO_PIN_ARM_32,
+	PC3X3_GPIO_PIN_ARM_33,
+	PC3X3_GPIO_PIN_ARM_34,
+	PC3X3_GPIO_PIN_ARM_35,
+	PC3X3_GPIO_PIN_ARM_36,
+	PC3X3_GPIO_PIN_ARM_37,
+	PC3X3_GPIO_PIN_ARM_38,
+	PC3X3_GPIO_PIN_ARM_39,
+	PC3X3_GPIO_PIN_ARM_40,
+	PC3X3_GPIO_PIN_ARM_41,
+	PC3X3_GPIO_PIN_ARM_42,
+	PC3X3_GPIO_PIN_ARM_43,
+	PC3X3_GPIO_PIN_ARM_44,
+	PC3X3_GPIO_PIN_ARM_45,
+	PC3X3_GPIO_PIN_ARM_46,
+	PC3X3_GPIO_PIN_ARM_47,
+	PC3X3_GPIO_PIN_ARM_48,
+	PC3X3_GPIO_PIN_ARM_49,
+	PC3X3_GPIO_PIN_ARM_50,
+	PC3X3_GPIO_PIN_ARM_51,
+	PC3X3_GPIO_PIN_ARM_52,
+	PC3X3_GPIO_PIN_ARM_53,
+	PC3X3_GPIO_PIN_SDGPIO_0,
+	PC3X3_GPIO_PIN_SDGPIO_1,
+	PC3X3_GPIO_PIN_SDGPIO_2,
+	PC3X3_GPIO_PIN_SDGPIO_3,
+	PC3X3_GPIO_PIN_SDGPIO_4,
+	PC3X3_GPIO_PIN_SDGPIO_5,
+	PC3X3_GPIO_PIN_SDGPIO_6,
+	PC3X3_GPIO_PIN_SDGPIO_7,
+	PC3X3_GPIO_PIN_SDGPIO_8,
+	PC3X3_GPIO_PIN_SDGPIO_9,
+	PC3X3_GPIO_PIN_SDGPIO_10,
+	PC3X3_GPIO_PIN_SDGPIO_11,
+	PC3X3_GPIO_PIN_SDGPIO_12,
+	PC3X3_GPIO_PIN_SDGPIO_13,
+	PC3X3_GPIO_PIN_SDGPIO_14,
+	PC3X3_GPIO_PIN_SDGPIO_15,
+	PC3X3_GPIO_PIN_SDGPIO_16,
+	PC3X3_GPIO_PIN_SDGPIO_17,
+	PC3X3_GPIO_PIN_SDGPIO_18,
+	PC3X3_GPIO_PIN_SDGPIO_19,
+	PC3X3_GPIO_PIN_SDGPIO_20,
+	PC3X3_GPIO_PIN_SDGPIO_21,
+	PC3X3_GPIO_PIN_SDGPIO_22,
+	PC3X3_GPIO_PIN_SDGPIO_23,
+};
+
+/* Prototypes--------------------------------------------------------------- */
+/**
+ * Initialise the gpio library for use
+ *
+ * \return Returns zero on success, non-zero on failure.
+ */
+int picoxcell_gpio_init (void);
+
+/**
+ * Request a new GPIO pin. This implements part of the Linux GPIO guidelines.
+ *
+ * \param gpio The pin to request.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int picoxcell_gpio_request (unsigned gpio);
+
+/**
+ * Free a GPIO pin previously requested with gpio_request().
+ *
+ * \param gpio The GPIO pin to free.
+ */
+void picoxcell_gpio_free (unsigned gpio);
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * input.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int picoxcell_gpio_direction_input (unsigned gpio);
+
+/**
+ * Set the direction of a GPIO pin requested with gpio_request() to be an
+ * output.
+ *
+ * \param gpio The GPIO pin to configure.
+ * \param value The initial output value for the gpio pin.
+ * \return Returns zero on success, non-zero on failure.
+ */
+int picoxcell_gpio_direction_output (unsigned gpio, int value);
+
+/**
+ * Set the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to set the value of.
+ * \param value The value to set the pin to.
+ */
+void picoxcell_gpio_set_value (unsigned gpio, int value);
+
+/**
+ * Get the value of a GPIO pin.
+ *
+ * \param gpio The number of the pin to get the value of.
+ * \return Returns the value of the pin on success,
+ * negative on failure.
+ */
+int picoxcell_gpio_get_value (unsigned gpio);
+
+int
+picoxcell_gpio_configure_dac (unsigned gpio,
+			      u8 converter_size, u16 analogue_rate);
+
+#endif /* __PICOXCELL_MACH_GPIO_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/spi.h b/arch/arm/include/asm/arch-picoxcell/spi.h
new file mode 100644
index 0000000..18f4afd
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/spi.h
@@ -0,0 +1,97 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file spi.h
+* \brief Definitions for the picoxcell spi block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_SPI_H__
+#define __PICOXCELL_SPI_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Functional Registers */
+
+#define SSI_CTRL_REG_0_REG_OFFSET                   (0x00)
+#define SSI_CTRL_REG_1_REG_OFFSET                   (0x04)
+#define SSI_ENABLE_REG_REG_OFFSET                   (0x08)
+#define SSI_MW_CTRL_REG_OFFSET                      (0x0C)
+#define SSI_SLAVE_ENABLE_REG_OFFSET                 (0x10)
+#define SSI_BAUD_RATE_SEL_REG_OFFSET                (0x14)
+#define SSI_TX_FIFO_THRESHOLD_REG_OFFSET            (0x18)
+#define SSI_RX_FIFO_THRESHOLD_REG_OFFSET            (0x1C)
+#define SSI_TX_FIFO_LEVEL_REG_OFFSET                (0x20)
+#define SSI_RX_FIFO_LEVEL_REG_OFFSET                (0x24)
+#define SSI_STATUS_REG_OFFSET                       (0x28)
+#define SSI_IMR_REG_OFFSET                          (0x2C)
+#define SSI_ISR_REG_OFFSET                          (0x30)
+#define SSI_RAW_ISR_REG_OFFSET                      (0x34)
+#define SSI_TX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x38)
+#define SSI_RX_FIFO_OVRFLOW_INT_CLEAR_REG_OFFSET    (0x3C)
+#define SSI_RX_FIFO_UNDFLOW_INT_CLEAR_REG_OFFSET    (0x40)
+#define SSI_MM_INT_CLEAR_REG_OFFSET                 (0x44)
+#define SSI_INT_CLEAR_REG_OFFSET                    (0x48)
+#define SSI_DMA_CTRL_REG_OFFSET                     (0x4C)
+#define SSI_DMA_TX_DATA_LEVEL_REG_OFFSET            (0x50)
+#define SSI_DMA_RX_DATA_LEVEL_REG_OFFSET            (0x54)
+#define SSI_DATA_REG_OFFSET                         (0x60)
+
+/* Identification Registers */
+
+#define SSI_ID_REG_OFFSET                           (0x58)
+#define SSI_COMP_VERSION_REG_OFFSET                 (0x5C)
+
+/* Types ------------------------------------------------------------------- */
+
+/* Macros ------------------------------------------------------------------ */
+#define PICOXCELL_MAX_NUMBER_SPI_CS     (4)
+#define PICOXCELL_MAX_NUMBER_SPI_BUSSES (1)
+#define PICOXCELL_MIN_SPI_CLK_DIVIDER   (2)
+#define PICOXCELL_MAX_SPI_CLK_DIVIDER   (65534)
+
+/* SSI_CTRL_REG_0_REG_OFFSET bites */
+#define PICOXCELL_SPI_LOOPBACK_MODE     (1 << 11)
+#define PICOXCELL_SPI_NORMAL_MODE       (0)
+#define PICOXCELL_SPI_TMOD_TX_RX        (0x0)
+#define PICOXCELL_SPI_TMOD_TX           (0x1 << 8)
+#define PICOXCELL_SPI_TMOD_RX           (0x2 << 8)
+#define PICOXCELL_SPI_TMOD_EEPROM_RX    (0x3 << 8)
+#define PICOXCELL_SPI_SCPOL             (1 << 7)
+#define PICOXCELL_SPI_SCPH              (1 << 6)
+#define PICOXCELL_SPI_MOTO_FORMAT       (0x0)
+#define PICOXCELL_SPI_DATA_FRM_8_BIT    (0x7)
+
+/* SSI_ENABLE_REG_REG_OFFSET bits */
+#define PICOXCELL_SPI_ENABLE            (1)
+#define PICOXCELL_SPI_DISABLE           (0)
+
+/* SSI_SLAVE_ENABLE_REG_OFFSET bits */
+#define PICOXCELL_SPI_SLAVES_DISABLE    (0)
+
+/* SSI_STATUS_REG_OFFSET bits */
+#define PICOXCELL_SPI_STATUS_DCOL       (1 << 6)
+#define PICOXCELL_SPI_STATUS_TXE        (1 << 5)
+#define PICOXCELL_SPI_STATUS_RFF        (1 << 4)
+#define PICOXCELL_SPI_STATUS_RFNE       (1 << 3)
+#define PICOXCELL_SPI_STATUS_TFE        (1 << 2)
+#define PICOXCELL_SPI_STATUS_TFNF       (1 << 1)
+#define PICOXCELL_SPI_STATUS_BUSY       (1 << 0)
+
+/* SSI_IMR_REG_RESET bits */
+#define PICOXCELL_SPI_MASK_ALL_INTS     (0xFFFF)
+
+#endif /* __PICOXCELL_SPI_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/timer.h b/arch/arm/include/asm/arch-picoxcell/timer.h
new file mode 100644
index 0000000..2431b2a
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/timer.h
@@ -0,0 +1,84 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file timer.h
+* \brief Definitions for the picoxcell timer block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_TIMER_H__
+#define __PICOXCELL_TIMER_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+/* Individual definitions */
+#define TIMER1_LOAD_COUNT_REG_OFFSET        (0x00)
+#define TIMER1_CURRENT_VALUE_REG_OFFSET     (0x04)
+#define TIMER1_CONTROL_REG_OFFSET           (0x08)
+#define TIMER1_EOI_REG_OFFSET               (0x0c)
+#define TIMER1_INT_STATUS_REG_OFFSET        (0x10)
+
+#define TIMER2_LOAD_COUNT_REG_OFFSET        (0x14)
+#define TIMER2_CURRENT_VALUE_REG_OFFSET     (0x18)
+#define TIMER2_CONTROL_REG_OFFSET           (0x1c)
+#define TIMER2_EOI_REG_OFFSET               (0x20)
+#define TIMER2_INT_STATUS_REG_OFFSET        (0x24)
+
+#define TIMER3_LOAD_COUNT_REG_OFFSET        (0x28)
+#define TIMER3_CURRENT_VALUE_REG_OFFSET     (0x2c)
+#define TIMER3_CONTROL_REG_OFFSET           (0x30)
+#define TIMER3_EOI_REG_OFFSET               (0x34)
+#define TIMER3_INT_STATUS_REG_OFFSET        (0x38)
+
+#define TIMER4_LOAD_COUNT_REG_OFFSET        (0x3c)
+#define TIMER4_CURRENT_VALUE_REG_OFFSET     (0x40)
+#define TIMER4_CONTROL_REG_OFFSET           (0x44)
+#define TIMER4_EOI_REG_OFFSET               (0x48)
+#define TIMER4_INT_STATUS_REG_OFFSET        (0x4c)
+
+#define TIMERS_INT_STATUS_REG_OFFSET        (0xa0)
+#define TIMERS_EOI_REG_OFFSET               (0xa4)
+#define TIMERS_RAW_INT_STATUS_REG_OFFSET    (0xa8)
+#define TIMERS_COMP_VERSION_REG_OFFSET      (0xac)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* Generic definitions 'borrowed' from U-Boot land */
+
+/* The number of timers in the hardware, numbered 0 to N-1 */
+#define TIMERNUMBEROFTIMERS                 (4)
+
+/* Register definitions for the timers */
+#define TIMERNLOADCOUNTREGOFFSET(__N)       (0x0000 + (0x14 * (__N)))
+#define TIMERNCURRENTVALUEREGOFFSET(__N)    (0x0004 + (0x14 * (__N)))
+#define TIMERNCONTROLREGOFFSET(__N)         (0x0008 + (0x14 * (__N)))
+#define TIMERNEOIREGOFFSET(__N)             (0x000c + (0x14 * (__N)))
+#define TIMERNINTERRUPTSTATUSREGOFFSET(__N) (0x0010 + (0x14 * (__N)))
+
+/* Timer N control register bit definitions */
+#define TIMERENABLE                         (0x00000001)
+#define TIMERMODE                           (0x00000002)
+#define TIMERINTERRUPTMASK                  (0x00000004)
+
+/* Register definitions for global timer registers */
+#define TIMERSINTERRUPTSTATUSREGOFFSET      (0x00a0)
+#define TIMERSEOIREGOFFSET                  (0x00a4)
+#define TIMERSRAWINTERRUPTSTATUSREGOFFSET   (0x00a8)
+
+/* Global Timer Registers bit definitions */
+#define TIMER(__N)                          (0x00000001 << (__N))
+
+#endif /* __PICOXCELL_TIMER_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/uart.h b/arch/arm/include/asm/arch-picoxcell/uart.h
new file mode 100644
index 0000000..49082fe
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/uart.h
@@ -0,0 +1,157 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file uart.h
+* \brief Definitions for the picoxcell uart block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_UART_H__
+#define __PICOXCELL_UART_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define UART_RX_BUFFER_REG_OFFSET               (0x00)
+#define UART_TX_HOLDING_REG_OFFSET		(0x00)
+#define UART_DIVISOR_LOW_REG_OFFSET		(0x00)
+#define UART_DIVISOR_HIGH_REG_OFFSET		(0x04)
+#define UART_INT_ENABLE_REG_OFFSET		(0x04)
+#define UART_INT_IDENTITY_REG_OFFSET		(0x08)
+#define UART_FIFO_CTRL_REG_OFFSET		(0x08)
+#define UART_LINE_CTRL_REG_OFFSET		(0x0c)
+#define UART_MODEM_CTRL_REG_OFFSET		(0x10)
+#define UART_LINE_STATUS_REG_OFFSET		(0x14)
+#define UART_MODEM_STATUS_REG_OFFSET		(0x18)
+#define UART_SCRATCH_REG_OFFSET			(0x1c)
+
+#define UART_UART_STATUS_REG_OFFSET             (0x7c)
+
+#define UART_SHADOW_RTS_REG_OFFSET		(0x8c)
+#define UART_SHADOW_BRK_CTRL_REG_OFFSET		(0x90)
+#define UART_SHADOW_DMA_MODE_REG_OFFSET		(0x94)
+#define UART_SHADOW_FIFO_ENABLE_REG_OFFSET	(0x98)
+#define UART_SHADOW_RCVR_TRIGGER_REG_OFFSET	(0x9c)
+#define UART_SHADOW_TX_EMPTY_TRIGGER_REG_OFFSET	(0xa0)
+#define UART_HALT_TX_REG_OFFSET			(0xa4)
+#define UART_DMA_SOFT_ACK_REG_OFFSET		(0xa8)
+#define UART_COMP_PARAM_REG_OFFSET		(0xf4)
+#define UART_UART_VERSION_REG_OFFSET		(0xf8)
+#define UART_COMP_TYPE_REG_OFFSET		(0xfc)
+
+/* Macros ------------------------------------------------------------------ */
+
+/* DLL & DLH */
+#define UART_DIVISOR_MASK               (0xFF)
+
+/* IER */
+#define UART_INT_ENABLE_PTIME_IDX	(0x7)	/* Programmable THRE Interrupt Mode Enable that can be */
+						/*  written to only when THRE_MODE_USER == Enabled, */
+						/*  always readable. This is used to enable/disable the */
+						/*  generation of THRE Interrupt. */
+#define UART_INT_ENABLE_EDSSI_IDX       (0x3)	/*  R/W Enable Modem Status Interrupt. */
+#define UART_INT_ENABLE_ELSI_IDX        (0x2)	/*  R/W Enable Receiver Line Status Interrupt. */
+#define UART_INT_ENABLE_ETBEI_IDX       (0x1)	/*  R/W Enable Transmit Holding Register Empty Interrupt. */
+#define UART_INT_ENABLE_ERBFI_IDX       (0x0)	/*  R/W Enable Received Data Available Interrupt. */
+
+#define UART_INT_ENABLE_PTIME_MASK          (1 << UART_INT_ENABLE_PTIME_IDX)
+#define UART_INT_ENABLE_EDSSI_MASK          (1 << UART_INT_ENABLE_EDSSI_IDX)
+#define UART_INT_ENABLE_ELSI_MASK           (1 << UART_INT_ENABLE_ELSI_IDX)
+#define UART_INT_ENABLE_ETBEI_MASK          (1 << UART_INT_ENABLE_ETBEI_IDX)
+#define UART_INT_ENABLE_ERBFI_MASK          (1 << UART_INT_ENABLE_ERBFI_IDX)
+
+/* IIR */
+#define UART_INT_IDENTITY_MASK	            (0x0F)
+#define UART_INT_IDENTITY_MODEM_STATUS      (0x00)
+#define UART_INT_IDENTITY_NONE	            (0x01)
+#define UART_INT_IDENTITY_THR_EMPTY	    (0x02)
+#define UART_INT_IDENTITY_RX_DATA	    (0x04)
+#define UART_INT_IDENTITY_RX_LINE_STATUS    (0x06)
+#define UART_INT_IDENTITY_BUSY_DETECT       (0x07)
+#define UART_INT_IDENTITY_CHARACTER_TIMEOUT (0x0C)
+
+/* FCR */
+#define UART_FIFO_CTRL_RCVR_MASK	        (0xC0)
+#define UART_FIFO_CTRL_RCVR1_CHAR	        (0x00)	/* 00 = 1 character in the FIFO */
+#define UART_FIFO_CTRL_RCVR_QUARTER_FULL        (0x40)	/* 01 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_HALF_FULL           (0x80)	/* 10 = FIFO  full */
+#define UART_FIFO_CTRL_RCVR_2_LESS_THAN_FULL    (0xC0)	/* 11 = FIFO 2 less than full */
+
+#define UART_FIFO_CTRL_TX_EMPTY_MASK	        (0x30)
+#define UART_FIFO_CTRL_TX_EMPTY_EMPTY           (0x00)	/* 00 = FIFO empty */
+#define UART_FIFO_CTRL_TX_EMPTY_2_CHARS         (0x10)	/* 01 = 2 characters in the FIFO */
+#define UART_FIFO_CTRL_TX_EMPTY_QUARTER_FULL    (0x20)	/* 10 = FIFO  full */
+#define UART_FIFO_CTRL_TX_EMPTY_HALF_FULL       (0x30)	/* 11 = FIFO  full */
+
+#define UART_FIFO_CTRL_ENABLE		        (0x01)	/* fifo enable bit */
+
+/* LCR indices */
+#define UART_LINE_CTRL_DLAB_IDX                 (7)	/* Divisor latch access bit */
+#define UART_LINE_CTRL_BRK_IDX                  (6)
+#define UART_LINE_CTRL_EPS_IDX                  (4)
+#define UART_LINE_CTRL_PEN_IDX                  (3)
+#define UART_LINE_CTRL_STOP_IDX                 (2)
+#define UART_LINE_CTRL_DLS_IDX                  (0)
+
+/* LCR bit masks */
+#define UART_LINE_CTRL_DLAB_MASK	        (1 << UART_LINE_CTRL_DLAB_IDX)
+#define UART_LINE_CTRL_BRK_MASK	                (1 << UART_LINE_CTRL_BRK_IDX)
+#define UART_LINE_CTRL_EPS_MASK	                (1 << UART_LINE_CTRL_EPS_IDX)
+#define UART_LINE_CTRL_PEN_MASK	                (1 << UART_LINE_CTRL_PEN_IDX)
+#define UART_LINE_CTRL_STOP_MASK                (1 << UART_LINE_CTRL_STOP_IDX)
+#define UART_LINE_CTRL_DLS_MASK	                (3)
+#define UART_LINE_CTRL_DLS_8BITS	        (3)	/* 8 bit data length */
+#define UART_LINE_CTRL_DLS_7BITS	        (2)	/* 7 bit data length */
+#define UART_LINE_CTRL_DLS_6BITS	        (1)	/* 6 bit data length */
+#define UART_LINE_CTRL_DLS_5BITS	        (0)	/* 5 bit data length */
+
+#define UART_LINE_CTRL_1STOP_BIT                (~(UART_LINE_CTRL_STOP_MASK))
+#define UART_LINE_CTRL_PARITY_DISABLE           (~(UART_LINE_CTRL_PEN_MASK))
+
+/* MCR indices */
+#define UART_MODEM_CTRL_LOOPBACK_IDX            (4)
+#define UART_MODEM_CTRL_OUT2_IDX		(3)
+#define UART_MODEM_CTRL_OUT1_IDX		(2)
+#define UART_MODEM_CTRL_CTS_IDX		        (1)
+#define UART_MODEM_CTRL_DTR_IDX		        (0)
+
+/* MCR bit masks */
+#define UART_MODEM_CTRL_LOOPBACK_MASK	        (1 << UART_MODEM_CTRL_LOOPBACK_IDX)
+#define UART_MODEM_CTRL_OUT2_MASK		(1 << UART_MODEM_CTRL_OUT2_IDX)
+#define UART_MODEM_CTRL_OUT1_MASK		(1 << UART_MODEM_CTRL_OUT1_IDX)
+#define UART_MODEM_CTRL_CTS_MASK		(1 << UART_MODEM_CTRL_CTS_IDX)
+#define UART_MODEM_CTRL_DTR_MASK		(1 << UART_MODEM_CTRL_DTR_IDX)
+
+#define UART_MODEM_STATUS_CTS_IDX               (4)	/* CTS input */
+#define UART_MODEM_STATUS_DCTS_IDX              (0)	/* change in CTS input since last read */
+
+#define UART_LINE_STATUS_THRE_IDX	        (5)
+#define UART_LINE_STATUS_DATA_READY_IDX         (0)
+#define UART_LINE_STATUS_THRE_MASK	        (1 << UART_LINE_STATUS_THRE_IDX)
+#define UART_LINE_STATUS_DATA_READY_MASK        (1 << UART_LINE_STATUS_DATA_READY_IDX)
+
+#define UART_UART_STATUS_RFF_IDX                (4)	/* RX FIFO full */
+#define UART_UART_STATUS_RFNE_IDX	        (3)	/* RX FIFO not empty */
+#define UART_UART_STATUS_TFE_IDX	        (2)
+#define UART_UART_STATUS_TFNF_IDX	        (1)
+#define UART_UART_STATUS_BUSY_IDX	        (0)
+
+#define UART_UART_STATUS_RFF_MASK               (1 << UART_UART_STATUS_RFF_IDX)
+#define UART_UART_STATUS_RFNE_MASK              (1 << UART_UART_STATUS_RFNE_IDX)
+#define UART_UART_STATUS_TFE_MASK               (1 << UART_UART_STATUS_TFE_IDX)
+#define UART_UART_STATUS_TFNF_MASK              (1 << UART_UART_STATUS_TFNF_IDX)
+#define UART_UART_STATUS_BUSY_MASK              (1 << UART_UART_STATUS_BUSY_IDX)
+
+#endif /* __PICOXCELL_UART_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/utilities.h b/arch/arm/include/asm/arch-picoxcell/utilities.h
new file mode 100644
index 0000000..16b83bd
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/utilities.h
@@ -0,0 +1,108 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file utilities.h
+* \brief Definitions for some useful functions.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+#ifndef __PICOXCELL_UTILS_H__
+#define __PICOXCELL_UTILS_H__
+
+/* Includes ---------------------------------------------------------------- */
+#include <common.h>
+
+/* Prototypes--------------------------------------------------------------- */
+/*!
+ * \brief Read a 32 bit value from a register.
+ *
+ * \param The address to read from
+ * \return The value read
+ */
+__inline unsigned int picoxcell_read_register (const unsigned int address);
+
+/*!
+ * \brief Write a 32 bit value to a register
+ *
+ * \param The value to write.
+ * \param The address to write to
+ */
+__inline void
+picoxcell_write_register (const unsigned int value, const unsigned int address);
+
+/*!
+ * \brief Read the device identification code from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int picoxcell_get_device_id (void);
+
+/*!
+ * \brief Read the device revision from the axi2cfg block
+ *
+ * \return The value read
+ */
+unsigned int picoxcell_get_revision (void);
+
+/*!
+ * \brief Return the state of the Reduced MII enabled bit.
+ *
+ * \return 0 - RMII not enabled
+ *         1 - RMII enabled
+ */
+unsigned int picoxcell_get_rmii_enabled (void);
+
+/*!
+ * \brief Read a number of 16 bit words from the PC3xx axi2cfg.
+ *
+ * \param caeid The CAEID of the AE to read from.
+ * \param address The start address in the AE to begin reading from.
+ * \param[out] data The buffer to store the data in.
+ * \param count The number of 16 bit words to read.
+ * \return Returns the number of words read on success, negative on failure.
+ */
+int axi2cfg_config_read (u16 caeid, u16 address, u16 * data, u16 count);
+
+/*!
+ * \brief Write a number of 16 bit words to the PC3xx axi2cfg.
+ *
+ * \param caeid The CAEID of the AE to write to.
+ * \param address The start address in the AE to begin writing to.
+ * \param[in] data The buffer to write from.
+ * \param count The number of 16 bit words to write.
+ * \return Returns the number of words written on success, negative on failure.
+ */
+int axi2cfg_config_write (u16 caeid, u16 address, u16 * data, u16 count);
+
+/*!
+ * \brief Read the system configuration register.
+ *
+ * \return Returns the value of the system configuration register.
+ */
+u32 syscfg_read (void);
+
+/*!
+ * \brief Update the system configuration register.
+ *
+ * \param mask Mask of the bits to update.
+ * \param val The value to write.
+ */
+void syscfg_update (u32 mask, u32 val);
+
+/*!
+ * \brief Are we running on a PC3x3 ?
+ *
+ * \return 1 if running on a PC3x3 device
+ *         0 if not running on a PC3x3 device
+ */
+__inline int is_pc3x3 (void);
+
+#endif /* __PICOXCELL_UTILS_H__ */
diff --git a/arch/arm/include/asm/arch-picoxcell/wdog.h b/arch/arm/include/asm/arch-picoxcell/wdog.h
new file mode 100644
index 0000000..a9f7a61
--- /dev/null
+++ b/arch/arm/include/asm/arch-picoxcell/wdog.h
@@ -0,0 +1,60 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*!
+* \file wdog.h
+* \brief Definitions for the picoxcell watchdog block.
+*
+* Copyright (c) 2006-2011 Picochip Ltd
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* All enquiries to support@picochip.com
+*/
+
+#ifndef __PICOXCELL_WDOG_H__
+#define __PICOXCELL_WDOG_H__
+
+/* Constants --------------------------------------------------------------- */
+
+/*****************************************************************************/
+/* Register Offset Addresses                                                 */
+/*****************************************************************************/
+
+#define WDOG_CONTROL_REG_OFFSET             (0x00)
+#define WDOG_TIMEOUT_RANGE_REG_OFFSET       (0x04)
+#define WDOG_CURRENT_COUNT_REG_OFFSET       (0x08)
+#define WDOG_COUNTER_RESTART_REG_OFFSET     (0x0c)
+#define WDOG_INT_STATUS_REG_OFFSET          (0x10)
+#define WDOG_CLEAR_REG_OFFSET               (0x14)
+
+#define WDOG_PARAMS_5_REG_OFFSET            (0xe4)
+#define WDOG_PARAMS_4_REG_OFFSET            (0xe8)
+#define WDOG_PARAMS_3_REG_OFFSET            (0xec)
+#define WDOG_PARAMS_2_REG_OFFSET            (0xf0)
+#define WDOG_PARAMS_1_REG_OFFSET            (0xf4)
+
+#define WDOG_COMP_VERSION_REG_OFFSET        (0xf8)
+#define WDOG_COMP_TYPE_REG_OFFSET           (0xfc)
+
+/*****************************************************************************/
+/* Register Bit Field Manipulation                                           */
+/*****************************************************************************/
+
+/* Kick value */
+#define WDOG_COUNTER_RESTART_KICK_VALUE	    (0x76)
+
+/* Control bits */
+#define WDOGCONTROLREGWDT_ENIDX		    (0)
+#define WDOGCONTROLREGRMODIDX		    (1)
+#define WDOGCONTROLREGRPLIDX		    (2)
+
+/* Masks */
+#define WDOGCONTROLREGWDT_ENMASK	    (1 << WDOGCONTROLREGWDT_ENIDX)
+#define WDOGCONTROLREGRMODMASK		    (1 << WDOGCONTROLREGRMODIDX)
+#define WDOGCONTROLREGRPLMASK		    (0x7 << WDOGCONTROLREGRPLIDX)
+
+#endif /* __PICOXCELL_WDOG_H___ */
diff --git a/board/picochip/pc7302/lowlevel_init.S b/board/picochip/pc7302/lowlevel_init.S
index ab2352d..733785d 100644
--- a/board/picochip/pc7302/lowlevel_init.S
+++ b/board/picochip/pc7302/lowlevel_init.S
@@ -17,7 +17,7 @@
 
 /* Includes ---------------------------------------------------------------- */
 #include <config.h>
-#include <asm/arch/pc302.h>
+#include <asm/arch/picoxcell.h>
 #include <asm/arch/mem_arm.h>
 #include <asm/arch/mem_shd.h>
 #include <asm/arch/gpio.h>
@@ -44,14 +44,14 @@
  *****************************************************************************/
 .macro  configWriteLoadFile Reg0, Reg1, Reg2, Reg3, Reg4, lfbase, lfwords
 
-        ADR     \Reg0,\lfbase
-        LDR     \Reg1,=PC302_AXI2CFG_BASE
-        LDR     \Reg2,=\lfwords
+        adr     \Reg0,\lfbase
+        ldr     \Reg1,=PICOXCELL_AXI2CFG_BASE
+        ldr     \Reg2,=\lfwords
 0:
-        LDR     \Reg3, [\Reg0],#0x4
-        STR     \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
-        SUBS    \Reg2, \Reg2, #1
-        BNE     0b
+        ldr     \Reg3, [\Reg0],#0x4
+        str     \Reg3, [\Reg1,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        subs    \Reg2, \Reg2, #1
+        bne     0b
 .endm
 
 /*****************************************************************************
@@ -61,33 +61,33 @@
  *****************************************************************************/
 .macro  configRead Reg0, Reg1, Reg2, aeid, addr
 
-        LDR     \Reg0,=PC302_AXI2CFG_BASE
+        ldr     \Reg0,=PICOXCELL_AXI2CFG_BASE
 
         /* aeid */
-        LDR     \Reg1,=\aeid
-        ORR     \Reg1,\Reg1,#PA_CONFIG_AEID
-        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        ldr     \Reg1,=\aeid
+        orr     \Reg1,\Reg1,#PA_CONFIG_AEID
+        str     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
 
         /* addr */
-        LDR     \Reg1,=\addr
-        ORR     \Reg1,\Reg1,#PA_CONFIG_ADDR
-        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        ldr     \Reg1,=\addr
+        orr     \Reg1,\Reg1,#PA_CONFIG_ADDR
+        str     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
 
         /* data */
-        MOV     \Reg1,#PA_CONFIG_READ
-        STR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
-        MOV     \Reg2,#0x20
+        mov     \Reg1,#PA_CONFIG_READ
+        str     \Reg1, [\Reg0,#AXI2CFG_CONFIG_WRITE_REG_OFFSET]
+        mov     \Reg2,#0x20
 
         /* read */
 0:
-        LDR     \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
-        TST     \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
-        BNE     1f
-        SUBS    \Reg2,\Reg2,#1
-        BNE     0b
-        MOV     \Reg1, #PA_CONFIG_TIMEOUT
+        ldr     \Reg1, [\Reg0,#AXI2CFG_CONFIG_READ_REG_OFFSET]
+        tst     \Reg1, #(PA_CONFIG_VALID | PA_CONFIG_FAIL)
+        bne     1f
+        subs    \Reg2,\Reg2,#1
+        bne     0b
+        mov     \Reg1, #PA_CONFIG_TIMEOUT
 1:
-        MOV     \Reg0, \Reg1
+        mov     \Reg0, \Reg1
 
 .endm
 
@@ -105,13 +105,13 @@
  lowlevel_init:
 
         /* Setup the Periheral Port Memory Remap Register */
-        LDR     r0, =PERIPHERAL_BUS_SETUP
-        MCR     p15, 0, r0, c15, c2, 4
+        ldr     r0, =PERIPHERAL_BUS_SETUP
+        mcr     p15, 0, r0, c15, c2, 4
 
         /* Now we need to remap the flash memory otherwsie we'll not be
          * able to talk to sdram later on.
          */
-        orr     pc, pc, #PC302_BOOTABLE_FLASH_BASE
+        orr     pc, pc, #PICOXCELL_FLASH_BASE
         nop
         nop
 
@@ -120,13 +120,13 @@
          * we return from here to the cpu_init_crit() and ultimately the
          * reset() we keep running code in the remapped address.
          */
-        orr     ip, ip, #PC302_BOOTABLE_FLASH_BASE
-        orr     lr, lr, #PC302_BOOTABLE_FLASH_BASE
+        orr     ip, ip, #PICOXCELL_FLASH_BASE
+        orr     lr, lr, #PICOXCELL_FLASH_BASE
 
         /* Perform the 'remap' in the axi2cfg block
          * This turns off the address aliasing in the hardware
          */
-        ldr     r0, =PC302_AXI2CFG_BASE
+        ldr     r0, =PICOXCELL_AXI2CFG_BASE
         ldr     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
         bic     r1, #AXI2CFG_SYS_CONFIG_RW_REMAP_MASK
         str     r1, [r0, #AXI2CFG_SYS_CONFIG_REG_OFFSET]
@@ -164,16 +164,16 @@
  * Example:
  *
  *  is_pc3x2	r0
- *  LDREQ	r0, =PC3X2_VALUE
- *  LDRNE	r0, =PC3X3_VALUE
+ *  ldreq       r0, =PC3X2_VALUE
+ *  ldrne       r0, =PC3X3_VALUE
  *
  *****************************************************************************/
 .macro	is_pc3x2, tmp
-	LDR	\tmp, =PC302_AXI2CFG_BASE
-	ORR	\tmp, \tmp, #AXI2CFG_DEVICE_ID_REG_OFFSET
-	LDR	\tmp, [\tmp]	@ Get the device ID.
+	ldr     \tmp, =PICOXCELL_AXI2CFG_BASE
+	orr     \tmp, \tmp, #AXI2CFG_DEVICE_ID_REG_OFFSET
+	ldr     \tmp, [\tmp]    @ Get the device ID.
 
-	ANDS	\tmp, \tmp, #0x0020
+	ands    \tmp, \tmp, #0x0020
 .endm
 
 /*****************************************************************************
@@ -185,110 +185,110 @@
  *****************************************************************************/
 memif_arm_init:
 
-        LDR     r3, =PC302_MEMIF_BASE
+        ldr     r3, =PICOXCELL_MEMIF_BASE
 
         /* ;; =MEMIF_ARM_DRAM_INIT_PARAM_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
-        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
-        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
-        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
-        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
-        BIC     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
-        ORR     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
-        STR     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
+        bic     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_MSK << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        orr     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_VAL << MEMIF_ARM_DRAM_INIT_PARAM_FWAIT_IDX)
+        bic     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        orr     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PRE_CKE_IDX)
+        bic     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_MSK << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        orr     r4, r4, #(MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_VAL << MEMIF_ARM_DRAM_INIT_PARAM_PST_CKE_IDX)
+        str     r4, [r3, #MEMIF_ARM_DRAM_INIT_PARAM_OFFSET]
 
         /* ;; =MEMIF_ARM_ADDR_MAP_0_OFFSET */
-        LDR     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16
-        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
+        ldr     r4, =MEMIF_ARM_ADDR_MAP_0_VAL_1Gbx16
+        str     r4, [r3, #MEMIF_ARM_ADDR_MAP_0_OFFSET]
 
         /* ;; =MEMIF_ARM_ADDR_MAP_1_OFFSET */
-        LDR     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16
-        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
+        ldr     r4, =MEMIF_ARM_ADDR_MAP_1_VAL_1Gbx16
+        str     r4, [r3, #MEMIF_ARM_ADDR_MAP_1_OFFSET]
 
         /* ;; =MEMIF_ARM_ADDR_MAP_2_OFFSET */
-        LDR     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16
-        STR     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
+        ldr     r4, =MEMIF_ARM_ADDR_MAP_2_VAL_1Gbx16
+        str     r4, [r3, #MEMIF_ARM_ADDR_MAP_2_OFFSET]
 
         /* ;; =MEMIF_ARM_DRAM_PARAM_2_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
-        AND     r4, r4, #0xFFFFFFF0
-        ORR     r4, r4, #0x00000004 ; wl = cl - 2
-        STR     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
+        and     r4, r4, #0xFFFFFFF0
+        orr     r4, r4, #0x00000004 ; wl = cl - 2
+        str     r4, [r3, #MEMIF_ARM_DRAM_PARAM_2_OFFSET]
 
         /* ;; =MEMIF_ARM_DRAM_BL_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
-        BIC     r4, r4, #0x00000001 //; bl = 4
-        STR     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
+        bic     r4, r4, #0x00000001 //; bl = 4
+        str     r4, [r3, #MEMIF_ARM_DRAM_BL_OFFSET]
 
         /* ;;  =MEMIF_ARM_DRAM_EMR_MR_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
-        AND     r4, r4, #0xFFFFFF88
-        ORR     r4, r4, #0x00000002 //; bl = 4
-        ORR     r4, r4, #0x00000060 //; cl = 6
-        ORR     r4, r4, #0x04000000 //; dqs# = 0
-        STR     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
+        and     r4, r4, #0xFFFFFF88
+        orr     r4, r4, #0x00000002 //; bl = 4
+        orr     r4, r4, #0x00000060 //; cl = 6
+        orr     r4, r4, #0x04000000 //; dqs# = 0
+        str     r4, [r3, #MEMIF_ARM_DRAM_EMR_MR_OFFSET]
 
         /* ;;  =MEMIF_ARM_PHY_CMD_RDC_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
-        AND     r4, r4, #0xFFFFFF00
-        ORR     r4, r4, #0x00000050 //;  phy wl
-        ORR     r4, r4, #0x00000006 //;  phy rl
-        AND     r4, r4, #0xFFFFFCFF
-        ORR     r4, r4, #0x00000300 //;  rdc_we_to_re_delay = 3 clks
-        AND     r4, r4, #0xFFFEFFFF
-        ORR     r4, r4, #0x00010000 //;  use_fixed_re = 1
-        STR     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
+        and     r4, r4, #0xFFFFFF00
+        orr     r4, r4, #0x00000050 //;  phy wl
+        orr     r4, r4, #0x00000006 //;  phy rl
+        and     r4, r4, #0xFFFFFCFF
+        orr     r4, r4, #0x00000300 //;  rdc_we_to_re_delay = 3 clks
+        and     r4, r4, #0xFFFEFFFF
+        orr     r4, r4, #0x00010000 //;  use_fixed_re = 1
+        str     r4, [r3, #MEMIF_ARM_PHY_CMD_RDC_OFFSET]
 
         /* ;; =MEMIF_ARM_PHY_SLV_DLL_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
-        AND     r4, r4, #0x0
-        ORR     r4, r4, #0x30000000 //;  dll rd_slave1 ratio
-        ORR     r4, r4, #0x00300000 //;  dll rd_slave0 ratio
+        ldr     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+        and     r4, r4, #0x0
+        orr     r4, r4, #0x30000000 //;  dll rd_slave1 ratio
+        orr     r4, r4, #0x00300000 //;  dll rd_slave0 ratio
 	is_pc3x2    r0
-        ORRNE   r4, r4, #0x00000050 //;  dll wr_slave ratio for PC3X3
-	ORREQ	r4, r4, #0x00000040 //;  dll wr_slave ratio for PC3X2
-        STR     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
+        orrne   r4, r4, #0x00000050 //;  dll wr_slave ratio for PC3X3
+	orreq   r4, r4, #0x00000040 //;  dll wr_slave ratio for PC3X2
+        str     r4, [r3, #MEMIF_ARM_PHY_SLV_DLL_OFFSET]
 
         /* ;; =MEMIF_ARM_DRAM_ODT_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_DRAM_ODT_OFFSET]
-        BIC     r4, r4, #0x00000001 //; disable dram odt during reads
-        STR     r4, [r3,#MEMIF_ARM_DRAM_ODT_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_DRAM_ODT_OFFSET]
+        bic     r4, r4, #0x00000001 //; disable dram odt during reads
+        str     r4, [r3,#MEMIF_ARM_DRAM_ODT_OFFSET]
 
         /* ;; =MEMIF_ARM_ODT_CTRL_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
-        AND     r4, r4, #0xFFFFFF00
-        AND     r4, r4, #0xFFFF00FF
-        ORR     r4, r4, #0x0010 //; wr_odt_delay, cl-5
-        ORR     r4, r4, #0x3000 //; wr_odt_hold, 4 cycles required
-        STR     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
+        and     r4, r4, #0xFFFFFF00
+        and     r4, r4, #0xFFFF00FF
+        orr     r4, r4, #0x0010 //; wr_odt_delay, cl-5
+        orr     r4, r4, #0x3000 //; wr_odt_hold, 4 cycles required
+        str     r4, [r3, #MEMIF_ARM_ODT_CTRL_OFFSET]
 
         /* ;; =MEMIF_ARM_PHY_LOCAL_ODT_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
-        AND     r4, r4, #0xFFFFFFC0
-        ORR     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
+        ldr     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        and     r4, r4, #0xFFFFFFC0
+        orr     r4, r4, #0x0001 //; rd_local_odt = 75 ohm
                                 //; wr_local_odt = off
                                 //; idle_local_odt = off
-        STR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
+        str     r4, [r3, #MEMIF_ARM_PHY_LOCAL_ODT_OFFSET]
 
         /* ;; =MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET]
-        ORR     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
-        ORR     r4, r4, #0x000F //; All control signals half drive strength
-        STR     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_PHY_LOCAL_DRV_STRENGTH_OFFSET]
+        orr     r4, r4, #0x0010 //; fifo_we_in odt = 75 ohm
+        orr     r4, r4, #0x000F //; All control signals half drive strength
+        str     r4, [r3, #MEMIF_ARM_GP2_OFFSET]
 
         /* ;; =MEMIF_ARM_INDIRECT_RW_CMD_OFFSET */
-        LDR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
-        ORR     r4, r4, #0x1  //; de-assert soft reset
-        STR     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        ldr     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
+        orr     r4, r4, #0x1  //; de-assert soft reset
+        str     r4, [r3, #MEMIF_ARM_INDIRECT_RW_CMD_OFFSET]
 
 /* Check to see if the mem-if ARM is ready yet? */
 memif_arm_init_poll:
-        LDR     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
-        AND     r4, r4, #0x3
-        CMP     r4, #0x1
-        BNE     memif_arm_init_poll
+        ldr     r4, [r3, #MEMIF_ARM_CTRL_MODE_OFFSET]
+        and     r4, r4, #0x3
+        cmp     r4, #0x1
+        bne     memif_arm_init_poll
 
-        mov	pc, lr		/* Return to my caller */
+        mov     pc, lr          /* Return to my caller */
 
 /*****************************************************************************
  *
@@ -331,46 +331,12 @@ memif_shared_init_poll:
         configRead r0, r1, r2, PA_AEID_MEMIF, ADDR_SDRAM_STATUS
 
         /* Has it timed out? */
-        TST     r0, #PA_CONFIG_TIMEOUT
-        BNE     memif_shared_init_poll
+        tst     r0, #PA_CONFIG_TIMEOUT
+        bne     memif_shared_init_poll
 
         /* Has it configured? */
-        TST     r0, #0x01
-        BEQ     memif_shared_init_poll
-
-        /* Return to my caller */
-        mov	pc, lr
-
-/*****************************************************************************
- *
- * register_initialisation
- *
- * Description: Initialise some CPU registers
- *
- * Note:
- * Used to prevent X propagation if running this code in a simulation
- *
- *****************************************************************************/
-register_initialisation:
-
-        mov     r0, #0x00000000
-        mov     r1, #0x00000000
-        mov     r2, #0x00000000
-        mov     r3, #0x00000000
-        mov     r4, #0x00000000
-        mov     r5, #0x00000000
-        mov     r6, #0x00000000
-        mov     r7, #0x00000000
-        mov     r8, #0x00000000
-        mov     r9, #0x00000000
-        mov     r10,#0x00000000
-
-        /* Don't noodle with r11 (fp)
-                             r12 (ip)
-                             r13 (sp)
-                             r14 (lr)
-                             r15 (pc)
-           as this would cause big probs ! */
+        tst     r0, #0x01
+        beq     memif_shared_init_poll
 
         /* Return to my caller */
         mov	pc, lr
@@ -385,7 +351,7 @@ register_initialisation:
  initialiseBootErrorPin:
 
         /* Get base address of the arm gpio block */
-        ldr     r0,=PC302_GPIO_BASE
+        ldr     r0,=PICOXCELL_GPIO_BASE
 
         /* Negate the Boot error pin (in the data register) */
         ldr     r1,[r0, #GPIO_SW_PORT_C_DR_REG_OFFSET]
@@ -414,7 +380,7 @@ register_initialisation:
  assertBootError:
 
         /* Get base address of the arm gpio block */
-        ldr     r0,=PC302_GPIO_BASE
+        ldr     r0,=PICOXCELL_GPIO_BASE
 
         /* Assert the Boot Error pin */
         mov     r1, #ASSERT_BOOT_ERROR_PIN
@@ -422,5 +388,3 @@ register_initialisation:
 
         /* Return to my caller */
         mov	pc, lr
-
-       .end
diff --git a/board/picochip/pc7302/mt29f2g08aadwp.c b/board/picochip/pc7302/mt29f2g08aadwp.c
index 88190d2..9c1408c 100644
--- a/board/picochip/pc7302/mt29f2g08aadwp.c
+++ b/board/picochip/pc7302/mt29f2g08aadwp.c
@@ -38,17 +38,15 @@
  * MA 02111-1307 USA
  */
 
-
-
 /* Includes ---------------------------------------------------------------- */
 #include <common.h>
 
 #ifdef CONFIG_CMD_NAND
 
-#include <asm/arch/pc302.h>
+#include <asm/arch/picoxcell.h>
 #include <nand.h>
 #include <asm/arch/utilities.h>
-#include <asm/arch/pc3xxgpio.h>
+#include <asm/arch/picoxcell_gpio.h>
 #include <asm/arch/mux.h>
 #include <asm/arch/axi2cfg.h>
 
@@ -66,53 +64,42 @@ static unsigned int rdy;
  * \param ctrl, control data to set up the transaction
  *
  */
-static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
-				    int dat,
-				    unsigned int ctrl)
+static void mt29f2g08aadwp_cmd_ctrl (struct mtd_info *mtd,
+				     int dat, unsigned int ctrl)
 {
-    struct nand_chip *this = mtd->priv;
-
-    if (ctrl & NAND_CTRL_CHANGE)
-    {
-        if (ctrl & NAND_NCE)
-        {
-            /* Assert the chip select */
-            pc3xx_gpio_set_value(nce, 0);
-
-	    if (ctrl & NAND_CLE)
-            {
-	        /* Assert CLE */
-                pc3xx_gpio_set_value(cle, 1);
-            }
-    	    else
-	    {
-                /* Negate CLE */
-                pc3xx_gpio_set_value(cle, 0);
-            }
-
-	    if (ctrl & NAND_ALE)
-	    {
-                /* Assert ALE */
-                pc3xx_gpio_set_value(ale, 1);
-            }
-	    else
-            {
-		/* Negate ALE */
-                pc3xx_gpio_set_value(ale, 0);
-            }
-        }
-        else
-        {
-	    /* Negate the chip select */
-            pc3xx_gpio_set_value(nce, 1);
-        }
-    }
-
-    /* If we have data to write, write it */
-    if (dat != NAND_CMD_NONE)
-    {
-	*(volatile unsigned char *)(this->IO_ADDR_W) = (unsigned char)dat;
-    }
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			/* Assert the chip select */
+			picoxcell_gpio_set_value (nce, 0);
+
+			if (ctrl & NAND_CLE) {
+				/* Assert CLE */
+				picoxcell_gpio_set_value (cle, 1);
+			} else {
+				/* Negate CLE */
+				picoxcell_gpio_set_value (cle, 0);
+			}
+
+			if (ctrl & NAND_ALE) {
+				/* Assert ALE */
+				picoxcell_gpio_set_value (ale, 1);
+			} else {
+				/* Negate ALE */
+				picoxcell_gpio_set_value (ale, 0);
+			}
+		} else {
+			/* Negate the chip select */
+			picoxcell_gpio_set_value (nce, 1);
+		}
+	}
+
+	/* If we have data to write, write it */
+	if (dat != NAND_CMD_NONE) {
+		*(volatile unsigned char *)(this->IO_ADDR_W) =
+		    (unsigned char)dat;
+	}
 }
 
 /*!
@@ -122,9 +109,9 @@ static void mt29f2g08aadwp_cmd_ctrl(struct mtd_info *mtd,
  *         1 - nand ready
  *
  */
-static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
+static int mt29f2g08aadwp_dev_ready (struct mtd_info *mtd)
 {
-    return pc3xx_gpio_get_value(rdy);
+	return picoxcell_gpio_get_value (rdy);
 }
 
 /*
@@ -145,55 +132,52 @@ static int mt29f2g08aadwp_dev_ready(struct mtd_info *mtd)
  * Members with a "?" were not set in the merged testing-NAND branch,
  * so they are not set here either.
  */
-int board_nand_init(struct nand_chip *nand)
+int board_nand_init (struct nand_chip *nand)
 {
-    /* Define which gpio bits are used to control the NAND Flash
-     *
-     * Note: These pin definitions mean that we can only use NAND
-     *       Flash if we are running U-Boot from RAM and have NOT booted
-     *       the device from parallel NOR Flash.
-     */
-    if (is_pc3x3())
-    {
-        cle = PC3X3_GPIO_PIN_ARM_4;
-        ale = PC3X3_GPIO_PIN_ARM_3;
-        nce = PC3X3_GPIO_PIN_ARM_2;
-        rdy = PC3X3_GPIO_PIN_ARM_1;
-
-        /* Setup some pin muxing */
-        pc3xx_group_set_mux ("pai_tx_data[3:0]", MUX_PERIPHERAL);
-        pc3xx_pin_set_mux(PC3X3_GPIO_PIN_ARM_4, MUX_ARM);
-    }
-    else
-    {
-        cle = PC302_GPIO_PIN_ARM_4;
-        ale = PC302_GPIO_PIN_ARM_3;
-        nce = PC302_GPIO_PIN_ARM_2;
-        rdy = PC302_GPIO_PIN_ARM_1;
-
-        /* Setup some pin muxing */
-        pc3xx_pin_set_mux(PC302_GPIO_PIN_ARM_4, MUX_ARM);
-    }
-
-    /* Request the required gpio pins */
-    (void)pc3xx_gpio_request(rdy);
-    (void)pc3xx_gpio_request(nce);
-    (void)pc3xx_gpio_request(ale);
-    (void)pc3xx_gpio_request(cle);
-
-    /* Initialise the pin direction */
-    (void)pc3xx_gpio_direction_input(rdy );
-    (void)pc3xx_gpio_direction_output(nce, 1);
-    (void)pc3xx_gpio_direction_output(ale, 0);
-    (void)pc3xx_gpio_direction_output(cle, 0);
-
-    /* Populate some members of the nand structure */
-    nand->cmd_ctrl = mt29f2g08aadwp_cmd_ctrl;
-    nand->ecc.mode = NAND_ECC_SOFT;
-    nand->dev_ready = mt29f2g08aadwp_dev_ready;
-    nand->IO_ADDR_R = (void __iomem *)CONFIG_SYS_NAND_BASE;
-    nand->IO_ADDR_W = (void __iomem *)CONFIG_SYS_NAND_BASE;
-
-    return 0;
+	/* Define which gpio bits are used to control the NAND Flash
+	 *
+	 * Note: These pin definitions mean that we can only use NAND
+	 *       Flash if we are running U-Boot from RAM and have NOT booted
+	 *       the device from parallel NOR Flash.
+	 */
+	if (is_pc3x3 ()) {
+		cle = PC3X3_GPIO_PIN_ARM_4;
+		ale = PC3X3_GPIO_PIN_ARM_3;
+		nce = PC3X3_GPIO_PIN_ARM_2;
+		rdy = PC3X3_GPIO_PIN_ARM_1;
+
+		/* Setup some pin muxing */
+		picoxcell_group_set_mux ("pai_tx_data[3:0]", MUX_PERIPHERAL);
+		picoxcell_pin_set_mux (PC3X3_GPIO_PIN_ARM_4, MUX_ARM);
+	} else {
+		cle = PC302_GPIO_PIN_ARM_4;
+		ale = PC302_GPIO_PIN_ARM_3;
+		nce = PC302_GPIO_PIN_ARM_2;
+		rdy = PC302_GPIO_PIN_ARM_1;
+
+		/* Setup some pin muxing */
+		picoxcell_pin_set_mux (PC302_GPIO_PIN_ARM_4, MUX_ARM);
+	}
+
+	/* Request the required gpio pins */
+	(void)picoxcell_gpio_request (rdy);
+	(void)picoxcell_gpio_request (nce);
+	(void)picoxcell_gpio_request (ale);
+	(void)picoxcell_gpio_request (cle);
+
+	/* Initialise the pin direction */
+	(void)picoxcell_gpio_direction_input (rdy);
+	(void)picoxcell_gpio_direction_output (nce, 1);
+	(void)picoxcell_gpio_direction_output (ale, 0);
+	(void)picoxcell_gpio_direction_output (cle, 0);
+
+	/* Populate some members of the nand structure */
+	nand->cmd_ctrl = mt29f2g08aadwp_cmd_ctrl;
+	nand->ecc.mode = NAND_ECC_SOFT;
+	nand->dev_ready = mt29f2g08aadwp_dev_ready;
+	nand->IO_ADDR_R = (void __iomem *)CONFIG_SYS_NAND_BASE;
+	nand->IO_ADDR_W = (void __iomem *)CONFIG_SYS_NAND_BASE;
+
+	return 0;
 }
 #endif /* CONFIG_CMD_NAND */
diff --git a/board/picochip/pc7302/pc7302.c b/board/picochip/pc7302/pc7302.c
index 259d7a7..d61ec67 100644
--- a/board/picochip/pc7302/pc7302.c
+++ b/board/picochip/pc7302/pc7302.c
@@ -20,7 +20,7 @@
 #include <asm/arch/timer.h>
 #include <asm/arch/utilities.h>
 #include <asm/arch/mux.h>
-#include <asm/arch/pc3xxgpio.h>
+#include <asm/arch/picoxcell_gpio.h>
 #include <netdev.h>
 
 /* Macros ------------------------------------------------------------------ */
@@ -36,7 +36,7 @@ DECLARE_GLOBAL_DATA_PTR;
  * \param timer, the timer to start
  *
  */
-static void pc302_timer_start(int timer);
+static void picoxcell_timer_start (int timer);
 
 /* Functions --------------------------------------------------------------- */
 
@@ -50,9 +50,9 @@ static void pc302_timer_start(int timer);
  *
  *****************************************************************************/
 #if defined(CONFIG_SHOW_BOOT_PROGRESS)
-void show_boot_progress(int progress)
+void show_boot_progress (int progress)
 {
-	printf("Boot reached stage %d\n", progress);
+	printf ("Boot reached stage %d\n", progress);
 }
 #endif
 
@@ -67,27 +67,27 @@ void show_boot_progress(int progress)
  *****************************************************************************/
 int board_init (void)
 {
-    /* Setup some kernel boot parameters */
-    gd->bd->bi_boot_params = 0x00000100;
+	/* Setup some kernel boot parameters */
+	gd->bd->bi_boot_params = 0x00000100;
 
-    /* Setup the machine type */
-    gd->bd->bi_arch_number = MACH_TYPE_PC7302;
+	/* Setup the machine type */
+	gd->bd->bi_arch_number = MACH_TYPE_PC7302;
 
-    gd->flags = 0;
+	gd->flags = 0;
 
-    /* Enable the Instruction Cache */
-    icache_enable ();
+	/* Enable the Instruction Cache */
+	icache_enable ();
 
-    /* Start timer #0 */
-    pc302_timer_start(0);
+	/* Start timer #0 */
+	picoxcell_timer_start (0);
 
-    /* Initialise the gpio muxing library */
-    pc3xx_muxing_init();
+	/* Initialise the gpio muxing library */
+	picoxcell_muxing_init ();
 
-    /* Initialise the gpio library */
-    pc3xx_gpio_init();
+	/* Initialise the gpio library */
+	picoxcell_gpio_init ();
 
-    return 0;
+	return 0;
 }
 
 /*****************************************************************************
@@ -101,9 +101,9 @@ int board_init (void)
  *****************************************************************************/
 int checkboard (void)
 {
-    printf("Board: Picochip "PICOCHIP_PLATFORM" \n");
+	printf ("Board: Picochip " PICOCHIP_PLATFORM " \n");
 
-    return 0;
+	return 0;
 }
 
 /*****************************************************************************
@@ -115,52 +115,37 @@ int checkboard (void)
  * Returns: 0 - Success
  *
  *****************************************************************************/
-int print_cpuinfo(void)
+int print_cpuinfo (void)
 {
-    unsigned int device_id, device_rev;
-    unsigned int die_id[4];
-
-    /* What device are we running on ? */
-    printf("CPU:   ");
-
-    device_id = pc302_read_device_id();         /* Read the device id */
-    device_rev = pc302_read_device_revision();  /* Read the revision code */
-    pc302_read_die_id_number(&die_id[0]);       /* Read the die id */
-
-    switch (device_id)
-    {
-        case PC302_DEVICE_ID:
-        {
-            printf("PC302 Rev %04d\n", device_rev);
-            break;
-        }
-        case PC312_DEVICE_ID:
-        {
-            printf("PC312 Rev %04d\n", device_rev);
-            break;
-        }
-        case PC313_DEVICE_ID:
-        {
-            printf("PC313 Rev %04d\n", device_rev);
-            break;
-        }
-        case PC323_DEVICE_ID:
-        {
-            printf("PC323 Rev %04d\n", device_rev);
-            break;
-        }
-        case PC333_DEVICE_ID:
-        {
-            printf("PC333 Rev %04d\n", device_rev);
-            break;
-        }
-        default:
-        {
-            printf("Unknown !\n");
-        }
-    }
-
-    return 0;
+	unsigned int device_id, device_rev;
+
+	/* What device are we running on ? */
+	printf ("CPU:   ");
+
+	device_id = picoxcell_get_device_id ();	/* Read the device id */
+	device_rev = picoxcell_get_revision ();	/* Read the revision code */
+
+	switch (device_id) {
+	case PC302_DEVICE_ID:
+		printf ("PC302 Rev %04d\n", device_rev);
+		break;
+	case PC312_DEVICE_ID:
+		printf ("PC312 Rev %04d\n", device_rev);
+		break;
+	case PC313_DEVICE_ID:
+		printf ("PC313 Rev %04d\n", device_rev);
+		break;
+	case PC323_DEVICE_ID:
+		printf ("PC323 Rev %04d\n", device_rev);
+		break;
+	case PC333_DEVICE_ID:
+		printf ("PC333 Rev %04d\n", device_rev);
+		break;
+	default:
+		printf ("Unknown !\n");
+	}
+
+	return 0;
 }
 
 /*****************************************************************************
@@ -174,8 +159,8 @@ int print_cpuinfo(void)
  *****************************************************************************/
 int misc_init_r (void)
 {
-    /* Not used right now, function template left here as a place holder */
-    return 0;
+	/* Not used right now, function template left here as a place holder */
+	return 0;
 }
 
 /*****************************************************************************
@@ -189,38 +174,37 @@ int misc_init_r (void)
  *****************************************************************************/
 int dram_init (void)
 {
-    gd->ram_size =
-        get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+	gd->ram_size = get_ram_size ((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
 
-    return 0;
+	return 0;
 }
 
-void dram_init_banksize(void)
+void dram_init_banksize (void)
 {
-    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-    gd->bd->bi_dram[0].size =
-        get_ram_size((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size =
+	    get_ram_size ((long *)PHYS_SDRAM_1, PHYS_SDRAM_1_SIZE);
 }
 
-static void pc302_timer_start(int timer)
+static void picoxcell_timer_start (int timer)
 {
-    /* Make sure the timer is disabled */
-    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
-                               TIMERNCONTROLREGOFFSET (timer) ),
-                              0 );
-
-    /* Initialise the timer to all 1's.
-     * We do this  because we want to run
-     * the timer in free running mode.
-     */
-    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
-                               TIMERNLOADCOUNTREGOFFSET (timer) ),
-                              0xFFFFFFFF );
-
-    /* Start the timer in free running mode */
-    pc302_write_to_register( ( CONFIG_SYS_TIMERBASE +
-                               TIMERNCONTROLREGOFFSET (timer) ),
-                             ( TIMERINTERRUPTMASK | TIMERENABLE ) );
+	/* Make sure the timer is disabled */
+	picoxcell_write_register (0, (CONFIG_SYS_TIMERBASE +
+				      TIMERNCONTROLREGOFFSET (timer)));
+
+	/* Initialise the timer to all 1's.
+	 * We do this  because we want to run
+	 * the timer in free running mode.
+	 */
+	picoxcell_write_register (0xFFFFFFFF, (CONFIG_SYS_TIMERBASE +
+					       TIMERNLOADCOUNTREGOFFSET
+					       (timer)));
+
+	/* Start the timer in free running mode */
+	picoxcell_write_register ((TIMERINTERRUPTMASK | TIMERENABLE),
+				  (CONFIG_SYS_TIMERBASE +
+				   TIMERNCONTROLREGOFFSET (timer)));
+
 }
 
 /*****************************************************************************
@@ -233,13 +217,13 @@ static void pc302_timer_start(int timer)
  *
  *****************************************************************************/
 
-int board_eth_init(bd_t *bis)
+int board_eth_init (bd_t * bis)
 {
-    int ret = -1;
+	int ret = -1;
 
 #ifdef CONFIG_DW_EMAC
-    ret = pc302_eth_register(bis);
+	ret = picoxcell_eth_register (bis);
 #endif
 
-    return ret;
+	return ret;
 }
diff --git a/include/configs/picochippc7302-common.h b/include/configs/picochippc7302-common.h
index fabb66b..da8384f 100644
--- a/include/configs/picochippc7302-common.h
+++ b/include/configs/picochippc7302-common.h
@@ -15,10 +15,10 @@
 * All enquiries to support@picochip.com
 */
 
-#ifndef __CONFIG_H
-#define __CONFIG_H
+#ifndef __CONFIG_PC7302_H
+#define __CONFIG_PC7302_H
 
-#include <asm/arch/pc302.h>
+#include <asm/arch/picoxcell.h>
 #include <asm/arch/uart.h>
 #include <asm/sizes.h>
 
@@ -50,15 +50,12 @@
 /* Running on a Picochip PC7302 platform */
 #define CONFIG_PICOCHIP_PC7302
 
-/* Bootable Flash memory has to live here (/ebi_decode0) */
-#define PC302_BOOTABLE_FLASH_BASE   (PC302_FLASH_BASE)
-
 /* Base address of the onchip SRAM */
-#define PC302_ONCHIP_SRAM_BASE      (PC302_SRAM_BASE)
-#define PC302_ONCHIP_SRAM_SIZE      (PC302_SRAM_SIZE)
+#define PICOXCELL_ONCHIP_SRAM_BASE      (PICOXCELL_SRAM_BASE)
+#define PICOXCELL_ONCHIP_SRAM_SIZE      (PICOXCELL_SRAM_SIZE)
 
 /* ARM Sub-system peripherals are clocked at 200MHz */
-#define PC302_AHB_CLOCK_FREQ        (200000000)
+#define PICOXCELL_AHB_CLOCK_FREQ        (200000000)
 
 /* Don't use Interrupts */
 #undef CONFIG_USE_IRQ
@@ -115,7 +112,7 @@
  */
 #define CONFIG_SYS_SDRAM_BASE	(0x00000000)
 #define CONFIG_NR_DRAM_BANKS    (1)
-#define PHYS_SDRAM_1		(PC302_DDRBANK_BASE)
+#define PHYS_SDRAM_1		(PICOXCELL_DDRBANK_BASE)
 #define PHYS_SDRAM_1_SIZE	(SZ_128M)
 
 /*-----------------------------------------------------------------------------
@@ -150,7 +147,7 @@
 /*-----------------------------------------------------------------------------
  * Timer Stuff
  */
-#define CONFIG_SYS_TIMERBASE    (PC302_TIMER_BASE)
+#define CONFIG_SYS_TIMERBASE    (PICOXCELL_TIMER_BASE)
 
 /*-----------------------------------------------------------------------------
  * Ethernet Stuff
@@ -166,7 +163,7 @@
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE (-4)
 #define CONFIG_SYS_NS16550_CLK      (3686400)
-#define CONFIG_SYS_NS16550_COM1     (PC302_UART1_BASE)
+#define CONFIG_SYS_NS16550_COM1     (PICOXCELL_UART1_BASE)
 
 /* Our uart registers need 32 bit access */ 
 #define CONFIG_SYS_NS16550_MEM32
@@ -183,17 +180,17 @@
  * U-Boot Memory Test (mtest command) Stuff
  */
 /* Default start address for memory test */
-#define CONFIG_SYS_MEMTEST_START    (PC302_ONCHIP_SRAM_BASE)
+#define CONFIG_SYS_MEMTEST_START    (PICOXCELL_ONCHIP_SRAM_BASE)
 
 /* Default end address for memory test */
 #define CONFIG_SYS_MEMTEST_END  (CONFIG_SYS_MEMTEST_START + \
-                                 PC302_ONCHIP_SRAM_SIZE - 1)
+                                 PICOXCELL_ONCHIP_SRAM_SIZE - 1)
 
 /* Define this to use the super duper memory test */
 #define CONFIG_SYS_ALT_MEMTEST
 
 /* Use Uart #1 scratch pad reg */
-#define CONFIG_SYS_MEMTEST_SCRATCH  (PC302_UART1_BASE + \
+#define CONFIG_SYS_MEMTEST_SCRATCH  (PICOXCELL_UART1_BASE + \
                                      UART_SCRATCH_REG_OFFSET)
 
 /*-----------------------------------------------------------------------------
@@ -389,4 +386,4 @@
     #endif
 #endif
 
-#endif /* __CONFIG_H */
+#endif /* __CONFIG_PC7302_H */
diff --git a/include/configs/picochippc7302nand.h b/include/configs/picochippc7302nand.h
index 35bc317..83d0c30 100644
--- a/include/configs/picochippc7302nand.h
+++ b/include/configs/picochippc7302nand.h
@@ -18,15 +18,15 @@
 #ifndef __CONFIG_PC7302_NAND__
 #define __CONFIG_PC7302_NAND__
 
-#include <asm/arch/pc302.h>
+#include <asm/arch/picoxcell.h>
 #include <asm/sizes.h>
 
 /*-----------------------------------------------------------------------------
  * NAND Flash Memory Stuff
  */
-#define CONFIG_SYS_NAND_BASE        PC302_EBI_CS2_BASE
-#define CONFIG_SYS_NAND_MAX_CHIPS   1
-#define CONFIG_SYS_MAX_NAND_DEVICE  1
+#define CONFIG_SYS_NAND_BASE        (PICOXCELL_EBI_CS2_BASE)
+#define CONFIG_SYS_NAND_MAX_CHIPS   (1)
+#define CONFIG_SYS_MAX_NAND_DEVICE  (1)
 
 /* Define Flash memory sector size */
 #define NAND_FLASH_SECTOR_SIZE      (SZ_128K)
@@ -79,7 +79,7 @@
 #define CONFIG_USE_UBIFS
 
 /* Build U-Boot to run at this address */
-#define CONFIG_SYS_TEXT_BASE 0x06000000
+#define CONFIG_SYS_TEXT_BASE    0x06000000
 
 #include <configs/picochippc7302-common.h>
 
diff --git a/include/configs/picochippc7302nor.h b/include/configs/picochippc7302nor.h
index 603d5bb..1677206 100644
--- a/include/configs/picochippc7302nor.h
+++ b/include/configs/picochippc7302nor.h
@@ -18,11 +18,11 @@
 #ifndef __CONFIG_PC7302_NOR__
 #define __CONFIG_PC7302_NOR__
 
-#include <asm/arch/pc302.h>
+#include <asm/arch/picoxcell.h>
 #include <asm/sizes.h>
 
 /* Start address of the flash memory */
-#define CONFIG_SYS_FLASH_BASE   (PC302_BOOTABLE_FLASH_BASE)
+#define CONFIG_SYS_FLASH_BASE   (PICOXCELL_FLASH_BASE)
 
 /* Define Flash memory sector size */
 #define FLASH_SECTOR_SIZE	(SZ_128K)
@@ -57,7 +57,7 @@
 #define CONFIG_ENV_IS_IN_FLASH
 
 /* Start address of environment variables */
-#define CONFIG_ENV_ADDR         (PC302_BOOTABLE_FLASH_BASE + CONFIG_SYS_MONITOR_LEN)
+#define CONFIG_ENV_ADDR         (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
 
 /* One flash sector for environment varisbles */
 #define CONFIG_ENV_SECT_SIZE    (FLASH_SECTOR_SIZE)
diff --git a/include/netdev.h b/include/netdev.h
index af42e3b..2818749 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -104,7 +104,7 @@ int xilinx_emaclite_initialize(bd_t *bis, unsigned long base_addr,
 							int txpp, int rxpp);
 int xilinx_ll_temac_eth_init(bd_t *bis, unsigned long base_addr, int flags,
 						unsigned long ctrl_addr);
-int pc302_eth_register(bd_t *bis);
+int picoxcell_eth_register(bd_t *bis);
 
 /*
  * As long as the Xilinx xps_ll_temac ethernet driver has not its own interface
-- 
1.7.0.4

